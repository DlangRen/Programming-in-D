Ddoc

$(DERS_BOLUMU $(IX slice) $(IX 数组) 切片和其它的数组特征)

$(P
在 $(LINK2 /ders/d.cn/arrays.html, 数组) 一章中我们已经看到元素是如何被整理为一个数组中的集合。那章是比较简短，数组的大部分特征都留在这一章来讲。
)

$(P
在细讲特征之前，先简单介绍一些意思相近的术语：
)

$(UL

$(LI $(B 数组：) 通常是指被逐个放置并通过索引来访问的一组元素。
)

$(LI
$(B 定长数组（静态数组）：) 有固定数量元素的数组。该类型数组拥有自己的元素。
)

$(LI
$(B 动态数组：)能获得或失去元素的数组。该类数组允许访问受 D 运行时环境管理的元素。
)

$(LI $(B 切片：)$(I 动态数组)的另一名称。
)

)

$(P
书中的 $(I slice) 特指 slice（切片）；$(I 数组)指 slice 或定长数组，没有区别。
)

$(H5 切片)

$(P
切片与动态数组的特征一致。当它的用法像数组时称为$(I 动态数组)，当它可以访问别的数组接口时称为$(I 切片)。它们允许使用那些接口，就像它们是独立的数组。
)

$(P
$(IX .., 切片元素范围) 切片由$(I 数量范围)语法定义，该语法与范围的开始、结束索引相对应：
)

---
  $(I 开始索引) .. $(I 超出的结束索引)
---

$(P
在数量范围的语法中，开始索引是范围的一部分，但结束索引在范围之外：
)

---
/* ... */ = monthDays[0 .. 3];  // 0，1，和 2 包括在内，但不含 3
---

$(P
$(I $(B 注：)数量范围与 Phobos 的 range 不同。Phobos 的 range 与 struct 和 class 接口有关。在后面的章节中我们将看到这些特征。
)
)

$(P
举个例子，我们$(I 裁减)一下 $(C monthDays) 数组，以便把它用作四个小数组：
)

---
    int[12] monthDays =
        [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];

    int[] firstQuarter  = monthDays[0 .. 3];
    int[] secondQuarter = monthDays[3 .. 6];
    int[] thirdQuarter  = monthDays[6 .. 9];
    int[] fourthQuarter = monthDays[9 .. 12];
---

$(P
上面代码中的四个变量就是切片；它们可以访问现有数组的四个部分。值得强调的一点是，这些切片不拥有自己的元素。它们只能访问实际数组的元素。修改切片的元素就会修改实际数组的元素。让我们修改一下每个切片的第一个元素，然后打印实际的数组来看一看：
)

---
    firstQuarter[0]  = 1;
    secondQuarter[0] = 2;
    thirdQuarter[0]  = 3;
    fourthQuarter[0] = 4;

    writeln(monthDays);
---

$(P
输出：
)

$(SHELL
[$(HILITE 1), 28, 31, $(HILITE 2), 31, 30, $(HILITE 3), 31, 30, $(HILITE 4), 30, 31]
)

$(P
每个切片修改了第一个元素，实际数组的相应元素受到了影响。
)

$(P
前面我们已经看到，有效的数组索引是从 0 到一个小于数组长度的值。例如，3 个元素数组的有效索引是 0，1 和 2。同样地，在切片语法中结束索引特指超过切片能访问的最后一个元素的索引。因此，当需要把数组的最后一个元素包括在切片中时，就必须把数组的长度值指定为结束索引。例如，一个包含 3 个元素数组的全部元素的切片会是 $(C array[0..3])。
)

$(P
一个明显的限制是开始索引不能大于结束索引：
)

---
    int[3] array = [ 0, 1, 2 ];
    int[] slice = array[2 .. 1];  // ←运行时错误
---

$(P
开始索引和结束索引相等是合法的。这种情况下切片是空的。假设 $(C index) 有效：
)

---
    int[] slice = anArray[index .. index];
    writeln("The length of the slice: ", slice.length);
---

$(P
输出：
)

$(SHELL
The length of the slice: 0
)

$(H5 $(IX $, 切片长度)使用 $(C $)，而不是 $(C array.length))

$(P
在索引中，$(C $) 是数组长度的简写：
)

---
    writeln(array[array.length - 1]);  // 最后一个元素
    writeln(array[$ - 1]);             // 同上
---

$(H5 $(IX .dup) $(IX 复制, 数组) 使用 $(C .dup) 复制)

$(P
作为“duplicate（复制）”的简写，$(C .dup) property（属性）从现有数组元素的副本中生成一个新的数组：
)

---
    double[] array = [ 1.25, 3.75 ];
    double[] theCopy = array.dup;
---

$(P
作为一个例子，让我们来定义一个包含某个闰年的月份天数的数组。一种方法是取非闰年数组的一个副本，然后递增相应的二月份的元素：
)

---
import std.stdio;

void main() {
    int[12] monthDays =
        [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];

    int[] leapYear = monthDays$(HILITE .dup);

    ++leapYear[1];   // 递增二用份的天数

    writeln("Non-leap year: ", monthDays);
    writeln("Leap year    : ", leapYear);
}
---

$(P
输出：
)

$(SHELL_SMALL
Non-leap year: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
Leap year    : [31, $(HILITE 29), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
)

$(H5 $(IX 赋值, 数组) 赋值)

$(P
到目前为止，我们已经看到赋值运算符可以$(I 修改)变量的值。对定长数组这个同样有效：
)

---
    int[3] a = [ 1, 1, 1 ];
    int[3] b = [ 2, 2, 2 ];

    a = b;        // ‘a’的元素变为了 2
    writeln(a);
---

$(P
输出：
)

$(SHELL
[2, 2, 2]
)

$(P
赋值操作对切片有完全不同的含义：它让切片可以访问新元素：
)

---
    int[] odds = [ 1, 3, 5, 7, 9, 11 ];
    int[] evens = [ 2, 4, 6, 8, 10 ];

    int[] slice;   // 还不能访问任何元素

    $(HILITE slice =) odds[2 .. $ - 2];
    writeln(slice);

    $(HILITE slice =) evens[1 .. $ - 1];
    writeln(slice);
---

$(P
上面的 $(C slice) 在定义时不能访问任何元素。赋值后它就可以访问 $(C odds) 数组的部分元素，以及后来可以访问 $(C evens) 数组的部分元素：
)

$(SHELL
[5, 7]
[4, 6, 8]
)

$(H5 生成更长的切片可以终止共享)

$(P
由于定长数组的长度不能修改，因此$(I 终止共享)的概念仅与切片有关。
)

$(P
可以让一个以上的切片来访问相同的元素。例如，通过三个切片可以访问下面八个元素中的前两个：
)

---
import std.stdio;

void main() {
    int[] slice = [ 1, 3, 5, 7, 9, 11, 13, 15 ];
    int[] half = slice[0 .. $ / 2];
    int[] quarter = slice[0 .. $ / 4];

    quarter[1] = 0;     // 通过一个切片修改

    writeln(quarter);
    writeln(half);
    writeln(slice);
}
---

$(P
通过所有的切片可以看到修改 $(C quarter) 的第二个元素所产生的效果：
)

$(SHELL
[1, $(HILITE 0)]
[1, $(HILITE 0), 5, 7]
[1, $(HILITE 0), 5, 7, 9, 11, 13, 15]
)

$(P
$(IX stomping) 当这样查看时, 切片提供元素的$(I 共享)访问。当给这样的切片添加新元素时，这种共享可能会有麻烦。由于多个切片可以访问相同的元素，若切片没有空间添加元素，那么在别的切片元素上就没有 $(I stomping（覆盖）)。
)

$(P
如果没有为新元素留出空间，D 就不允许元素 stomping，并且通过终止共享关系来回应这个问题：没有成长空间的切片会停止共享。当这种情况发生时，切片所有的现有元素都被自动复制到一个新的地方，然后切片会提供对这些新元素的访问。
)

$(P
为看到这种行为，让我们在修改第二个元素之前给 $(C quarter) 添加一个元素：
)

---
    quarter ~= 42;    // 切片停止了共享，因为
                      // 没有为新元素留出空间

    quarter[1] = 0;   //因此，这样的修改
                      // 不会影响到别的切片
---

$(P
程序的输出显示，对 $(C quarter) 切片的修改没有影响到其它切片：
)

$(SHELL
[1, $(HILITE 0), 42]
[1, 3, 5, 7]
[1, 3, 5, 7, 9, 11, 13, 15]
)

$(P
明确增加切片的长度也会让它远离共享：
)

---
    ++quarter.length;       // 没有共享
---

$(P
或者
)

---
    quarter.length += 5;    // 没有共享
---

$(P
另一方面，缩短切片不会影响共享。缩短切片仅仅意味着切片可以访问较少的元素：
)

---
    int[] a = [ 1, 11, 111 ];
    int[] d = a;

    d = d[1 .. $];  // 从开始位置缩短
    d[0] = 42;      // 通过切片修改元素

    writeln(a);     // 输出别的切片
---

$(P
从输出中可以看出，通过 $(C a) 可以看到对 $(C d) 的修改；共享仍然有效：
)

$(SHELL
[1, $(HILITE 42), 111]
)

$(P
以不同方式减少长度都不会终止共享：
)

---
    d = d[0 .. $ - 1];         // 从末端缩短
    --d.length;                // 同上
    d.length = d.length - 1;   // 同上
---

$(P
元素的共享仍然有效。
)

$(H6 $(IX .capacity) 使用 $(C capacity) 来确定是否会终止共享)

$(P
有时候，在元素添加到其中的一个切片后，切片仍继续共享元素。这是因为，当元素添加到最长的切片上时，在末端留有空间：
)

---
import std.stdio;

void main() {
    int[] slice = [ 1, 3, 5, 7, 9, 11, 13, 15 ];
    int[] half = slice[0 .. $ / 2];
    int[] quarter = slice[0 .. $ / 4];

    slice ~= 42;      // 添加到最长的切片上 ...
    $(HILITE slice[1] = 0);     // ... 修改一个元素

    writeln(quarter);
    writeln(half);
    writeln(slice);
}
---

$(P
在输出中可以看到，虽然添加元素增加了切片的长度，共享还没有终止，通过所有的切片可以看到修改：:
)

$(SHELL
[1, $(HILITE 0)]
[1, $(HILITE 0), 5, 7]
[1, $(HILITE 0), 5, 7, 9, 11, 13, 15, 42]
)

$(P
一个元素添加到特定切片上时，切片的 $(C capacity) property（属性）决定了共享是否会终止。虽然 ($(C capacity) 实际上是个函数，但讨论这种差别没有任何意义。)
)

$(P
$(C capacity) 的值具有如下含义：
)

$(UL

$(LI
值为 0，表示这不是最长的原始切片。在这种情况下，添加新元素一定会迁移切片的元素，并且共享将终止。
)

$(LI
值为非零时，则表示这是最长的原始切片。这种情况下， $(C capacity) 表示切片拥有的不需要被复制的元素总数。可以加入的 $(I 新元素) 的数量可以通过从容量值中减去切片的实际长度来计算。如果切片的长度等于它的容量，那么添加一个以上的元素时，切片将被复制到新的位置。)

)

$(P
因此，需要确定共享是否终止的程序可以使用类似于下面的逻辑：
)

---
    if (slice.capacity == 0) {
        /* 如果一个以上的元素添加到切片上时，它的元素
         * 的位置会迁移。*/

        // ...

    } else {
        /* 在切片迁移之前，切片还有空间
         * 存储新元素。让我们计算
         * 一下还需要多少：*/
        auto howManyNewElements = slice.capacity - slice.length;

        // ...
    }
---

$(P
一个有趣的不引人注意的情况是，当有一个以上的切片拥有$(I 所有的元素)时，这种情况下，所有的切片都会报告有 capacity：
)

---
import std.stdio;

void main() {
    // 三个切片拥有全部元素
    int[] s0 = [ 1, 2, 3, 4 ];
    int[] s1 = s0;
    int[] s2 = s0;

    writeln(s0.capacity);
    writeln(s1.capacity);
    writeln(s2.capacity);
}
---

$(P
三个都有 capacity：
)

$(SHELL
7
7
7
)

$(P
然而，一旦其中的一个切片添加了一个元素， 其它切片的容量就降为了 0：
)

---
    $(HILITE s1 ~= 42);    $(CODE_NOTE s1 变为了最长的)

    writeln(s0.capacity);
    writeln(s1.capacity);
    writeln(s2.capacity);
---

$(P
由于现在最长的切片是添加元素的那个，它是唯一有 capacity 的切片：
)

$(SHELL
0
7        $(SHELL_NOTE 现在只有 s1 有 capacity)
0
)

$(H6 $(IX .reserve) 为元素预留空间)

$(P
无论复制元素还是分配新内存对增加 capacity 都有一定的成本。因此，附加元素应该是一个昂贵的操作。当要附加的元素数目已知时，就可以为元素预留容量：
)

---
import std.stdio;

void main() {
    int[] slice;

    slice$(HILITE .reserve(20));
    writeln(slice.capacity);

    foreach (element; 0 .. $(HILITE 17)) {
        slice ~= element;  $(CODE_NOTE 这些元素将不会移动)
    }
}
---

$(SHELL
31        $(SHELL_NOTE 至少有 20 个元素的容量)
)

$(P
$(C slice) 的元素在超过 31 个时将会移动。
)

$(H5 $(IX 数组方式操作) $(IX 元素, 全部操作)所有元素上的操作)

$(P
定长数组和切片都有这个特征。
)

$(P
数组名后写出的 $(C []) 字符意味着$(I 全部元素)。当某些操作需要被应用到数组的所有元素时该特征简化了程序。
)

$(P
$(I $(B 注：) dmd 2.071，是用来编译本章例子的编译器，还没有完全支持这一特征呢。因此，下面只使用一些定长数组的例子。)
)

---
import std.stdio;

void main() {
    double[3] a = [ 10, 20, 30 ];
    double[3] b = [  2,  3,  4 ];

    double[3] result = $(HILITE a[] + b[]);

    writeln(result);
}
---

$(P
输出：
)

$(SHELL
[12, 23, 34]
)

$(P
在上面的程序中，加法操作被依次应用到两个数组的相应元素上：首先是第一对元素相加，然后是第二对元素相加，以此类推。这自然要求两个数组的长度必须相等。
)

$(P
运算符可以是算术运算符之一 $(C +)，$(C -)，$(C *)，$(C /)，$(C %) 和 $(C ^^)；二元运算符之一 $(C ^)，$(C &) 和 $(C |)；以及在数组前面键入的一元运算符 $(C -) 和 $(C ~)。在后面的章节中我们将看到一些运算符。
)

$(P
这些运算符的赋值版本也可以使用：$(C =)，$(C +=)，$(C -=)，$(C *=)，$(C /=)，$(C %=)，$(C ^^=)，$(C ^=)，$(C &=) 和 $(C |=)。
)

$(P
这个特征不只是使用两个数组时才可以这样；单个数组和一个复合表达式也可以。例如，下面的操作让数组的全部元素都除以四：
)

---
    double[3] a = [ 10, 20, 30 ];
    $(HILITE a[]) /= 4;

    writeln(a);
---

$(P
输出：
)

$(SHELL
[2.5, 5, 7.5]
)

$(P
给所有的元素赋一个特定值：
)

---
    $(HILITE a[]) = 42;
    writeln(a);
---

$(P
输出：
)

$(SHELL
[42, 42, 42]
)

$(P
在使用切片时，这个特征需要高度重视。虽然下面两个表达式的元素值没有明显的差异，但含义明显不同：
)

---
    slice2 = slice1;      // ← slice2 开始提供
                          // 对 slice1 所提供的
                          //   相同元素的访问

    slice3[] = slice1;    // ←修改  slice3
                          //   访问
---

$(P
$(C slice2) 的赋值使得它与 $(C slice1) 共享相同的元素。另一方面，由于 $(C slice3[]) 指的是 $(C slice3) 的$(I 全部元素)，元素的值变为与 $(C slice1) 的元素值一致。$(C []) 字符存不存在的影响不能忽略。
)

$(P
在下面的程序中我们能看到这种差异：
)

---
import std.stdio;

void main() {
    double[] slice1 = [ 1, 1, 1 ];
    double[] slice2 = [ 2, 2, 2 ];
    double[] slice3 = [ 3, 3, 3 ];

    slice2 = slice1;      // ← slice2 开始提供
                          // 对 slice1 所提供的
                          //   相同元素的访问

    slice3[] = slice1;    // ←修改  slice3
                          //    的元素值

    writeln("slice1 before: ", slice1);
    writeln("slice2 before: ", slice2);
    writeln("slice3 before: ", slice3);

    $(HILITE slice2[0] = 42);       // ← 它与 slice1 共享元素值的
                          //  变化

    slice3[0] = 43;       // ← 它只提供对
                          //   该变化值的
                          //   访问

    writeln("slice1 after : ", slice1);
    writeln("slice2 after : ", slice2);
    writeln("slice3 after : ", slice3);
}
---

$(P
通过 $(C slice2) 的修改也会影响 $(C slice1)：
)

$(SHELL
slice1 before: [1, 1, 1]
slice2 before: [1, 1, 1]
slice3 before: [1, 1, 1]
slice1 after : [$(HILITE 42), 1, 1]
slice2 after : [$(HILITE 42), 1, 1]
slice3 after : [43, 1, 1]
)

$(P
此处的危险是潜在的 bug 直到共享的元素值有了变化时才让人注意到。
)

$(H5 $(IX 多维数组) 多维数组)

$(P
到目前为止，我们用过的数组里只有像 $(C int) 和 $(C double) 这样的基本类型。元素类型实际上可以是任何类型，包括数组。这使得程序员能够定义如$(I 数组的数组)这样复杂的容器。数组的数组被称为 $(I 多维数组)。
)

$(P
迄今为止所有我们所定义的数组元素都是从左到右的写入到源代码中的。为了帮助我们理解二维数组的概念，这次我们从上到下的定义数组：
)

---
    int[] array = [
                    10,
                    20,
                    30,
                    40
                  ];
---

$(P
你还记得，源代码中的大部分空格都是用来帮助提高可读性的，并且不会改变代码的含义。上面的数组可以定义在一行，而且含义不变。
)

$(P
现在让我们用别的数组替换数组的每个元素：
)

---
  /* ... */ array = [
                      [ 10, 11, 12 ],
                      [ 20, 21, 22 ],
                      [ 30, 31, 32 ],
                      [ 40, 41, 42 ]
                    ];
---

$(P
我们已用 $(C int[]) 类型的元素替换了 $(C int) 类型的元素。要使代码符合数组定义语法，我们现在必须指定 $(C int[]) 作为元素的类型而不是 $(C int)：
)

---
    $(HILITE int[])[] array = [
                      [ 10, 11, 12 ],
                      [ 20, 21, 22 ],
                      [ 30, 31, 32 ],
                      [ 40, 41, 42 ]
                    ];
---

$(P
这样的数组被称为 $(I 二维数组)，因为它们有行和列。
)

$(P
二维数组的使用方式和我们记得的任何其它数组一样，每个元素本身就是一个数组，数组操作也能使用：
)

---
    array ~= [ 50, 51 ]; // 添加一个新元素 (即一个切片)
    array[0] ~= 13;      // 添加到第一个元素
---

$(P
数组的新状态：
)

$(SHELL_SMALL
[[10, 11, 12, $(HILITE 13)], [20, 21, 22], [30, 31, 32], [40, 41, 42], $(HILITE [50, 51])]
)

$(P
数组和元素尽量长度固定。下面的是一个所有维度都固定的三维数组：
)

---
    int[2][3][4] array;  // 2 列，3 行，4 页
---

$(P
上面的定义可以看作是 $(I 四页三行两列的整数)。例如，在冒险游戏中这种数组可以用来表示一个4 层建筑物，每层由 2x3=6 个房间组成。
)

$(P
例如，第二层第一室的项目数可以像下面这样增长：
)

---
    // 第二层的索引是 1，该层
    // 第一个房间通过 [0][0] 来访问
    ++itemCounts[1][0][0];
---

$(P
除了上述语法， $(C new) 表达式也能用来创建 $(I 切片的切片)。下面是只使用两个维度的例子：
)

---
import std.stdio;

void main() {
    int[][] s = new int[][](2, 3);
    writeln(s);
}
---

$(P
上面的 $(C new) 表达式创建了一个包含 2 个切片、每个切片含有 3 个元素的切片，该切片可以访问它们以及内部的元素。输出：
)

$(SHELL
[[0, 0, 0], [0, 0, 0]]
)

$(H5 摘要)

$(UL

$(LI
定长数组拥有自己的元素；切片提供对不专属于它们的元素的访问。
)

$(LI
在 $(C []) 运算符内部，$(C $) 与 $(C $(I 数组名称).length) 等价。
)

$(LI
$(C .dup) 由一个现有数组元素的副本生成一个新的数组。
)

$(LI
对于定长数组，赋值操作改变元素的值；对于切片，它让切片开始提供对别的元素的访问。
)

$(LI
变长的切片 $(I 可以) 停止元素的共享，并开始提供对新复制元素的访问。$(C capacity) 可以确定是否属于这种情况。
)

$(LI
$(C array[]) 语法表示$(I 数组的所有元素)；在它上面的操作可以单独应用到每个元素。
)

$(LI
数组的数组被称为多维数组。
)

)

$(PROBLEM_TEK

$(P
迭代 $(C double) 类型数组的元素，并对大于 10 的元素作减半处理。例如，下面给出的数组：
)

---
    double[] array = [ 1, 20, 2, 30, 7, 11 ];
---

$(P
修改为下面这样：
)

$(SHELL
[1, $(HILITE 10), 2, $(HILITE 15), 7, $(HILITE 5.5)]
)

$(P
虽然这个问题有好多解决办法，但这儿尽量使用切片的特征。你可以从切片开始，它可以提供对所有元素的访问。然后你可以从数组的开始处缩短切片，并且总是使用第一个元素。
)

$(P
下面的表达式从数组的开始处缩短了切片：
)

---
        slice = slice[1 .. $];
---

)

Macros:
        SUBTITLE=数组和其它的数组特征

        DESCRIPTION=D 语言切片和数组的更多特征

        KEYWORDS=d 编程语言手册 数组 切片 定长 动态
