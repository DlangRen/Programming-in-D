<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-4.1.2" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>$ .dup capacity))
$(LI $(LINK2 /ders/d.en/strings.html, Strings) $(INDEX_KEYWORDS char[] wchar[] dchar[] string wstring dstring))
$(LI $(LINK2 /ders/d.en/stream_redirect.html, Redirecting Standard Input and Output Streams))
$(LI $(LINK2 /ders/d.en/files.html, Files) $(INDEX_KEYWORDS File))
$(LI $(LINK2 /ders/d.en/auto_and_typeof.html, auto and typeof) $(INDEX_KEYWORDS auto typeof))
$(LI $(LINK2 /ders/d.en/name_space.html, Name Scope))
$(LI $(LINK2 /ders/d.en/for.html, for Loop) $(INDEX_KEYWORDS for))
$(LI $(LINK2 /ders/d.en/ternary.html, Ternary Operator ?:) $(INDEX_KEYWORDS ?:))
$(LI $(LINK2 /ders/d.en/literals.html, Literals))
$(LI $(LINK2 /ders/d.en/formatted_output.html, Formatted Output) $(INDEX_KEYWORDS writef writefln))
$(LI $(LINK2 /ders/d.en/formatted_input.html, Formatted Input))
$(LI $(LINK2 /ders/d.en/do_while.html, do-while Loop) $(INDEX_KEYWORDS do while))
$(LI $(LINK2 /ders/d.en/aa.html, Associative Arrays) $(INDEX_KEYWORDS .keys .values .byKey .byValue .byKeyValue .get .remove in))
$(LI $(LINK2 /ders/d.en/foreach.html, foreach Loop) $(INDEX_KEYWORDS foreach .byKey .byValue .byKeyValue))
$(LI $(LINK2 /ders/d.en/switch_case.html, switch and case) $(INDEX_KEYWORDS switch, case, default, final switch))
$(LI $(LINK2 /ders/d.en/enum.html, enum) $(INDEX_KEYWORDS enum .min .max))
$(LI $(LINK2 /ders/d.en/functions.html, Functions) $(INDEX_KEYWORDS return void))
$(LI $(LINK2 /ders/d.en/const_and_immutable.html, Immutability) $(INDEX_KEYWORDS enum const immutable .dup .idup))
$(LI $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types) $(INDEX_KEYWORDS &amp;))
$(LI $(LINK2 /ders/d.en/function_parameters.html, Function Parameters) $(INDEX_KEYWORDS in out ref inout lazy scope shared))
$(LI $(LINK2 /ders/d.en/lvalue_rvalue.html, Lvalues and Rvalues) $(INDEX_KEYWORDS auto ref))
$(LI $(LINK2 /ders/d.en/lazy_operators.html, Lazy Operators))
$(LI $(LINK2 /ders/d.en/main.html, Program Environment) $(INDEX_KEYWORDS main stderr))
$(LI $(LINK2 /ders/d.en/exceptions.html, Exceptions) $(INDEX_KEYWORDS throw try catch finally))
$(LI $(LINK2 /ders/d.en/scope.html, scope) $(INDEX_KEYWORDS scope(exit) scope(success) scope(failure)))
$(LI $(LINK2 /ders/d.en/assert.html, assert and enforce) $(INDEX_KEYWORDS assert enforce))
$(LI $(LINK2 /ders/d.en/unit_testing.html, Unit Testing) $(INDEX_KEYWORDS unittest))
$(LI $(LINK2 /ders/d.en/contracts.html, Contract Programming) $(INDEX_KEYWORDS in out body))
$(LI $(LINK2 /ders/d.en/lifetimes.html, Lifetimes and Fundamental Operations))
$(LI $(LINK2 /ders/d.en/null_is.html, The null Value and the is Operator) $(INDEX_KEYWORDS null is !is))
$(LI $(LINK2 /ders/d.en/cast.html, Type Conversions) $(INDEX_KEYWORDS to assumeUnique cast))
$(LI $(LINK2 /ders/d.en/struct.html, Structs) $(INDEX_KEYWORDS struct .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T025319Z" creationid="Heromyth" creationdate="20170802T025319Z">
        <seg>$ .dup capacity))
$(LI $(LINK2 /ders/d.cn/strings.html, 字符串) $(INDEX_KEYWORDS char[] wchar[] dchar[] string wstring dstring))
$(LI $(LINK2 /ders/d.cn/stream_redirect.html, 重定向标准输入输出流))
$(LI $(LINK2 /ders/d.cn/files.html, 文件) $(INDEX_KEYWORDS File))
$(LI $(LINK2 /ders/d.cn/auto_and_typeof.html, auto 和 typeof) $(INDEX_KEYWORDS auto typeof))
$(LI $(LINK2 /ders/d.cn/name_space.html, 名字作用域))
$(LI $(LINK2 /ders/d.cn/for.html, for 循环) $(INDEX_KEYWORDS for))
$(LI $(LINK2 /ders/d.cn/ternary.html, 三元运算符 ?:) $(INDEX_KEYWORDS ?:))
$(LI $(LINK2 /ders/d.cn/literals.html, 文字量))
$(LI $(LINK2 /ders/d.cn/formatted_output.html, 格式化输出) $(INDEX_KEYWORDS writef writefln))
$(LI $(LINK2 /ders/d.cn/formatted_input.html, 格式化输入))
$(LI $(LINK2 /ders/d.cn/do_while.html, do-while 循环) $(INDEX_KEYWORDS do while))
$(LI $(LINK2 /ders/d.cn/aa.html, 关联数组) $(INDEX_KEYWORDS .keys .values .byKey .byValue .byKeyValue .get .remove in))
$(LI $(LINK2 /ders/d.cn/foreach.html, foreach 循环) $(INDEX_KEYWORDS foreach .byKey .byValue .byKeyValue))
$(LI $(LINK2 /ders/d.cn/switch_case.html, switch 和 case) $(INDEX_KEYWORDS switch, case, default, final switch))
$(LI $(LINK2 /ders/d.cn/enum.html, enum) $(INDEX_KEYWORDS enum .min .max))
$(LI $(LINK2 /ders/d.cn/functions.html, 函数) $(INDEX_KEYWORDS return void))
$(LI $(LINK2 /ders/d.cn/const_and_immutable.html, 不变量) $(INDEX_KEYWORDS enum const immutable .dup .idup))
$(LI $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型与引用类型) $(INDEX_KEYWORDS &amp;))
$(LI $(LINK2 /ders/d.cn/function_parameters.html, 函数参数) $(INDEX_KEYWORDS in out ref inout lazy scope shared))
$(LI $(LINK2 /ders/d.cn/lvalue_rvalue.html, 左值与右值) $(INDEX_KEYWORDS auto ref))
$(LI $(LINK2 /ders/d.cn/lazy_operators.html, 惰性运算符))
$(LI $(LINK2 /ders/d.cn/main.html, 程序环境) $(INDEX_KEYWORDS main stderr))
$(LI $(LINK2 /ders/d.cn/exceptions.html, 异常) $(INDEX_KEYWORDS throw try catch finally))
$(LI $(LINK2 /ders/d.cn/scope.html, scope) $(INDEX_KEYWORDS scope(exit) scope(success) scope(failure)))
$(LI $(LINK2 /ders/d.cn/assert.html, assert 与 enforce) $(INDEX_KEYWORDS assert enforce))
$(LI $(LINK2 /ders/d.cn/unit_testing.html, 单元测试) $(INDEX_KEYWORDS unittest))
$(LI $(LINK2 /ders/d.cn/contracts.html, 契约编程) $(INDEX_KEYWORDS in out body))
$(LI $(LINK2 /ders/d.cn/lifetimes.html, 生命周期与函数式运算))
$(LI $(LINK2 /ders/d.cn/null_is.html, null 值与 is 运算符) $(INDEX_KEYWORDS null is !is))
$(LI $(LINK2 /ders/d.cn/cast.html, 类型转换) $(INDEX_KEYWORDS to assumeUnique cast))
$(LI $(LINK2 /ders/d.cn/struct.html, 结构) $(INDEX_KEYWORDS struct .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C !is) is the opposite of $(C is).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014827Z" creationid="Hipter" creationdate="20160707T014827Z">
        <seg>$(C !is) 与 $(C is) 相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .get()) is useful in such cases: it returns the value associated with the specified key if that key exists, otherwise it returns the default value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042443Z" creationid="Hipter" creationdate="20160709T042443Z">
        <seg>$(C .get()) 在这样的样例中是有用的：如果指定键存在则返回相应值，否则返回默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .idup) is used for producing immutable strings from existing strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152146Z" creationid="Hipter" creationdate="20160713T033023Z">
        <seg>$(C .idup) 可用来从存在的字符串中生成不可变的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .length) returns the number of elements of the array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071943Z" creationid="大处着手小处着眼" creationdate="20160725T071943Z">
        <seg>$(C .length) 返回数组元素的个数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C OnCrowding.block) causes the sender to wait until there is room in the mailbox.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T024621Z" creationid="Heromyth" creationdate="20170825T135024Z">
        <seg>$(C OnCrowding.block) 会使得发送者线程等待，一直到邮箱中有足够空间为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C Thread.sleep()) suspends the operations for the specified amount of time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013206Z" creationid="Heromyth" creationdate="20170826T013206Z">
        <seg>$(C Thread.sleep()) 会将操作挂起一段时间，其时间长短可在代码中指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C Thread.sleep) is admittedly an artifical method to use in the following examples because it takes time without ever busying any core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013246Z" creationid="Heromyth" creationdate="20170826T013234Z">
        <seg>当然在下面的例子中 $(C Thread.sleep) 只是用来模拟长耗时的任务，因为它并不需要处理器核心处理实际的工作，它只是占用时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C __gshared) is necessary when interacting with libraries of languages like C and C++ where data sharing is automatic by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T042413Z" creationid="Heromyth" creationdate="20170825T233527Z">
        <seg>在与 C 和 C++ 这样的语言编写的库（它们默认自动共享数据）交互时，$(C __gshared) 必不可少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C parallel()) is very convenient as it $(I constructs), $(I starts), and $(I waits for) the tasks automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T022257Z" creationid="Heromyth" creationdate="20170826T022257Z">
        <seg>$(C parallel()) 用起来非常方便，因为无论是$(I 构建)、$(I 启动)还是$(I 等待任务执行完成)都是自动进行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C parallel()) returns a range object that knows how to distribute the execution of the $(C delegate) to a separate core for each element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T015021Z" creationid="Heromyth" creationdate="20170826T013748Z">
        <seg>$(C parallel()) 返回一个范围对象，它将决定如何将处理元素的 $(C delegate) 分发给独立的处理器核心执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C parallel()) then waits for all of the tasks to be completed before finally exiting the loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T022246Z" creationid="Heromyth" creationdate="20170826T022246Z">
        <seg>之后 $(C parallel()) 会等待所有任务都完成后再退出循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C readf()) continues to wait for more characters to add to the string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T072239Z" creationid="Hipter" creationdate="20160712T004229Z">
        <seg>$(C readf()) 继续等待新输入的字符以添加到字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C receive()) on the other hand can wait for more than one type of message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235851Z" creationid="Heromyth" creationdate="20170824T235851Z">
        <seg>而 $(C receive()) 可以接收多种类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C receiveTimeout()) prevents blocking the receiving thread indefinitely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043248Z" creationid="Heromyth" creationdate="20170825T043248Z">
        <seg>$(C receiveTimeout()) 可以防止出现无限等待消息这样的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C reduce()) calls the functions with the current value of the result and each element of the range.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075401Z" creationid="Heromyth" creationdate="20170826T075401Z">
        <seg>$(C reduce()) 将传入的函数作为运算方法对每个元素进行计算并按照合并到结果中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C std.algorithm.map) is an algorithm commonly found in many functional languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073418Z" creationid="Heromyth" creationdate="20170826T073418Z">
        <seg>在大多数函数式编程语言中你都能找到 $(C std.algorithm.map) 这样的算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C task()) constructs, $(C executeInNewThread()) starts, and $(C yieldForce()) waits for a task object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142722Z" creationid="Heromyth" creationdate="20170826T022411Z">
        <seg>使用 $(C task()) 来创建任务对象；使用 $(C executeInNewThread()) 来启动任务对象；使用 $(C yieldForce()) 来等待任务对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C taskPool.map()) and $(C taskPool.amap()) from the $(C std.parallelism) module take advantage of multiple cores and run faster in many cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073801Z" creationid="Heromyth" creationdate="20170826T073554Z">
        <seg>$(C std.parallelism) 模块里的 $(C taskPool.map()) 和 $(C taskPool.amap()) 会充分利用多核，并在大部分情况下加快程序的运行速度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C variable1) and $(C variable2) above merely provide access to that anonymous object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011741Z" creationid="Hipter" creationdate="20160706T011741Z">
        <seg>上面的 $(C variable1) 和 $(C variable2) 只提供对那个匿名对象的访问：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C workForce()) can be called when starting other tasks is preferred over suspending the current thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T150428Z" creationid="Heromyth" creationdate="20170826T045627Z">
        <seg>$(C workForce()) 则适合用需要优先启动其他任务，而不是先考虑将当前线程挂起的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C ~) concatenates two strings and $(C ~=) appends to an existing string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153448Z" creationid="大处着手小处着眼" creationdate="20160715T033130Z">
        <seg>$(C ~) 可以连接两个字符串，$(C ~=) 则能够把字符串附加到一个已存在的字符串上：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025535Z" creationid="大处着手小处着眼" creationdate="20160726T025535Z">
        <seg>$(COZUM_BOLUMU 数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T101504Z" creationid="Hipter" creationdate="20160709T095142Z">
        <seg>$(COZUM_BOLUMU 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ADR" changedate="20160714T092548Z" creationid="ADR" creationdate="20160714T092548Z">
        <seg>$(COZUM_BOLUMU 字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX array) Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T051835Z" creationid="Heromyth" creationdate="20170817T051835Z">
        <seg>$(DERS_BOLUMU $(IX array) 数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX associative array) $(IX AA) Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085529Z" creationid="Hipter" creationdate="20160708T082836Z">
        <seg>$(DERS_BOLUMU $(IX 关联数组) $(IX AA) 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX class) Classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160701T014126Z" creationid="Hipter" creationdate="20160701T014126Z">
        <seg>$(DERS_BOLUMU $(IX class) 类)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX compilation) Compilation)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003000Z" creationid="Heromyth" creationdate="20170820T003000Z">
        <seg>$(DERS_BOLUMU $(IX compilation) 编译)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX concurrency, message passing) $(IX message passing concurrency) Message Passing Concurrency)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222051Z" creationid="Heromyth" creationdate="20170824T011541Z">
        <seg>$(DERS_BOLUMU $(IX concurrency, message passing) $(IX message passing concurrency) 基于消息传递的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX data sharing concurrency) $(IX concurrency, data sharing) Data Sharing Concurrency)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222528Z" creationid="Heromyth" creationdate="20170825T143318Z">
        <seg>$(DERS_BOLUMU $(IX data sharing concurrency) $(IX concurrency, data sharing) 基于数据共享的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX parallelism) Parallelism)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012513Z" creationid="Heromyth" creationdate="20170826T012513Z">
        <seg>$(DERS_BOLUMU $(IX parallelism) 并行)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX property) Properties)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043252Z" creationid="Heromyth" creationdate="20170905T043252Z">
        <seg>$(DERS_BOLUMU $(IX property) 特性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX user defined attributes) $(IX UDA) User Defined Attributes (UDA))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170719T105356Z" creationid="Heromyth" creationdate="20170719T054011Z">
        <seg>$(DERS_BOLUMU $(IX user defined attributes) $(IX UDA) 自定义属性（UDA）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU Programming in D)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T011008Z" creationid="Heromyth" creationdate="20170726T011008Z">
        <seg>$(DERS_BOLUMU D 语言编程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU Strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T000617Z" creationid="大处着手小处着眼" creationdate="20160716T000617Z">
        <seg>$(DERS_BOLUMU 字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX &amp;quot;) Double quotes, not single quotes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144659Z" creationid="Hipter" creationdate="20160712T075419Z">
        <seg>$(H5 $(IX &amp;quot;) 使用双引号，而非单引号)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX .length) Using $(C .length) to get or set the number of elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071657Z" creationid="大处着手小处着眼" creationdate="20160725T071657Z">
        <seg>$(H5 $(IX .length) 使用 $(C .length) 来获取或设置元素的个数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX Tid) $(IX thisTid) $(IX ownerTid) Thread identifiers)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232217Z" creationid="Heromyth" creationdate="20170824T232217Z">
        <seg>$(H5 $(IX Tid) $(IX thisTid) $(IX ownerTid) 线程 ID)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX []) Accessing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T142855Z" creationid="大处着手小处着眼" creationdate="20160723T142855Z">
        <seg>$(H5 $(IX []) 元素的访问)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX atomic operation) Atomic operations)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002826Z" creationid="Heromyth" creationdate="20170826T002826Z">
        <seg>$(H5 $(IX atomic operation) 原子操作)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX compiler) Compiler)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004712Z" creationid="Heromyth" creationdate="20170820T004712Z">
        <seg>$(H5 $(IX compiler) 编译器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX concatenation, string) String concatenation)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153034Z" creationid="大处着手小处着眼" creationdate="20160715T032440Z">
        <seg>$(H5 $(IX concatenation, string) 字符串连接)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX container) $(IX element) Containers and elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033618Z" creationid="大处着手小处着眼" creationdate="20160720T033618Z">
        <seg>$(H5 $(IX container) $(IX element) 容器和元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX delegate, message passing) Expecting different types of messages)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235801Z" creationid="Heromyth" creationdate="20170824T235801Z">
        <seg>$(H5 $(IX delegate, message passing) 接收不同类型的消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX exception, concurrency) Exceptions during the execution of the worker)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044616Z" creationid="Heromyth" creationdate="20170825T044616Z">
        <seg>$(H5 $(IX exception, concurrency) 工作线程中的异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX fixed-length array) $(IX dynamic array) $(IX static array) Fixed-length arrays vs. dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T031444Z" creationid="大处着手小处着眼" creationdate="20160725T031444Z">
        <seg>$(H5 $(IX 定长数组) $(IX 动态数组) $(IX 静态数组) 定长数组与动态数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX formattedRead) $(C formattedRead) for parsing strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T132149Z" creationid="Hipter" creationdate="20160712T022848Z">
        <seg>$(H5 $(IX formattedRead) 使用 $(C formattedRead) 函数来解析字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX in, associative array) Determining the presence of a key)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144209Z" creationid="Hipter" creationdate="20160709T034906Z">
        <seg>$(H5 $(IX in, 关联数组) 确定某个键是否存在)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX index) Index)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T015845Z" creationid="大处着手小处着眼" creationdate="20160725T015845Z">
        <seg>$(H5 $(IX index) Index（索引）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX initialization, array) Initializing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082357Z" creationid="大处着手小处着眼" creationdate="20160725T082342Z">
        <seg>$(H5 $(IX 初始化,数组) 初始化元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX interpreter) Interpreter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004222Z" creationid="Heromyth" creationdate="20170820T004222Z">
        <seg>$(H5 $(IX interpreter) 解释器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX length, string) Potentially confusing length of strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T010012Z" creationid="大处着手小处着眼" creationdate="20160714T005946Z">
        <seg>$(H5 $(IX length, string) 有可能让人困惑的字符串长度)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX literal, string) String literals)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T014642Z" creationid="大处着手小处着眼" creationdate="20160715T014642Z">
        <seg>$(H5 $(IX literal, string) 字符串字面量)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX machine code) Machine code)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003231Z" creationid="Heromyth" creationdate="20170820T003231Z">
        <seg>$(H5 $(IX machine code) 机器码)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX prioritySend) $(IX PriorityMessageException) Priority messages)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135118Z" creationid="Heromyth" creationdate="20170825T135118Z">
        <seg>$(H5 $(IX prioritySend) $(IX PriorityMessageException) 消息优先级)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX programming language) Programming language)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004025Z" creationid="Heromyth" creationdate="20170820T004025Z">
        <seg>$(H5 $(IX programming language) 编程语言)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX readln) $(IX strip) $(C readln) and $(C strip), instead of $(C readf))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T111020Z" creationid="Hipter" creationdate="20160711T092224Z">
        <seg>$(H5 $(IX readln) $(IX strip) 使用 $(C readln) 和 $(C strip)，而非 $(C readf))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX receiveTimeout) Waiting for messages up to a certain time)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043213Z" creationid="Heromyth" creationdate="20170825T043213Z">
        <seg>$(H5 $(IX receiveTimeout) 在指定的时间内等待消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX remove) Removing key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032109Z">
        <seg>$(H5 $(IX remove) 移除键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX send) $(IX receiveOnly) Message Passing)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232728Z" creationid="Heromyth" creationdate="20170824T232728Z">
        <seg>$(H5 $(IX send) $(IX receiveOnly) 消息传递)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX shared static this) $(IX static this, shared) $(IX shared static ~this) $(IX static ~this, shared) $(IX this, shared static) $(IX ~this, shared static) $(IX module constructor, shared) $(C shared static this()) for single initialization and $(C shared static ~this()) for single finalization)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T044006Z" creationid="Heromyth" creationdate="20170826T002306Z">
        <seg>$(H5 $(IX shared static this) $(IX static this, shared) $(IX shared static ~this) $(IX static ~this, shared) $(IX this, shared static) $(IX ~this, shared static) $(IX module constructor, shared)$(C shared static this()) 用于单次初始化；$(C shared static ~this()) 用于单次析构)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX shared) $(C shared) to share mutable data between threads)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233547Z" creationid="Heromyth" creationdate="20170825T233547Z">
        <seg>$(H5 $(IX shared) 用 $(C shared) 在线程间共享数据))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX spawn) Starting threads)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054229Z" creationid="Heromyth" creationdate="20170824T054229Z">
        <seg>$(H5 $(IX spawn) 启动线程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string), $(C wstring), and $(C dstring) are immutable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144832Z" creationid="Hipter" creationdate="20160712T080114Z">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string)、$(C wstring) 和 $(C dstring) 是 immutable （不可变的）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX synchronized) $(C synchronized) to avoid race conditions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235849Z" creationid="Heromyth" creationdate="20170825T235849Z">
        <seg>$(H5 $(IX synchronized) $(C synchronized) 避免竞态条件)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 A race condition example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235137Z" creationid="Heromyth" creationdate="20170825T235137Z">
        <seg>$(H5 竞态条件示例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Adding key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T144521Z">
        <seg>$(H5 添加键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 An array example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072336Z" creationid="大处着手小处着眼" creationdate="20160725T072336Z">
        <seg>$(H5 一个数组例子)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Basic array operations)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051122Z" creationid="大处着手小处着眼" creationdate="20160726T012123Z">
        <seg>$(H5 数组的基本操作)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Calling functions without parentheses)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044437Z" creationid="Heromyth" creationdate="20170906T044437Z">
        <seg>$(H5 不使用圆括号的函数调用)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Comparing strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033521Z" creationid="大处着手小处着眼" creationdate="20160715T033521Z">
        <seg>$(H5 比较字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Comparing with structs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123652Z" creationid="Heromyth" creationdate="20170819T123652Z">
        <seg>$(H5 与结构对比)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Concepts)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012345Z" creationid="Heromyth" creationdate="20170824T012345Z">
        <seg>$(H5 相关概念)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094803Z" creationid="Hipter" creationdate="20160708T094803Z">
        <seg>$(H5 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Detecting thread termination)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051954Z" creationid="Heromyth" creationdate="20170825T051954Z">
        <seg>$(H5 检测线程终止)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083417Z" creationid="Hipter" creationdate="20160709T083417Z">
        <seg>$(H5 样例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Initialization)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030542Z" creationid="Hipter" creationdate="20160709T030542Z">
        <seg>$(H5 初始化)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Lowercase and uppercase are different)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T035759Z" creationid="大处着手小处着眼" creationdate="20160715T035759Z">
        <seg>$(H5 小写与大写不同)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Mailbox management)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052558Z" creationid="Heromyth" creationdate="20170825T052558Z">
        <seg>$(H5 邮箱管理)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Multiple functions and tuple results)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085024Z" creationid="Heromyth" creationdate="20170826T085024Z">
        <seg>$(H5 多个函数和元组结果)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Online version)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052519Z" creationid="Heromyth" creationdate="20170801T052519Z">
        <seg>$(H5 在线版本)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Properties are not absolutely necessary)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070724Z" creationid="Heromyth" creationdate="20170906T070724Z">
        <seg>$(H5 特性不是唯一的解决方案)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Properties)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143437Z" creationid="Hipter" creationdate="20160709T042827Z">
        <seg>$(H5 特性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Property functions that are used in assignment)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053007Z" creationid="Heromyth" creationdate="20170906T053007Z">
        <seg>$(H5 用于赋值的特性函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Property functions that return values)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044648Z" creationid="Heromyth" creationdate="20170906T044648Z">
        <seg>$(H5 返回值的特性函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Removing key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144123Z" creationid="Heromyth" creationdate="20170818T144123Z">
        <seg>$(H5 删除键-值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Sharing is not automatic)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143933Z" creationid="Heromyth" creationdate="20170825T143933Z">
        <seg>$(H5 共享不是自动的)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Summary)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T054023Z" creationid="Hipter" creationdate="20160707T015616Z">
        <seg>$(H5 小结)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 The benefit of user defined attributes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121738Z" creationid="Heromyth" creationdate="20170815T121738Z">
        <seg>$(H5 自定义属性的好处)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Thread names)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135208Z" creationid="Heromyth" creationdate="20170825T135208Z">
        <seg>$(H5 线程名)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 When to use)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070822Z" creationid="Heromyth" creationdate="20170906T070822Z">
        <seg>$(H5 何时使用特性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX LinkTerminated) $(IX spawnLinked) $(C LinkTerminated) exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052242Z" creationid="Heromyth" creationdate="20170825T052242Z">
        <seg>$(H6 $(IX LinkTerminated) $(IX spawnLinked) $(C LinkTerminated) 异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX OwnerTerminated) $(C OwnerTerminated) exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052019Z" creationid="Heromyth" creationdate="20170825T052019Z">
        <seg>$(H6 $(IX OwnerTerminated) $(C OwnerTerminated) 异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX assignment, class) Assignment)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024616Z" creationid="Hipter" creationdate="20160706T024616Z">
        <seg>$(H6 $(IX assignment, class) 赋值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX copy, array) Copying fixed-length arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013007Z" creationid="大处着手小处着眼" creationdate="20160726T013007Z">
        <seg>$(H6 $(IX 复制, 数组) 复​​制定长数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX copy, class) Copying)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011913Z" creationid="Hipter" creationdate="20160706T011913Z">
        <seg>$(H6 $(IX copy, class) 复制)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX error, compilation) $(IX compilation error) Compilation error)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005043Z" creationid="Heromyth" creationdate="20170820T005043Z">
        <seg>$(H6 $(IX error, compilation) $(IX compilation error) 编译错误)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX exception, parallelism) Exceptions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034813Z" creationid="Heromyth" creationdate="20170826T034813Z">
        <seg>$(H6 $(IX exception, parallelism) 异常处理)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX is, operator) $(IX !is) The $(C is) and $(C !is) operators)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013714Z" creationid="Hipter" creationdate="20160707T013714Z">
        <seg>$(H6 $(IX is, 运算符) $(IX !is)   $(C is) 和 $(C !is) 运算符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX null, class) $(new, class) Class variables may be $(C null))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124204Z" creationid="Heromyth" creationdate="20170819T124204Z">
        <seg>$(H6 $(IX null, class) $(new, class) 类变量可以为 $(C null))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX remove, array) Removing elements from dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T051918Z" creationid="Heromyth" creationdate="20170817T051918Z">
        <seg>$(H6 $(IX remove, array) 从动态数组里删除元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX reverse) Reversing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021701Z" creationid="大处着手小处着眼" creationdate="20160726T021701Z">
        <seg>$(H6 $(IX reverse（反转）) 反转元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX sort) Sorting the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021045Z" creationid="大处着手小处着眼" creationdate="20160726T021045Z">
        <seg>$(H6 $(IX sort（排序）) 排序元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX variable, class) $(IX object, class) Class variables versus class objects)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130756Z" creationid="Heromyth" creationdate="20170819T130756Z">
        <seg>$(H6 $(IX variable, class) $(IX object, class) 类变量与类对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX work unit size) Work unit size)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014645Z" creationid="Heromyth" creationdate="20170826T014645Z">
        <seg>$(H6 $(IX work unit size) 工作单元大小)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX ~, concatenation) $(IX concatenation, array) Combining arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T041030Z" creationid="大处着手小处着眼" creationdate="20160726T014408Z">
        <seg>$(H6 $(IX ~, 连接) $(IX 连接, 数组) 连接数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX ~=) $(IX append, array) $(IX add element, array) Adding elements to dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013609Z" creationid="大处着手小处着眼" creationdate="20160726T013609Z">
        <seg>$(H6 $(IX ~=) $(IX 附加, 数组) $(IX 添加元素, 数组) 给动态数组添加元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Classes are reference types)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123955Z" creationid="Heromyth" creationdate="20170819T123955Z">
        <seg>$(H6 类是引用类型)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Construction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033741Z" creationid="Hipter" creationdate="20160706T032028Z">
        <seg>$(H6 构造函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031821Z" creationid="Hipter" creationdate="20160706T031821Z">
        <seg>$(H6 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Destruction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033752Z" creationid="Hipter" creationdate="20160706T033700Z">
        <seg>$(H6 析构函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233909Z" creationid="Heromyth" creationdate="20170824T233909Z">
        <seg>$(H6 示例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member access)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002524Z" creationid="Heromyth" creationdate="20170820T002524Z">
        <seg>$(H6 成员访问)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member functions of $(C Task))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045320Z" creationid="Heromyth" creationdate="20170826T045320Z">
        <seg>$(H6 $(C Task)) 的成员函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member functions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005242Z" creationid="Hipter" creationdate="20160707T005242Z">
        <seg>$(H6 成员函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Operator overloading)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004731Z" creationid="Hipter" creationdate="20160707T004731Z">
        <seg>$(H6 运算符重载)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Receiving any type of message)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000705Z" creationid="Heromyth" creationdate="20170825T000705Z">
        <seg>$(H6 接收任意类型的消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Receiving exceptions as messages)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052506Z" creationid="Heromyth" creationdate="20170825T052506Z">
        <seg>$(H6 接收异常消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE array =) array.remove!(a =&gt; $(HILITE a == 42));    // Assigned back to array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145745Z" creationid="Heromyth" creationdate="20170817T145745Z">
        <seg>$(HILITE array =) array.remove!(a =&gt; $(HILITE a == 42));    // 回赋给 array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE array =) array.remove($(HILITE 1));                // Assigned back to array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145201Z" creationid="Heromyth" creationdate="20170817T145201Z">
        <seg>$(HILITE array =) array.remove($(HILITE 1));                // 回赋给 array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE Recommended)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012540Z" creationid="Hipter" creationdate="20160707T012540Z">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE 推荐)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE synchronized) { // ← This lock is different from the one above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000546Z" creationid="Heromyth" creationdate="20170826T000546Z">
        <seg>$(HILITE synchronized) { // ← 此处的锁与上方的锁不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE synchronized) { // ← This lock is different from the one below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000529Z" creationid="Heromyth" creationdate="20170826T000529Z">
        <seg>$(HILITE synchronized) { // ← 此处的锁与下方的锁不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I ($(B Note:) This is related to name scopes, as well as object lifetimes, which will be explained in $(LINK2 /ders/d.en/lifetimes.html, a later chapter.)))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025009Z" creationid="Hipter" creationdate="20160707T022842Z">
        <seg>$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I (Assume that A is paused and B is restarted at this point))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235752Z" creationid="Heromyth" creationdate="20170825T235752Z">
        <seg>$(I (假设此处 A 暂停 B 继续))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I (Assume that A is paused and B is started at this point))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235727Z" creationid="Heromyth" creationdate="20170825T235727Z">
        <seg>$(I (假设此处 A 暂停 B 启动))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I (Assume that B is paused and A is restarted at this point))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235740Z" creationid="Heromyth" creationdate="20170825T235740Z">
        <seg>$(I (假设此处 B 暂停 A 继续))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I Decorating) the names of member variables is a common practice in object oriented programming.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071035Z" creationid="Heromyth" creationdate="20170906T071035Z">
        <seg>在面向对象编程中，$(I 修饰)变量名是十分常用的技巧。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I In parallel) means that operations are executed on multiple cores at the same time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124753Z" creationid="Heromyth" creationdate="20170826T012636Z">
        <seg>$(I 并行) 意味着将要执行的一组操作可以被分派到多个内核同时执行。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I type_name)[$(I value_count)] $(I variable_name);
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032737Z" creationid="大处着手小处着眼" creationdate="20160720T032737Z">
        <seg>$(I 类型名称)[$(I 值的个数)] $(I 变量名称);
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I value_type)[$(I key_type)] $(I associative_array_name);
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095157Z" creationid="Hipter" creationdate="20160708T095114Z">
        <seg>$(I 值类型)[$(I 键类型)] $(I 关联数组名);
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Encapsulation:) Controlling access to members ($(I Encapsulation is available for structs as well but it has not been mentioned until this chapter.))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120907Z" creationid="Heromyth" creationdate="20170819T120907Z">
        <seg>$(LI
$(B 封装：) 控制成员的访问（$(I 封装也可用于结构，只是到本章之前一直未提及。)）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Inheritance:) Acquiring members of another type
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120944Z" creationid="Heromyth" creationdate="20170819T120944Z">
        <seg>$(LI
$(B 继承：) 获取另一个类型的成员
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Polymorphism:) Being able to use a more special type in place of a more general type
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T121346Z" creationid="Heromyth" creationdate="20170819T121346Z">
        <seg>$(LI
$(B 多态性：) 能够使用较特定的类型取代较通用的类型
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Although both programming models use operating system threads, in parallelism threads are encapsulated by the concept of task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221132Z" creationid="Heromyth" creationdate="20170824T012154Z">
        <seg>$(LI
虽然两者都涉及线程操作，但并行线程被封装成了任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Although some of the functions in Phobos modules will be easy to use with strings, library documentations are usually terse compared to tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T070344Z" creationid="大处着手小处着眼" creationdate="20160714T093404Z">
        <seg>$(LI
尽管 Phobos 模块中的一些函数易于处理字符串，但库文档通常比教程简短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Another solution is to assign an empty array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115803Z" creationid="Hipter" creationdate="20160711T012526Z">
        <seg>$(LI
另一种解法是用空数组赋值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
In parallelism, tasks are independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012119Z" creationid="Heromyth" creationdate="20170824T012119Z">
        <seg>$(LI
在并行中，任务之间相互独立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
It is fully eager.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074913Z" creationid="Heromyth" creationdate="20170826T074744Z">
        <seg>$(LI
它是即时计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
It works with $(C RandomAccessRange) ranges.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074821Z" creationid="Heromyth" creationdate="20170826T074821Z">
        <seg>$(LI
它适用于 $(C RandomAccessRange) 范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Many other functions may be chained as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151035Z" creationid="大处着手小处着眼" creationdate="20160714T095132Z">
        <seg>$(LI
许多别的函数可以嵌套使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Parallelism is easy to use, and as long as tasks are independent it is easy to produce programs that work correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221355Z" creationid="Heromyth" creationdate="20170824T012219Z">
        <seg>$(LI
并行易于使用，并且只要任务相互独立，便可以轻松地生成可正常工作的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Since the initial value of an array is an empty array anyway, the following technique would achieve the same result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013753Z" creationid="Hipter" creationdate="20160711T013753Z">
        <seg>$(LI
由于数组的初始值无论如何都是一个空数组，那么下面的技术将得到一样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Specifying the elements to remove with a $(I lambda function), which we will cover in $(LINK2 /ders/d.en/lambda.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145615Z" creationid="Heromyth" creationdate="20170817T145615Z">
        <seg>$(LI
使用一个 $(I 匿名函数) （在 $(LINK2 /ders/d.cn/lambda.html, 后面章节) 会讲解它）来指定需要删除的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The $(C .keys) property returns a slice (i.e. dynamic array) that includes all of the keys of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141924Z" creationid="Hipter" creationdate="20160709T101654Z">
        <seg>$(LI
特性 $(C .keys) 返回的是一个分片(即动态数组)，其中包含关联数组的所有键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The explanations are included as code comments:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025910Z" creationid="大处着手小处着眼" creationdate="20160726T025910Z">
        <seg>$(LI
解释包含在代码说明中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The goal is to store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013837Z" creationid="Hipter" creationdate="20160711T013837Z">
        <seg>$(LI
目标是存储每个学生的多个成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The main purpose of parallelism is to take advantage of microprocessor cores to improve the performance of programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T220601Z" creationid="Heromyth" creationdate="20170824T011955Z">
        <seg>$(LI
并行的主要目的是利用微处理器的多核提高程序的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
There are three mistakes (bugs) in this program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141623Z" creationid="大处着手小处着眼" creationdate="20160726T030739Z">
        <seg>$(LI
程序有三个错误（bug）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI  类是引用类型。The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041335Z" creationid="Hipter" creationdate="20160708T041335Z">
        <seg>$(LI  类是引用类型。 $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(B The numbers start with zero:) Although humans assign numbers to items starting with 1, the numbers in arrays start at 0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023625Z" creationid="大处着手小处着眼" creationdate="20160724T023559Z">
        <seg>$(LI $(B 从零开始编号：) 虽然人们习惯于从 1 开始给项目分配编号，但数组是从 0 开始的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(B Two different uses of the $(C[]) characters:) Don't confuse the two separate uses of the $(C []) characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T024921Z" creationid="大处着手小处着眼" creationdate="20160724T024914Z">
        <seg>$(LI $(B$(C[]) 的两种不同用法：) 不要混淆 $(C []) 的两种独特用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C OnCrowding.ignore): The message is discarded.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134644Z" creationid="Heromyth" creationdate="20170825T134644Z">
        <seg>$(LI $(C OnCrowding.ignore)：多余的消息将被抛弃。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C Variant) matches any type of message.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140545Z" creationid="Heromyth" creationdate="20170825T140545Z">
        <seg>$(LI $(C Variant) 用来匹配所有类型的消息。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C __gshared) provides data sharing as in C and C++ languages.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004446Z" creationid="Heromyth" creationdate="20170826T004446Z">
        <seg>$(LI $(C __gshared) 提供了与 C 和 C++ 共享数据的能力。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C amap()) calls functions with the elements of a $(C RandomAccessRange) fully-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115730Z" creationid="Heromyth" creationdate="20170826T091304Z">
        <seg>$(LI $(C amap())：以即时取值的方式对 $(C RandomAccessRange) 中的元素并行调用指定的函数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C amap): Calls functions with the elements of a $(C RandomAccessRange) fully-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012754Z" creationid="Heromyth" creationdate="20170826T012754Z">
        <seg>$(LI $(C amap)：以并行即时取值的方式对 $(C RandomAccessRange) 中的元素应用指定的函数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C asyncBuf()) iterates the elements of an $(C InputRange) semi-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115520Z" creationid="Heromyth" creationdate="20170826T091243Z">
        <seg>$(LI $(C asyncBuf())：以半延时取值的方式并行迭代 $(C InputRange) 中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C asyncBuf): Iterates the elements of an $(C InputRange) semi-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012717Z" creationid="Heromyth" creationdate="20170826T012717Z">
        <seg>$(LI $(C asyncBuf)：以并行半延时取值的方式迭代 $(C InputRange) 中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C catch) and $(C finally) cannot be used without a $(C try) block.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022354Z" creationid="Hipter" creationdate="20160707T022354Z">
        <seg>$(LI 没有一个 $(C try) 块， $(C catch) 和 $(C finally) 不能使用。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C done): Specifies whether the task has been completed; rethrows the exception if the task has been terminated with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145142Z" creationid="Heromyth" creationdate="20170826T045340Z">
        <seg>$(LI $(C done)：指明任务是否已完成；如果任务已经因为异常而中止，则重新抛出该异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C executeInNewThread()): Starts the task in a new thread.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145149Z" creationid="Heromyth" creationdate="20170826T045355Z">
        <seg>$(LI $(C executeInNewThread())：在新线程中启动任务。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C executeInNewThread(int priority)): Starts the task in a new thread with the specified priority.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145211Z" creationid="Heromyth" creationdate="20170826T045411Z">
        <seg>$(LI $(C executeInNewThread(int priority))：在新线程中启动任务，并指定线程优先级。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C map()) calls functions with the elements of an $(C InputRange) semi-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115700Z" creationid="Heromyth" creationdate="20170826T091254Z">
        <seg>$(LI $(C map())：以半延时取值的方式对 $(C InputRange) 中的元素并行调用指定的函数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C map()), $(C amap()), and $(C reduce()) can take multiple functions and return the results as tuples.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115905Z" creationid="Heromyth" creationdate="20170826T091357Z">
        <seg>$(LI $(C map())、$(C amap()) 或 $(C reduce()) 可以传入多个函数并以元组方式让出返回结果。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C map): Calls functions with the elements of an $(C InputRange) semi-eagerly in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012737Z" creationid="Heromyth" creationdate="20170826T012737Z">
        <seg>$(LI $(C map)：以并行半延时取值的方式对 $(C InputRange) 中的每一个元素应用指定的函数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C ownerTid) is the thread id of the owner of the current thread.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T024909Z" creationid="Heromyth" creationdate="20170825T140505Z">
        <seg>$(LI $(C ownerTid) 为当前线程的所有者的 ID。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C parallel()) accesses the elements of a range in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115149Z" creationid="Heromyth" creationdate="20170826T091134Z">
        <seg>$(LI $(C parallel()) 可以并行访问范围中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C parallel): Accesses the elements of a range in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124836Z" creationid="Heromyth" creationdate="20170826T012649Z">
        <seg>$(LI $(C parallel)：并行访问范围中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C receiveOnly()), $(C receive()), and $(C receiveTimeout()) wait for messages.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140531Z" creationid="Heromyth" creationdate="20170825T140531Z">
        <seg>$(LI $(C receiveOnly())、$(C receive()) 和 $(C receiveTimeout()) 用于等待消息。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C reduce()) makes calculations over the elements of a $(C RandomAccessRange) in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115833Z" creationid="Heromyth" creationdate="20170826T091314Z">
        <seg>$(LI $(C reduce())：并行归约计算 $(C RandomAccessRange) 中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C reduce): Makes calculations over the elements of a $(C RandomAccessRange) in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012808Z" creationid="Heromyth" creationdate="20170826T012808Z">
        <seg>$(LI $(C reduce)：使用指定的函数并行归约计算 $(C RandomAccessRange) 中的元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C register()), $(C unregister()), and $(C locate()) allow referring to threads by name.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140728Z" creationid="Heromyth" creationdate="20170825T140728Z">
        <seg>$(LI $(C register())、$(C unregister()) 和 $(C locate()) 允许程序员通过线程名访问线程。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(failure)): the expression is executed only if the scope is being exited due to an exception)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051533Z" creationid="Hipter" creationdate="20160707T025720Z">
        <seg>$(LI $(C scope(failure))：表达式只在因出现异常而退出作用域时被执行。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(success)): the expression is executed only if the scope is being exited successfully)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025415Z" creationid="Hipter" creationdate="20160707T025415Z">
        <seg>$(LI $(C scope(success))：表达式只在成功退出作用域时被执行。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C send()) and $(C prioritySend()) send messages.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140516Z" creationid="Heromyth" creationdate="20170825T140516Z">
        <seg>$(LI $(C send()) 和 $(C prioritySend()) 用于发送消息。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C setMaxMailboxSize()) limits the size of mailboxes.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140715Z" creationid="Heromyth" creationdate="20170825T140715Z">
        <seg>$(LI $(C setMaxMailboxSize()) 用来限制邮箱大小。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C spawn()) and $(C spawnLinked()) start threads.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135838Z" creationid="Heromyth" creationdate="20170825T135838Z">
        <seg>$(LI $(C spawn()) 和 $(C spawnLinked()) 用于启动线程。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C static this()) is executed once for each thread; $(C shared static this()) is executed once for the entire program.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004554Z" creationid="Heromyth" creationdate="20170826T004554Z">
        <seg>$(LI $(C static this()) 会为每个线程执行一次；$(C shared static this()) 则只会在整个程序中执行一次。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C synchronized) is for preventing other threads from intervening when a thread is executing a certain piece of code.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004459Z" creationid="Heromyth" creationdate="20170826T004459Z">
        <seg>$(LI $(C synchronized) 可防止其他线程在当前现成的操作执行到一半时横插一脚致使结果错误。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C task): Creates tasks that are executed in parallel.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012658Z" creationid="Heromyth" creationdate="20170826T012658Z">
        <seg>$(LI $(C task)：创建并行执行的任务。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C thisTid) is the thread id of the current thread.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T024833Z" creationid="Heromyth" creationdate="20170825T135851Z">
        <seg>$(LI $(C thisTid) 为当前线程的 ID。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C yieldForce()): Starts the task if it has not been started yet; if it has already been completed, returns its return value; if it is still running, waits for its completion without making the microprocessor busy; if an exception has been thrown, rethrows that exception.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145524Z" creationid="Heromyth" creationdate="20170826T045504Z">
        <seg>$(LI $(C yieldForce())：如果任务没有启动，则启动它；如果任务已经完成，则返回任务函数的返回值；如果任务正在执行，则以不占用微处理器的方式等待该任务完成；如果任务在执行中抛出了一个异常，它将在此处重新抛出那个异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKey) $(C .byKey) provides access to the keys without copying them; we will see how $(C .byKey) is used in $(C foreach) loops in the next chapter.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025532Z" creationid="Hipter" creationdate="20160709T081414Z">
        <seg>$(LI $(IX .byKey) $(C .byKey) 提供对键的直接访问；在下一章我们将看到在 $(C foreach) 循环中如何使用 $(C .byKey) 。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) provides access to the key-value pairs without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025550Z" creationid="Hipter" creationdate="20160709T082623Z">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) 提供对键值对的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byValue) $(C .byValue) provides access to the values without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025539Z" creationid="Hipter" creationdate="20160709T082217Z">
        <seg>$(LI $(IX .byValue) $(C .byValue) 提供对值的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .clear) $(C .clear) removes all elements.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083332Z" creationid="Hipter" creationdate="20160709T083332Z">
        <seg>$(LI $(IX .clear) $(C .clear) 移除全部元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .get) $(C .get) returns the value if it exists, the default value otherwise.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133139Z" creationid="Hipter" creationdate="20160709T083159Z">
        <seg>$(LI $(IX .get) $(C .get) 值存在即返回相应值，否则返回默认值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .keys) $(C .keys) returns a copy of all keys as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080658Z" creationid="Hipter" creationdate="20160709T080658Z">
        <seg>$(LI $(IX .keys) $(C .keys) 返回全部键的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .length) $(C .length) returns the number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080521Z" creationid="Hipter" creationdate="20160709T080521Z">
        <seg>$(LI $(IX .length) $(C .length) 返回键值对的个数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .rehash) $(C .rehash) may make the array more efficient in some cases, such as after inserting a large number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T082830Z" creationid="Hipter" creationdate="20160709T082830Z">
        <seg>$(LI $(IX .rehash) $(C .rehash) 在一些例子中可以让数组更有效率，比如在插入大量的键值对之后。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .remove) $(C .remove) removes the specified key and its value from the array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083314Z" creationid="Hipter" creationdate="20160709T083314Z">
        <seg>$(LI $(IX .remove) $(C .remove) 从数组中移除指定的键和值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .remove, associative array) $(C .remove) removes the specified key and its value from the array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143538Z" creationid="Heromyth" creationdate="20170818T143538Z">
        <seg>$(LI $(IX .remove, associative array) $(C .remove) 从数组里删除指定的键及其值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) is the size of the array $(I reference) (it has nothing to do with the number of key-value pairs in the table and is the same value for all associative arrays).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T045628Z" creationid="Hipter" creationdate="20160709T083105Z">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) 数组$(I 引用)大小（它不受表中键值对个数的影响，对所有的关联数组来说值都是一样的）。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .values) $(C .values) returns a copy of all values as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T081449Z" creationid="Hipter" creationdate="20160709T081449Z">
        <seg>$(LI $(IX .values) $(C .values) 返回全部值的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX MailboxFull) $(C OnCrowding.throwException): A $(C MailboxFull) exception is thrown when sending the message.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134702Z" creationid="Heromyth" creationdate="20170825T134702Z">
        <seg>$(LI $(IX MailboxFull) $(C OnCrowding.throwException)：向发送者线程中抛出$(C MailboxFull) 异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX OnCrowding) $(C OnCrowding.block): The sender waits until there is room in the mailbox.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134502Z" creationid="Heromyth" creationdate="20170825T134502Z">
        <seg>$(LI $(IX OnCrowding) $(C OnCrowding.block)：阻塞发送者直到邮箱中有空闲空间。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX allMembers) $(C __traits(allMembers)) produces the members of a type (or a module) as strings.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053356Z" creationid="Heromyth" creationdate="20170804T053356Z">
        <seg>$(LI $(IX allMembers) $(C __traits(allMembers)) 会以字符串列表的形式生成某个类型（或模块）的所有成员。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX getMember) $(C __traits(getMember)) produces a $(I symbol) useful when accessing a member.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053639Z" creationid="Heromyth" creationdate="20170804T053639Z">
        <seg>$(LI $(IX getMember) $(C __traits(getMember)) 会生成一个 $(I 符号)，可以在访问某个成员时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX locate) $(C locate()): Returns the thread that is associated with the specified name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135412Z" creationid="Heromyth" creationdate="20170825T135340Z">
        <seg>$(LI $(IX locate) $(C locate())：返回线程名关联的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX register, concurrency) $(C register()): Associates a thread with a name.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135326Z" creationid="Heromyth" creationdate="20170825T135326Z">
        <seg>$(LI $(IX register, concurrency) $(C register())：给线程关联一个名字。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX spinForce) $(C spinForce()): Works similarly to $(C yieldForce()), except that it makes the microprocessor busy while waiting, in order to catch the completion as early as possible.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145650Z" creationid="Heromyth" creationdate="20170826T045523Z">
        <seg>$(LI $(IX spinForce) $(C spinForce())：与 $(C yieldForce()) 功能相似。不同的是在等待时它将以占用微处理器为代价换取更快的检测任务完成的速度。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX unregister) $(C unregister()): Breaks the association between the specified name and the thread.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135430Z" creationid="Heromyth" creationdate="20170825T135430Z">
        <seg>$(LI $(IX unregister) $(C unregister())：解除线程和线程名之间的关联。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX workForce) $(C workForce()): Works similarly to $(C yieldForce()), except that it starts a new task in the current thread while waiting for the task to be completed.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T150523Z" creationid="Heromyth" creationdate="20170826T045536Z">
        <seg>$(LI $(IX workForce) $(C workForce())：与 $(C yieldForce()) 功能相似。不同的是，它在等待当前任务完成时会将启动一个新的任务。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A class can be defined as $(C synchronized) so that only one member function can be executed on a given object at a given time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004510Z" creationid="Heromyth" creationdate="20170826T004510Z">
        <seg>$(LI 类也可以被定义为 $(C synchronized)，这样同一时间只能有一个线程调用这个类实例对象的成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A class destructor must not access a member that is managed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001816Z" creationid="Heromyth" creationdate="20170820T001647Z">
        <seg>$(LI 类的析构函数不能访问由垃圾回收器管理的成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A class destructor must not allocate new memory that is managed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001802Z" creationid="Heromyth" creationdate="20170820T001723Z">
        <seg>$(LI 类的析构函数一定不要分配由垃圾回收器管理的新内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A function pointer of type $(C bool function(Tid)): The specified function is called.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134737Z" creationid="Heromyth" creationdate="20170825T134737Z">
        <seg>$(LI 类型为 $(C bool function(Tid) 的函数指针)：调用指定的函数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assigning an empty associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084451Z" creationid="Hipter" creationdate="20160709T084139Z">
        <seg>$(LI 用一个空的关联数组赋值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assignment associates a variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020548Z" creationid="Hipter" creationdate="20160707T020548Z">
        <seg>$(LI 赋值会把一个变量与一个对象相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assigns the initial value to $(C result))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082208Z" creationid="Heromyth" creationdate="20170826T082208Z">
        <seg>$(LI 把初始值赋给 $(C result))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Because concurrency by data sharing is hard to implement correctly, prefer concurrency by message passing, which is the subject of this chapter.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T025118Z" creationid="Heromyth" creationdate="20170825T135826Z">
        <seg>$(LI 基于数据共享的并发难以正确实现，因此推荐使用本章讲解的基于消息传递的并发。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Class variables that are not associated with any object are $(C null).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020015Z" creationid="Hipter" creationdate="20160707T020015Z">
        <seg>$(LI 不与任何对象相关联的类变量为 $(C null)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes and structs share common features but have big differences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015731Z" creationid="Hipter" creationdate="20160707T015731Z">
        <seg>$(LI 类和结构虽然有共同特点，但还是有很大的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes are reference types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015816Z" creationid="Hipter" creationdate="20160707T015816Z">
        <seg>$(LI  类是引用类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Each member is tested with $(C hasUDA) to determine whether it has the $(C Encrypted) attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042259Z" creationid="Heromyth" creationdate="20170815T042259Z">
        <seg>$(LI 每个成员都使用 $(C hasUDA) 来测试，以便确定它是否拥有 $(C Encrypted) 特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Even then, prefer $(I message passing concurrency), which has been the topic of the previous chapter.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004420Z" creationid="Heromyth" creationdate="20170826T004420Z">
        <seg>$(LI 若要使用并发，优先选择上一章的 $(I 基于消息传递的并发) 模型。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Exceptions may be thrown during message passing: $(C MessageMismatch), $(C OwnerTerminated), $(C LinkTerminated), $(C MailboxFull), and $(C PriorityMessageException).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140807Z" creationid="Heromyth" creationdate="20170825T140807Z">
        <seg>$(LI 消息传递的过程中也可能会抛出异常：$(C MessageMismatch)、$(C OwnerTerminated)、$(C LinkTerminated)、$(C MailboxFull) 以及 $(C PriorityMessageException)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Executes the expression $(C result = func(result, element)) for every element)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082221Z" creationid="Heromyth" creationdate="20170826T082221Z">
        <seg>$(LI 对每一个元素执行 $(C result = func(result, element)) 这样的表达式)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI It is an error to execute operations in parallel unless those operations are independent from each other.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115259Z" creationid="Heromyth" creationdate="20170826T091121Z">
        <seg>$(LI 操作只有在相互独立时才能并行执行；否则会出错。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Only $(C shared) data can be shared; $(C immutable) is implicitly $(C shared).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004436Z" creationid="Heromyth" creationdate="20170826T004436Z">
        <seg>$(LI 只有用 $(C shared) 定义的变量才能共享；$(C immutable) 隐含了 $(C shared)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Removing them one-by-one from the associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084106Z" creationid="Hipter" creationdate="20160709T084106Z">
        <seg>$(LI 从关联数组中逐个移除它们。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Returns the final value of $(C result))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082232Z" creationid="Heromyth" creationdate="20170826T082232Z">
        <seg>$(LI 返回最终 $(C result) 的值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Similar to the previous method, assigning the array's $(C .init) property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084440Z" creationid="Hipter" creationdate="20160709T084440Z">
        <seg>$(LI 与前一方法相似，用数组的 $(C .init) 属性赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Some of the variables that these blocks need may not be accessible within these blocks:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022405Z" creationid="Hipter" creationdate="20160707T022405Z">
        <seg>$(LI 属于块的某些变量，块范围内有可能访问不到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Tasks can explicitly be created, started, and waited for by $(C task()), $(C executeInNewThread()), and $(C yieldForce()), respectively.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115136Z" creationid="Heromyth" creationdate="20170826T091212Z">
        <seg>$(LI 任务可以显示地用 $(C task()) 创建、用 $(C executeInNewThread()) 启动，以及用 $(C yieldForce()) 来等待完成。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The $(C core.atomic) module enables safe data sharing that can be multiple times faster than $(C synchronized).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004612Z" creationid="Heromyth" creationdate="20170826T004612Z">
        <seg>$(LI $(C core.atomic) 模块提供安全的数据共享方案，而且还比 $(C synchronized) 快很多倍。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The $(C core.sync) package includes many other concurrency primitives.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004712Z" creationid="Heromyth" creationdate="20170826T004624Z">
        <seg>$(LI $(C core.sync) 包包含了许多其他经典的并发基本操作。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The act of copying associates an additional variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020218Z" creationid="Hipter" creationdate="20160707T020218Z">
        <seg>$(LI 复制操作将增加一个与对象关联的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The color attribute of each member is determined with $(C colorAttributeOf()), which we will see below.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T043241Z" creationid="Heromyth" creationdate="20170815T043241Z">
        <seg>$(LI 每个成员的 color 属性可以使用 $(C colorAttributeOf()) 来检测。下面便来看看这个方法。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The duration between each step: This information is used for determining when the robot's next step will be.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234324Z" creationid="Heromyth" creationdate="20170824T234324Z">
        <seg>$(LI 每一步的间隔时间：决定机器人何时走下一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The exceptions that are escaped from tasks can be caught later by most of the parallelism functions like $(C yieldForce()).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T115455Z" creationid="Heromyth" creationdate="20170826T091228Z">
        <seg>$(LI 任务执行过程中抛出的异常可以在随后被类似 $(C yieldForce()) 的并行函数捕获。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The members of the type are determined by $(C __traits(allMembers)).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T110101Z" creationid="Heromyth" creationdate="20170814T110101Z">
        <seg>$(LI 该类型的所有成员可以通过 $(C __traits(allMembers)) 获得。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The number (id) of the robot: This information is sent back to the owner to identify the robot that the message is related to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234234Z" creationid="Heromyth" creationdate="20170824T234234Z">
        <seg>$(LI 机器人的编号 (id)：这个参数会随着消息传回线程所有者，这样我们就可以通过它确认消息的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The origin: This is where the robot starts moving from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234259Z" creationid="Heromyth" creationdate="20170824T234259Z">
        <seg>$(LI 起点：机器人的初始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The owner cannot automatically catch exceptions that are thrown from the worker.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T025143Z" creationid="Heromyth" creationdate="20170825T140819Z">
        <seg>$(LI 所有者线程无法自动捕获工作线程中的异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The value of each member is converted to $(C string) to be used later when printing to the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042044Z" creationid="Heromyth" creationdate="20170815T042044Z">
        <seg>$(LI 每个成员值都被转换为 $(C string)，以便后面输出时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI There is a $(C d) at the end of the literal $(STRING "résumé"d), specifying its type as an array of $(C dchar)s.)
)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020544Z" creationid="大处着手小处着眼" creationdate="20160714T020544Z">
        <seg>$(LI 有一个 $(C d) 在字面量 $(STRING "résumé"d) 的末尾，指定了它的类型是一个 $(C dchar) 型数组。)
)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI This program uses two indexes to make a slice:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095454Z" creationid="大处着手小处着眼" creationdate="20160714T095340Z">
        <seg>$(LI 这段程序使用两个索引值来生成一个切片：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be accessed at compile time by $(C hasUDA) and $(C __traits(getAttributes)) to alter the way the program is compiled.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053248Z" creationid="Heromyth" creationdate="20170815T053248Z">
        <seg>$(LI 自定义属性在编译时可以通过 $(C hasUDA) 和 $(C __traits(getAttributes)) 来访问，以便达到更改程序编译方式的目的。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be assigned to any declaration.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053036Z" creationid="Heromyth" creationdate="20170815T053036Z">
        <seg>$(LI 自定义属性可用于任何声明。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be type names as well as values.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053114Z" creationid="Heromyth" creationdate="20170815T053114Z">
        <seg>$(LI 自定义属性可以是类型名，也可以是具体值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When iterating over $(C RandomAccessRange) ranges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T015648Z" creationid="Heromyth" creationdate="20170826T015648Z">
        <seg>$(LI 在迭代 $(C RandomAccessRange) 范围时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When iterating over non-$(C RandomAccessRange) ranges:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T020519Z" creationid="Heromyth" creationdate="20170826T020519Z">
        <seg>$(LI 在迭代非 $(C RandomAccessRange) 范围时：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When iterating over the result ranges of $(C asyncBuf()) or parallel $(C map()) (both are explained later in this chapter):</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T021739Z" creationid="Heromyth" creationdate="20170826T021739Z">
        <seg>$(LI 在迭代 $(C asyncBuf()) 或 $(C map()) 返回的范围时（稍后本章会介绍这两个函数）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When needed, $(C TaskPool) objects other than $(C taskPool) can be used.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170831T120030Z" creationid="Heromyth" creationdate="20170826T091409Z">
        <seg>$(LI 如有必要，也可以使用 $(C TaskPool) 对象来代替 $(C taskPool) 。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When threads do not depend on other threads, prefer $(I parallelism), which has been the topic of the previous chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T025613Z" creationid="Heromyth" creationdate="20170825T135802Z">
        <seg>$(LI 如果线程间相互独立，推荐使用上一章的 $(I 并行)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI When threads do not depend on other threads, prefer $(I parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004319Z" creationid="Heromyth" creationdate="20170826T004240Z">
        <seg>$(LI 如果线程相互独立，优先选择$(I 并行)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Writing all of potentially unrelated expressions in the single $(C finally) block at the bottom separates those expressions from the actual code that they are related to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024639Z" creationid="Hipter" creationdate="20160707T024639Z">
        <seg>$(LI 把所有可能无关联的表达式写在底部单独的 $(C finally) 块，就可以分离那些有关联的可执行代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有必要保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060951Z" creationid="Hipter" creationdate="20160708T060116Z">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有被要求保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 类的析构函数不必分配新的内存给垃圾回收器。这是因为垃圾回收器没有必要保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060943Z" creationid="Hipter" creationdate="20160708T055701Z">
        <seg>$(LI 类的析构函数一定不分配由垃圾回收器管理的新内存。这是因为垃圾回收器没有被要求保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LINK2 /ders/d.en/inheritance.html, Polymorphism) is for abstracting parts of programs from each other and is achieved by class $(I interfaces).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013450Z" creationid="Heromyth" creationdate="20170819T122822Z">
        <seg>$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(MONO
$(B
Operation   Value            Meaning)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003833Z" creationid="Heromyth" creationdate="20170820T003833Z">
        <seg>$(MONO
$(B
操作   值            含义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(MONO
$(B Operation        Thread A                             Thread B)
────────────────────────────────────────────────────────────────────────────</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235714Z" creationid="Heromyth" creationdate="20170825T235714Z">
        <seg>$(MONO
$(B 操作        线程 A                             线程 B)
────────────────────────────────────────────────────────────────────────────</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(OL
$(LI
Providing the index of the element to remove.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144608Z" creationid="Heromyth" creationdate="20170817T144608Z">
        <seg>$(OL
$(LI
提供需要删除的那个元素的索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(OL
$(LI The type of string literals like $(STRING "hello") is $(C string), not $(C char[]), so they are immutable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150351Z" creationid="Hipter" creationdate="20160713T024251Z">
        <seg>$(OL
$(LI 像 $(STRING "hello") 这样的字符串字面量的类型是 $(C string)，而不是 $(C char[])，因此它们是  immutable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(B Hint:) You may want to put the elements in separate arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023612Z" creationid="大处着手小处着眼" creationdate="20160726T023612Z">
        <seg>$(P
$(B 提示：) 你可以把元素放入单独的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(B Reminder:) The element numbers of January and December are 0 and 11 respectively; not 1 and 12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T015216Z" creationid="大处着手小处着眼" creationdate="20160725T015216Z">
        <seg>$(P
$(B 提醒：) 一月和十二月的元素位置数分别是 0 和 11；而不是 1 和 12。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C .clear) removes all elements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034400Z" creationid="Hipter" creationdate="20160709T034400Z">
        <seg>$(P
$(C .clear) 移除全部元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C TaskPool.finish()) tells the object to stop processing when all of its current tasks are completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091100Z" creationid="Heromyth" creationdate="20170826T091100Z">
        <seg>$(P
$(C TaskPool.finish()) 会在所有任务完成后停止程序进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C amap()) works faster than $(C map()) at the expense of using an array that is large enough to store all of the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075020Z" creationid="Heromyth" creationdate="20170826T075020Z">
        <seg>$(P
$(C amap()) 的确比 $(C map()) 的速度快。但相应的代价是它需要提前准备好一个足够大的数组来储存结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C asyncBuf()) can be used outside of $(C foreach) loops as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073322Z" creationid="Heromyth" creationdate="20170826T073322Z">
        <seg>$(P
$(C asyncBuf()) 也可以在 $(C foreach) 外使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C asyncBuf()) takes a range and an optional $(I buffer size) that determines how many elements to be made available during each wave:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T151111Z" creationid="Heromyth" creationdate="20170826T045824Z">
        <seg>$(P
$(C asyncBuf()) 有两个形参：一个是范围；另一个是可选的$(I 缓冲区大小)。缓冲区大小决定了每轮将有多少元素被加载到缓冲区。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C atomicOp) can be used with other binary operators as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003500Z" creationid="Heromyth" creationdate="20170826T003500Z">
        <seg>$(P
$(C atomicOp) 也可以用在其他二元操作符上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C hasUDA) can be used with an attribute type as well as a specific value of that type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104724Z" creationid="Heromyth" creationdate="20170810T104724Z">
        <seg>$(P
$(C hasUDA) 除了可以与属性类型的特定值一起使用外，还可以与属性类型一起使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C is) specifies whether two class variables provide access to the same class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014640Z" creationid="Hipter" creationdate="20160707T014640Z">
        <seg>$(P
$(C is) 确定两个类变量是否提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C main()) stores the return value of $(C spawn()) under the name $(C worker) and uses that variable when sending messages to the worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233209Z" creationid="Heromyth" creationdate="20170824T233209Z">
        <seg>$(P
$(C main()) 将 $(C spawn()) 的返回值储存在 $(C worker) 变量中并通过它来给工作线程发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C parallel()) does not start parallel executions until $(I work unit size) number of elements of a non-$(C RandomAccessRange) have been executed serially first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T021638Z" creationid="Heromyth" creationdate="20170826T020925Z">
        <seg>$(P
只有在非 $(C RandomAccessRange) 中与$(I 工作单元大小)相同数量的元素被顺序处理时，$(C parallel()) 才会开始并行执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) can be used without a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021213Z" creationid="Hipter" creationdate="20160712T021213Z">
        <seg>$(P
$(C readln()) 没有参数也可以使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) is more suitable when reading strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015132Z" creationid="Hipter" creationdate="20160712T015132Z">
        <seg>$(P
$(C readln()) 更适合读取字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) stores the new-line character as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135825Z" creationid="Hipter" creationdate="20160712T015736Z">
        <seg>$(P
$(C readln()) 也存储换行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C receiveOnly()) can expect only one type of message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T020011Z" creationid="Heromyth" creationdate="20170824T235822Z">
        <seg>$(P
$(C receiveOnly()) 只能接收一种类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C reduce()) is another high-level algorithm commonly found in many functional languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075327Z" creationid="Heromyth" creationdate="20170826T075327Z">
        <seg>$(P
$(C reduce()) 也是一个经常在函数式编程中使用的高阶函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C reduce()) uses the elements in sequence to reach the final value of the result:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083004Z" creationid="Heromyth" creationdate="20170826T083004Z">
        <seg>$(P
$(C reduce()) 将按照顺序使用元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C scope) statements can be specified as blocks as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035056Z" creationid="Hipter" creationdate="20160707T035056Z">
        <seg>$(P
$(C scope) 语句也可以像块一样使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C send()) sends messages and $(C receiveOnly()) waits for a message of a particular type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T013958Z" creationid="Heromyth" creationdate="20170824T232755Z">
        <seg>$(P
$(C send()) 可用于发送消息，而 $(C receiveOnly()) 可用于等待待定类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C spawn()) takes a function pointer as a parameter and starts a new thread from that function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T001948Z" creationid="Heromyth" creationdate="20170824T054244Z">
        <seg>$(P
$(C spawn()) 需要一个函数指针作为参数，并且会从该函数启动一个新线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C spawnLinked()) is used in the same way as $(C spawn()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052301Z" creationid="Heromyth" creationdate="20170825T052301Z">
        <seg>$(P
$(C spawnLinked()) 与 $(C spawn()) 用法相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.map()), $(C taskPool.map()), $(C taskPool.amap()), and $(C taskPool.reduce()) can all take more than one function, in which case the results are returned as a $(C Tuple).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085039Z" creationid="Heromyth" creationdate="20170826T085039Z">
        <seg>$(P
$(C std.algorithm.map())、$(C taskPool.map())、$(C taskPool.amap()) 和 $(C taskPool.reduce()) 都允许传入多个函数处理元素，并返回类型为 $(C Tuple) 的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.map) takes the function as its template parameter, and the range as its function parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073904Z" creationid="Heromyth" creationdate="20170826T073904Z">
        <seg>$(P
$(C std.algorithm.map) 有一个模版参数用来接收函数，有一个函数形参用来接收范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.reverse) reverses the elements in place (the first element becomes the last element, etc.):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021752Z" creationid="大处着手小处着眼" creationdate="20160726T021752Z">
        <seg>$(P
$(C std.algorithm.reverse) 反转元素的位置（第一个元素成为最后一个元素，以此类推）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.sort) can sort the elements of many types of collections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051323Z" creationid="大处着手小处着眼" creationdate="20160726T021228Z">
        <seg>$(P
$(C std.algorithm.sort) 可以对许多类型集合中的元素进行排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.concurrency) does not provide such a convenience for general exception types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044657Z" creationid="Heromyth" creationdate="20170825T044657Z">
        <seg>$(P
$(C std.concurrency) 并未提供这种捕获异常的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C taskPool) contains appropriate number of tasks depending on the environment that the program runs under.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T142150Z" creationid="Heromyth" creationdate="20170826T090224Z">
        <seg>$(P
$(C taskPool) 需要容纳的任务总数取决于程序运行的具体环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C taskPool.map()) from the $(C std.parallelism) module works essentially the same as $(C std.algorithm.map).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074112Z" creationid="Heromyth" creationdate="20170826T074112Z">
        <seg>$(P
$(C std.parallelism) 模块中的 $(C taskPool.map()) 和 $(C std.algorithm.map) 的功能相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C taskPool.reduce()) should be used only under these considerations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084035Z" creationid="Heromyth" creationdate="20170826T084035Z">
        <seg>$(P
只有在满足以上条件的情况下才可以使用 $(C taskPool.reduce())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C thisTid()) returns the identifier of the $(I current) thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232250Z" creationid="Heromyth" creationdate="20170824T232250Z">
        <seg>$(P
$(C thisTid()) 返回$(I 当前)线程的 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C variable) that is modified inside $(C worker()) is not the same $(C variable) that is seen by $(C main()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T030104Z" creationid="Heromyth" creationdate="20170825T144845Z">
        <seg>$(P
$(C worker()) 修改的 $(C variable) 与 $(C main()) 访问的 $(C variable) 并不相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C yieldForce()) can be called in a $(C try-catch) block to catch the exceptions that are thrown by the task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T035111Z" creationid="Heromyth" creationdate="20170826T035111Z">
        <seg>$(P
可以在 $(C try-catch) 语句块中调用 $(C yieldForce()) 来捕获由 task 抛出的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(HILITE $(I $(B Note:) This feature is not supported by dmd 2.074.0.))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000802Z" creationid="Heromyth" creationdate="20170826T000745Z">
        <seg>$(P
$(HILITE $(I $(B 注意：) dmd 2.074.0 并不支持此功能。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) An associative array that is defined without any element is $(LINK2 /ders/d.en/null_is.html, $(C null)), not empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T143323Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
$(I $(B 注：) 已定义的没有任何元素的关联数组是 $(LINK2 /ders/d.cn/null_is.html, $(C null))，而不是空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) If the shorter equivalents of the expression above are used (i.e. $(C ++(*value)) and $(C &amp;#8209;&amp;#8209;(*value))), then the compiler warns that such read-modify-write operations on $(C shared) variables are deprecated.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000435Z" creationid="Heromyth" creationdate="20170826T000435Z">
        <seg>$(P
$(I $(B 注意：) 如果将上方的等式换成自增或自检（例如， $(C ++(*value)) 和 $(C &amp;#8209;&amp;#8209;(*value))），编译器会警告：对 $(C shared) 变量执行的读取-修改-写入操作已被弃用。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) It is a relatively expensive operation for a thread to wait for a lock, which may slow down the execution of the program noticeably.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000141Z" creationid="Heromyth" creationdate="20170826T000141Z">
        <seg>$(P
$(I $(B 注意：) 等待锁是一个相对昂贵的操作，它可能会显著降低程序的执行速度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) It is usually not proper to access members directly as in the code above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T023005Z" creationid="Hipter" creationdate="20160707T004627Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) Prefer message-passing to signal a thread.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233735Z" creationid="Heromyth" creationdate="20170825T233735Z">
        <seg>$(P
$(I $(B 注意：) 推荐使用消息传递向线程发送控制信号。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The execution time of the program may be different on other systems but it is expected to be roughly "4 seconds divided by the number of cores".)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T133258Z" creationid="Heromyth" creationdate="20170826T014221Z">
        <seg>$(P
$(I $(B 注意：)在不同的系统上运行上面的程序可能会有不同的执行时间，但大致都是“4 秒除以内核数”的结果。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The free-standing $(C averageGrade()) function above is needed due to a limitation that involves using local delegates with member function templates like $(C TaskPool.map).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074526Z" creationid="Heromyth" creationdate="20170826T074526Z">
        <seg>$(P
$(I $(B 注意：)之所以上面的代码需要一个独立的 $(C averageGrade()) 函数是因为像 $(C TaskPool.map) 这样的成员模版函数存在无法使用局部委托的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The indexes above are for demonstration purposes only; they are not stored in the computer's memory.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024515Z" creationid="大处着手小处着眼" creationdate="20160725T024249Z">
        <seg>$(P
$(I $(B 注意：) 上面的索引仅用于演示；并没有存储在计算机的内存中。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The meaning of the assignment operation is completely different for dynamic arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013455Z" creationid="大处着手小处着眼" creationdate="20160726T013455Z">
        <seg>$(P
$(I $(B 注意：) 赋值运算符的含义与动态数组完全不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) Unicode does not define how the characters are ordered other than their Unicode codes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T110655Z" creationid="大处着手小处着眼" creationdate="20160715T033832Z">
        <seg>$(P
$(I $(B 注：)除了 Unicode 编码顺序之外，Unicode 不定义字符的排列顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020523Z" creationid="Hipter" creationdate="20160708T020523Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的一章) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX ()) As has been mentioned in the previous chapter, when there is no argument to pass, functions can be called without parentheses:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044451Z" creationid="Heromyth" creationdate="20170906T044451Z">
        <seg>$(P
$(IX ()) 我们在之前的章节中提到过，如果调用函数时不需要传递参数，那我们可以省略圆括号：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX .init, clearing a variable) $(I $(B Note:) The $(C .init) property of any variable or type is the initial value of that type:)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084743Z" creationid="Hipter" creationdate="20160709T084655Z">
        <seg>$(P
$(IX .init, 清除一个变量) $(I $(B 注：) 任何变量或类型的 $(C .init) 属性是类型的初始值：)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX :, associative array) Sometimes some of the mappings between the keys and the values are already known at the time of the definition of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030702Z" creationid="Hipter" creationdate="20160709T030702Z">
        <seg>$(P
$(IX :, 关联数组) 有时候一些键与值的映射在定义关联数组的时候就已经明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX @) The user defined attribute syntax consists of the $(C @) sign followed by the attribute and appear before the declaration that it is being assigned to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T041949Z" creationid="Heromyth" creationdate="20170720T041949Z">
        <seg>$(P
$(IX @)自定义属性的语法格式：符号 $(C @)  的后面紧跟属性名，并且需要放置在与之相关的那个声明前面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX @property) Properties are member functions that are used like member variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044359Z" creationid="Heromyth" creationdate="20170906T044359Z">
        <seg>$(P
$(IX @property) 特性实际上就是成员函数，但我们却可以像使用成员变量一样调用它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX CPU bound) $(IX I/O bound) $(IX thread performance) Every operating system puts limits on the number of threads that can exist at one time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T002717Z" creationid="Heromyth" creationdate="20170824T231837Z">
        <seg>$(P
$(IX CPU bound) $(IX I/O bound) $(IX thread performance) 每个操作系统都会限制线程同时运行的个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX CPU) $(IX microprocessor) The brain of the computer is the microprocessor (or the CPU, short for $(I central processing unit)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003419Z" creationid="Heromyth" creationdate="20170820T003419Z">
        <seg>$(P
$(IX CPU) $(IX microprocessor) 计算机的大脑是微处理器（CPU，即 $(I 中央处理单元) 的简称)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX MessageMismatch) If the types do not match, a $(C MessageMismatch) exception is thrown:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T015951Z" creationid="Heromyth" creationdate="20170824T233608Z">
        <seg>$(P
$(IX MessageMismatch) 如果类型不匹配，则程序将会抛出一个 $(C MessageMismatch) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX OOP) $(IX object oriented programming) $(IX user defined type) Similar to structs, $(C class) is a feature for defining new types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T115209Z" creationid="Heromyth" creationdate="20170819T115209Z">
        <seg>$(P
$(IX OOP) $(IX object oriented programming) $(IX user defined type) 与结构相似，$(C class) 具有定义新类型的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T015721Z" creationid="Hipter" creationdate="20160708T015721Z">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D语言中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX Thread.sleep) To simulate long-lasting operations, the following examples call $(C Thread.sleep()) from the $(C core.thread) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013149Z" creationid="Heromyth" creationdate="20170826T013041Z">
        <seg>$(P
$(IX Thread.sleep) 下面的例子使用了 $(C core.thread)  模块中的 $(C Thread.sleep()) 来模拟长耗时操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX Variant, concurrency) $(C std.variant.Variant) is a type that can encapsulate any type of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T042428Z" creationid="Heromyth" creationdate="20170825T042428Z">
        <seg>$(P
$(IX Variant, concurrency) $(C std.variant.Variant) 类型可以封装任意类型的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX __gshared) An exception of this rule is a variable that is defined as $(C __gshared):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145219Z" creationid="Heromyth" creationdate="20170825T145219Z">
        <seg>$(P
$(IX __gshared) 除非使用 $(C __gshared) 定义变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX __traits) $(IX getAttributes) The meaning of attributes is solely determined by the programmer for the needs of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043110Z" creationid="Heromyth" creationdate="20170803T110205Z">
        <seg>$(P
$(IX __traits) $(IX getAttributes) 属性的实际含义完全由程序员根据程序的需要来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX core) Most modern microprocessors consist of more than one $(I core), each of which can operate as an individual processing unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124655Z" creationid="Heromyth" creationdate="20170826T012532Z">
        <seg>$(P
$(IX core) 大多数现代的微处理器都包含一个以上的$(I 内核)，其中的每一个内核都可以当作单独的处理单元使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX deadlock) The error can be explained by an example where one thread attempting to transfer money from account A to account to B while another thread attempting to transfer money in the reverse direction.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001318Z" creationid="Heromyth" creationdate="20170826T001318Z">
        <seg>$(P
$(IX deadlock) 我们会用一个例子来解释程序为什么出错。示例中有一个线程想要将账户 A 中的资金转到账户 B，而另一个线程想要将账户 B 中的资金转到账户 A。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX final) As overridable member functions have a runtime performance cost, without going into more detail, I recommend that you define all $(C class) functions that do not need to be overridden with the $(C final) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012042Z" creationid="Hipter" creationdate="20160707T012042Z">
        <seg>$(P
$(IX final) 由于可重写的成员函数有一个运行时性能消耗，在这儿不讨论更多细节，我推荐您定义全部没必要用 $(C final) 关键字重写的 $(C class) 成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX finalizer versus destructor) However, different from structs, class destructors are not executed at the time when the lifetime of a class object ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T134503Z" creationid="Heromyth" creationdate="20170819T134503Z">
        <seg>$(P
$(IX finalizer versus destructor) 不过，与结构有所不同的是，类的析构函数在类对象的生命期结束时并不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX flush, std.stdio) $(I $(B Note:) Normally, the characters that are printed to output streams like $(C stdout) do not appear on the output right away.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T023819Z" creationid="Heromyth" creationdate="20170826T023819Z">
        <seg>$(P
$(IX flush, std.stdio) $(I $(B 注意：)正常情况下向类似 $(C stdout) 这样的输出流直接输出的字符并不会立刻显示出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX fold, std.algorithm) $(C reduce()) is the equivalent of $(C std.algorithm.fold), which we have seen before in the $(LINK2 /ders/d.en/ranges.html, Ranges chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075251Z" creationid="Heromyth" creationdate="20170826T075225Z">
        <seg>$(P
$(IX fold, std.algorithm) $(C reduce()) 与 $(C std.algorithm.fold) 相同。我们已经在 $(LINK2 /ders/d.cn/ranges.html, Ranges) 一章中学习到了相关知识。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX foreach, parallel) $(C parallel()) accesses the elements of a range in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T133320Z" creationid="Heromyth" creationdate="20170826T013644Z">
        <seg>$(P
$(IX foreach, parallel) $(C parallel()) 以并行的方式访问范围中的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX hasUDA, std.traits) Another useful tool is $(C std.traits.hasUDA), which determines whether a symbol has a specific attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104354Z" creationid="Heromyth" creationdate="20170810T104354Z">
        <seg>$(P
$(IX hasUDA, std.traits) 另一个有用的工具是 $(C std.traits.hasUDA)，它可检测某个符号是否拥有某个特定的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX immutable, concurrency) On the other hand, since $(C immutable) variables cannot be modified, there is no problem with sharing them directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233747Z" creationid="Heromyth" creationdate="20170825T233747Z">
        <seg>$(P
$(IX immutable, concurrency) 另一方面，由于 $(C immutable) 变量无法被修改，它们可以直接共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX lock) The effect of $(C synchronized) is to create a lock behind the scenes and to allow only one thread hold that lock at a given time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000021Z" creationid="Heromyth" creationdate="20170826T000021Z">
        <seg>$(P
$(IX lock) $(C synchronized) 会在后台创建一个锁，同一时间只有一个线程能持有这个锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX map, std.algorithm) It helps to explain $(C map()) from the $(C std.algorithm) module before explaining $(C taskPool.map()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073408Z" creationid="Heromyth" creationdate="20170826T073408Z">
        <seg>$(P
$(IX map, std.algorithm)在介绍 $(C taskPool.map()) 之前，先了解一下 $(C std.algorithm) 模块的 $(C map()) 对理解本节的内容是非常有帮助的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX message) $(B Message): Data that is passed between threads are called messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054058Z" creationid="Heromyth" creationdate="20170824T054058Z">
        <seg>$(P
$(IX message) $(B 消息)：在线程间传递的数据叫做消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX owner) $(B Owner): Any thread that starts another thread is called the owner of the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T001433Z" creationid="Heromyth" creationdate="20170824T054156Z">
        <seg>$(P
$(IX owner) $(B 所有者)：任何启动另一个线程的线程即为该新线程的所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX parallelism vs. concurrency) $(IX concurrency vs. parallelism) The following are the differences between parallelism and concurrency:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T005423Z" creationid="Heromyth" creationdate="20170824T011639Z">
        <seg>$(P
$(IX parallelism vs. concurrency) $(IX concurrency vs. parallelism) 并发和并行的区别主要有以下几点：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX reduce, std.algorithm) As with $(C map()), it helps to explain $(C reduce()) from the $(C std.algorithm) module first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T151212Z" creationid="Heromyth" creationdate="20170826T075153Z">
        <seg>$(P
$(IX reduce, std.algorithm)与 $(C map()) 一样，先来了解下 $(C std.algorithm) 模块里的 $(C reduce())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX scalar) That definition can be read as $(I 5 double values).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044231Z" creationid="大处着手小处着眼" creationdate="20160720T030622Z">
        <seg>$(P
$(IX 标量) 这个定义可以理解为 $(I 5 个 double 值)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX setMaxMailboxSize) $(C setMaxMailboxSize()) is used for limiting the number of messages that a mailbox can hold.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T023919Z" creationid="Heromyth" creationdate="20170825T134421Z">
        <seg>$(P
$(IX setMaxMailboxSize)$(C setMaxMailboxSize()) 可以限制邮箱保存的消息数量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX task) $(IX executeInNewThread) $(IX yieldForce) When tasks do not correspond to or cannot be represented by elements of a range, these three steps can be handled explicitly by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142522Z" creationid="Heromyth" creationdate="20170826T022323Z">
        <seg>$(P
$(IX task) $(IX executeInNewThread) $(IX yieldForce) 当任务无法与范围元素相对应或者无法通过它们来表示时，程序员可以自己按照以下三步手动处理：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread id) $(B Thread identifier): Every thread has an id, which is used for specifying recipients of messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T001343Z" creationid="Heromyth" creationdate="20170824T054136Z">
        <seg>$(P
$(IX thread id) $(B 线程 ID)：每个线程都有一个 ID，你可以用它来指定消息的接收者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread) $(B Thread): Operating systems execute programs as work units called $(I threads).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222736Z" creationid="Heromyth" creationdate="20170824T012434Z">
        <seg>$(P
$(IX thread) $(B 线程)：操作系统执行程序的工作单元叫做 $(I 线程)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread) A flow of execution through certain parts of a program is called a a $(I thread of execution) or a $(I thread).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T015105Z" creationid="Heromyth" creationdate="20170826T014237Z">
        <seg>$(P
$(IX thread) 执行程序某一部分的执行流被称为 $(I 执行线程) 或 $(I 线程)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread_joinAll) The $(C thread_joinAll()) call that is seen at the end of $(C main()) is for making the owner to wait for all of its workers to terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135734Z" creationid="Heromyth" creationdate="20170825T135734Z">
        <seg>$(P
$(IX thread_joinAll) $(C main()) 末尾处的  $(C thread_joinAll()) 会阻塞所有者线程，等待所有工作线程终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX totalCPUs) Before seeing how this is done, let's first determine the number of cores that are available on the system by $(C std.parallelism.totalCPUs):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013441Z" creationid="Heromyth" creationdate="20170826T013413Z">
        <seg>$(P
$(IX totalCPUs) 在了解实现方法之前，我们先来看下如何通过使用 $(C std.parallelism.totalCPUs) 来获取系统可用的处理器核心数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX worker) $(B Worker): Any thread that is started by an owner is called a worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T001831Z" creationid="Heromyth" creationdate="20170824T054216Z">
        <seg>$(P
$(IX worker) $(B 工作线程)：由所有者启动的任何线种都叫做工作线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类析构函数应该叫 $(I 终结函数)) 。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T151443Z" creationid="Hipter" creationdate="20160707T050655Z">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类的析构函数应该叫 $(I 终结函数)) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(LINK_DOWNLOAD /ders/d.en/Programming_in_D_code_samples.zip, Click here to download code samples as a $(C .zip) file.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052452Z" creationid="Heromyth" creationdate="20170801T052326Z">
        <seg>$(P
$(LINK_DOWNLOAD /ders/d.en/Programming_in_D_code_samples.zip, 点击此处可下载 $(C .zip) 文件形式的示例代码。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A $(C static assert) inside the $(C std.concurrency) module prevents accessing $(I mutable) data from another thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145145Z" creationid="Heromyth" creationdate="20170825T145145Z">
        <seg>$(P
$(C std.concurrency) 模块中的 $(C static assert) 阻止线程访问其他线程中的$(I 可变)数据：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A better way would be to represent the concept of area as a property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044908Z" creationid="Heromyth" creationdate="20170906T044908Z">
        <seg>$(P
所以我们最好用特性来实现面积。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A class variable on the other hand is a language feature for accessing class objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013346Z" creationid="Heromyth" creationdate="20170820T013346Z">
        <seg>$(P
另一方面，类变量一种访问类对象的语言功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A compiler is another tool that reads the instructions of a program from source code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004725Z" creationid="Heromyth" creationdate="20170820T004725Z">
        <seg>$(P
编译器是另一种从源码中读取程序指令的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A flaw in that design is that the object may easily become inconsistent: Although rectangles must always have the invariant of "width * height == area", this consistency may be broken if the members are allowed to be modified freely and independently.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044741Z" creationid="Heromyth" creationdate="20170906T044741Z">
        <seg>$(P
这种设计的缺点是对象很容易出现不一致性：虽然矩形永远都是“长 × 宽 == 面积”，但是如果成员变量能被随意修改的话，对象的一致性将极易被破坏。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A lambda function or an object of a type that defines the $(C opCall) member can also be used as the task function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034707Z" creationid="Heromyth" creationdate="20170826T034707Z">
        <seg>$(P
lambda 函数和定义了 $(C opCall) 的对象都可以被当作任务函数使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A well known example of this problem is a function that tries to transfer money from one bank account to another.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001220Z" creationid="Heromyth" creationdate="20170826T001220Z">
        <seg>$(P
这个问题有一个著名的例子：想要编写一个函数将某个银行账户中的资金转到另一个账户。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
According to that output, the elements are produced and used sequentially.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073058Z" creationid="Heromyth" creationdate="20170826T073058Z">
        <seg>$(P
从输出结果来看，这些元素都被依次生成和使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Accordingly, the equivalent of the five separate variables above can be defined as an array of five values using the following syntax:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T025431Z" creationid="大处着手小处着眼" creationdate="20160720T025022Z">
        <seg>$(P
因此，上面的五个独立的变量可以等效的使用下面的语法定义为含五个值的数组：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Additionally, as a consequence of their ASCII code values, all of the latin uppercase letters are sorted before all of the lowercase letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143655Z" creationid="大处着手小处着眼" creationdate="20160715T143655Z">
        <seg>$(P
另外，受 ASCII 编码值的影响，所有拉丁大写字母都排在小写字母的前面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Additionally, as the results are used by the same functions one last time in the sequential calculations, the types of the parameters that the functions take must be compatible with the types of the values that the functions return.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084021Z" creationid="Heromyth" creationdate="20170826T084021Z">
        <seg>$(P
除此之外，由于在最后串行运算的时候使用的函数与之前相同，函数的返回值必须与函数的参数类型相同或可以相互转换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Additionally, the length of dynamic arrays can be changed by assigning a value to this property:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072227Z" creationid="大处着手小处着眼" creationdate="20160725T072227Z">
        <seg>$(P
另外，通过对这个 property 指定一个值就可以修改动态数组的 length：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
All of the elements of the $(C values) array above are initialized to $(C double.nan):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082906Z" creationid="大处着手小处着眼" creationdate="20160725T082906Z">
        <seg>$(P
上面 $(C values) 数组的所有元素都初始化为 $(C double.nan)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
All of the messages in this simple program go from the worker to the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234607Z" creationid="Heromyth" creationdate="20170824T234607Z">
        <seg>$(P
本例中的所有消息都是从工作线程向线程所有者传递的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
All of the threads of all of the programs that are active at a given time are executed on the very cores of the microprocessor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014317Z" creationid="Heromyth" creationdate="20170826T014317Z">
        <seg>$(P
所有程序的所有在操作系统指定时间活动的线程将会在微处理器的每个核心上执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Also available as $(LINK2 https://gumroad.com/l/PinD, $(I pay-what-you-want) eBooks at Gumroad) and $(I free) here as $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.pdf, PDF), $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.epub, EPUB), $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.azw3, AZW3), and $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.mobi, MOBI).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T012601Z" creationid="Heromyth" creationdate="20170801T042848Z">
        <seg>$(P
其他提供形式还包括：$(LINK2 https://gumroad.com/l/PinD, Gumroad提供的$(I 按需支付) 电子书) 以及各种$(I 免费) 版本的电子书，如 $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.pdf, PDF)、$(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.epub, EPUB)、$(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.azw3, AZW3) 和 $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.mobi, MOBI)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Also note that to avoid confusing their names with the member functions, the names of the member variables are appended by the $(C _) character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071023Z" creationid="Heromyth" creationdate="20170906T071023Z">
        <seg>$(P
注意不要混淆了变量和函数的名字：成员变量的名字多了一个 $(C _)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Also observe that total number of swaps is 10 times 10 thousand.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235313Z" creationid="Heromyth" creationdate="20170825T235313Z">
        <seg>$(P
除此之外我们还可以看到程序一共启动了 10 个线程，每个线程执行 1 万次交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although "résumé" contains six $(I letters), the length of the $(C string) is the number of UTF-8 code units that it contains:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T001021Z" creationid="大处着手小处着眼" creationdate="20160714T012628Z">
        <seg>$(P
虽然 "résumé" 包含6个$(I 字母)，但$(C 字符串)的长度是它包含的 UTF-8 编码单元的个数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although it is possible that the program can indeed produce that result, most of the time the actual outcome would be one of the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235430Z" creationid="Heromyth" creationdate="20170825T235430Z">
        <seg>$(P
虽然程序的确可以得到我们预期的那种结果，但是实际上大多数情况下程序的输出都是下面这样的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although member functions are defined and used the same way as structs, there is an important difference: Class member functions can be and by-default are $(I overridable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005644Z" creationid="Hipter" creationdate="20160707T005311Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although the program above gets compiled successfully, in most cases it would work incorrectly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235238Z" creationid="Heromyth" creationdate="20170825T235238Z">
        <seg>$(P
虽然上面这个程序顺利通过了编译，但在大多数情况下它并不能正确工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although the syntax makes it look as if a member of the $(I variable) is being accessed, it is actually the member of the $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004236Z" creationid="Hipter" creationdate="20160707T004236Z">
        <seg>$(P
虽然语法上看起来像访问 $(I 变量) 的成员，实际上是 $(I 对象) 的成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although these optimizations are effective, they cannot be applied automatically to layers higher than the very low-level operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012917Z" creationid="Heromyth" creationdate="20170826T012917Z">
        <seg>$(P
虽然这些优化效果显著，但是它们通常只能自动应用在非常低级别的操作上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although these statements are closely related to exceptions, they can be used without a $(C try-catch) block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025855Z" creationid="Hipter" creationdate="20160707T025855Z">
        <seg>$(P
虽然这些语句只在特殊情况下使用，但是没有 $(C try-catch) 块也能用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An attribute can be a type name as well as a value of a user defined or a fundamental type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043344Z" creationid="Heromyth" creationdate="20170803T043344Z">
        <seg>$(P
属性除了可以是自定义类型值或基础类型值以外，还可是以类型名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An index need not be a constant value; the value of a variable can also be used as an index, making arrays even more useful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021213Z" creationid="大处着手小处着眼" creationdate="20160725T021213Z">
        <seg>$(P
索引不必是恒定值；变量的值也能用作索引，这会让数组更有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An interpreter is a tool (a program) that reads the instructions from source code and executes them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004237Z" creationid="Heromyth" creationdate="20170820T004237Z">
        <seg>$(P
解释器是一种能从源码中读取指令并执行相应命令的工具（程序）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another difference from structs is that some member functions are automatically inherited from the $(C Object) class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012709Z" creationid="Hipter" creationdate="20160707T012709Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another method involves more than one thread reading from and writing to the same data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143403Z" creationid="Heromyth" creationdate="20170825T143403Z">
        <seg>$(P
另外一种共享消息的方法是多个线程读写同一块数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another method would be to send the actual exception object itself to the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T023407Z" creationid="Heromyth" creationdate="20170825T051841Z">
        <seg>$(P
另外一种方法是直接将异常对象发送回所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another overload of $(C task()) takes the function as its first function parameter instead:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143749Z" creationid="Heromyth" creationdate="20170826T034617Z">
        <seg>$(P
$(C task()) 函数的另一个重载形式是将函数作为其第一个形参：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another way of ensuring that only one thread mutates a certain variable is by using atomic operations, functionality of which are provided by the microprocessor, the compiler, or the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002846Z" creationid="Heromyth" creationdate="20170826T002846Z">
        <seg>$(P
另一种确保同一时间只有一个线程能修改变量的方法是原子操作。这个功能是由处理器、编译器或操作系统提供的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Any declaration (e.g. struct type, class type, variable, etc.) can be assigned attributes, which can then be accessed at compile time to alter the way the code is compiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170719T105759Z" creationid="Heromyth" creationdate="20170719T105759Z">
        <seg>$(P
所有声明（如结构、类和变量等）都可以加上属性，以便在编译时访问这些属性来调整该部分代码的编译方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Array elements can be removed with the $(C remove()) function from the $(C std.algorithm) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T143321Z" creationid="Heromyth" creationdate="20170817T143321Z">
        <seg>$(P
可以使用模块 $(C std.algorithm) 里的 $(C remove()) 函数删除数组元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays are containers where the elements are placed side by side in the computer's memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T023531Z" creationid="大处着手小处着眼" creationdate="20160725T023454Z">
        <seg>$(P
数组是容器，其中的元素在计算机的内存中是逐个放置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays are useful in such cases: the array feature allows us to define a single variable that stores multiple values together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022057Z" creationid="大处着手小处着眼" creationdate="20160720T021831Z">
        <seg>$(P
数组在这种情况下是有用的：数组功能允许我们定义一个把多个值存储到一起的单个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays have properties as well, of which we will see only $(C .length) here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071857Z" creationid="大处着手小处着眼" creationdate="20160725T071857Z">
        <seg>$(P
数组也有 properties（属性），在这儿我们只会看到 $(C .length)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays provide convenience operations that apply to all of their elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012802Z" creationid="大处着手小处着眼" creationdate="20160726T012802Z">
        <seg>$(P
数组提供了适用于所有元素的方便操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a result, assigning the quarter of its current value to $(C area) ends up halving both sides of the rectangle:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070708Z" creationid="Heromyth" creationdate="20170906T070708Z">
        <seg>$(P
对这个版本的 $(C area) 赋值时矩形两边的长度都会改变：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a result, passing the $(C Student) range through $(C parallel()) makes the program above finish in 1 second on a system that has 4 cores:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T015040Z" creationid="Heromyth" creationdate="20170826T013909Z">
        <seg>$(P
最后，在一个有 4 核的系统上，将 $(C Student) 范围传递给 $(C parallel()) 可以使上面的程序在 1 秒之内完成：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a result, the objects that are associated with $(C var1) and $(C var2) are different.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T132622Z" creationid="Hipter" creationdate="20160706T023913Z">
        <seg>$(P
最后，与 $(C var1) 和 $(C var2) 关联的那些对象并不相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a simple example, let's consider a rectangle struct that consists of two members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044702Z" creationid="Heromyth" creationdate="20170906T044702Z">
        <seg>$(P
我们使用下面这个包含两个成员的矩形结构体作为示例：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As an example, let's write the function above with a $(C scope(failure)) statement:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T030221Z" creationid="Hipter" creationdate="20160707T030221Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As an extreme example, objects may even begin their lives in inconsistent states:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044827Z" creationid="Heromyth" creationdate="20170906T044827Z">
        <seg>$(P
有一个极端例子，对象在其生命期开始时就已经处在不一致的状态：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As can be seen, at the end of the previous scenario both $(C i) and $(C j) end up having the value 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235803Z" creationid="Heromyth" creationdate="20170825T235803Z">
        <seg>$(P
经过这种情况的执行后 $(C i) 和 $(C j) 的值最后都变成了 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As in the $(C parallel()) and $(C map()) examples, importing the $(C std.parallelism) module and calling $(C taskPool.reduce()) is sufficient to take advantage of all of the cores:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083610Z" creationid="Heromyth" creationdate="20170826T083610Z">
        <seg>$(P
与之前 $(C parallel()) 和 $(C map()) 的例子一样，只需要导入 $(C std.parallelism) 模块并调用 $(C taskPool.reduce()) 就可以利用多核心的资源了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As it has been mentioned briefly in $(LINK2 /ders/d.en/null_is.html, The $(CH4 null) Value and the $(CH4 is) Operator chapter), class variables can be $(C null).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013535Z" creationid="Heromyth" creationdate="20170819T124929Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, $(CH4 null) 值和 $(CH4 is) 运算符一章)已提到过，类变量可以为 $(C null)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As it is indicated in their documentation, the return types of $(C indexOf()) and $(C lastIndexOf()) are not $(C int) nor $(C size_t), but $(C ptrdiff_t).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154528Z" creationid="大处着手小处着眼" creationdate="20160715T144120Z">
        <seg>$(P
与它们的文档中所指出的一样，$(C indexOf()) 和 $(C lastIndexOf()) 的返回类型既不是 $(C int) 也不是 $(C size_t)，而是 $(C ptrdiff_t)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As obvious from its behavior, $(C reduce()) uses a loop in its implementation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082338Z" creationid="Heromyth" creationdate="20170826T082338Z">
        <seg>$(P
就像我们看到的那样，$(C reduce()) 使用一个循环来实现其功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As seen in the outputs, the blocks of the $(C scope) statements are executed in reverse order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045137Z" creationid="Hipter" creationdate="20160707T035844Z">
        <seg>$(P
在输出中我们看到，$(C scope) 语句块是按相反的顺序执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As soon as a new thread is started, the owner and the worker start executing separately as if they were independent programs:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054625Z" creationid="Heromyth" creationdate="20170824T054625Z">
        <seg>$(P
新线程启动后，所有者和工作线程将会独立执行，看上去它们就像是独立的程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As tasks are executed on separate threads, the exceptions that they throw cannot be caught by the thread that started them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T144133Z" creationid="Heromyth" creationdate="20170826T034848Z">
        <seg>$(P
因为任务都是在一个单独的线程上执行的，所以启动它们的那个线程并不能捕捉到它们抛出的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As the compiler compiles a program according to the rules of the language, it stops the compilation as soon as it comes across $(I illegal) instructions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005114Z" creationid="Heromyth" creationdate="20170820T005114Z">
        <seg>$(P
当编译器按照语言规则编译程序时，一旦碰到 $(I 非法) 指令就会停止编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As the value of the $(C area) property is calculated by multiplying the width and the height of the rectangle, this time it would always be consistent:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T052759Z" creationid="Heromyth" creationdate="20170906T052759Z">
        <seg>$(P
$(C area) 是由矩形的长宽相乘计算得到的，所以这次它将始终与长宽保持一致：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As this method does not involve different instantiations of the $(C Task) template, it makes it possible to put such objects in the same array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143826Z" creationid="Heromyth" creationdate="20170826T034645Z">
        <seg>$(P
采用这种方法不会产生不同类型的 $(C Task) 模版实例，因此可以把它们放在同一个数组里：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we have seen in the previous chapter, expressions that must always be executed are written in the $(C finally) block, and expressions that must be executed when there are error conditions are written in $(C catch) blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T021804Z" creationid="Hipter" creationdate="20160707T021608Z">
        <seg>$(P
在前面的章节我们已经看到，写在 $(C finally) 块里的表达式一定总被执行。当有错误条件的时候，写在 $(C catch) 块里的表达式总被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we have seen in the previous chapter, the facilities of the $(C std.parallelism) module automatically catch exceptions that have been thrown during the execution of tasks and rethrow them in the context of the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044635Z" creationid="Heromyth" creationdate="20170825T044635Z">
        <seg>$(P
上一章的 $(C std.parallelism) 自动捕获 task 执行中抛出的异常并在所有者的线程中重新抛出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we will see later in $(LINK2 /ders/d.en/memory.html, the Memory Management chapter), class destructors must observe the following rules:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001603Z" creationid="Heromyth" creationdate="20170820T001603Z">
        <seg>$(P
在后面的 $(LINK2 /ders/d.en/memory.html, 内存管理一章) 将会看到，类的析构函数必须遵循以下几条规则：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the constructor is $(C this).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032221Z" creationid="Hipter" creationdate="20160706T032221Z">
        <seg>$(P
与结构一样，构造函数的名称是 $(C this) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the destructor is $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033855Z" creationid="Hipter" creationdate="20160706T033855Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As you can see, the $(C monthDays) array is defined and initialized at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T004534Z" creationid="大处着手小处着眼" creationdate="20160726T004534Z">
        <seg>$(P
正如你所看到的，$(C monthDays) 数组在定义的时候就已初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As you would also remember, comparing a reference to $(C null) by the $(C ==) or the $(C !=) operator is an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130303Z" creationid="Heromyth" creationdate="20170819T130303Z">
        <seg>$(P
大家都还记得吧，引用与运算符 $(C null) 不能通过运算符 $(C ==) 或 $(C !=) 进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assigning to a class variable disassociates that variable from its current object and associates it with a new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T030537Z" creationid="Hipter" creationdate="20160706T030537Z">
        <seg>$(P
给类变量赋值，会解除变量与当前对象的关联，并关联到一个新对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays allow indexing not only using integers but also using any other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085816Z" creationid="Hipter" creationdate="20160708T085816Z">
        <seg>$(P
关联数组允许索引不只是整型而是任何类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are a feature that is found in most modern high-level languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092745Z" creationid="Hipter" creationdate="20160708T014736Z">
        <seg>$(P
关联数组是大多数现代高级编程语言所具有的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are implemented in D using a $(I hash table).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023247Z" creationid="Hipter" creationdate="20160708T091112Z">
        <seg>$(P
在D语言中，关联数组是一个 $(I hash 表) 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays make it easy to access the grades by the name of the student as in $(C grades["emre"]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030054Z" creationid="Hipter" creationdate="20160709T092116Z">
        <seg>$(P
在 $(C grades["emre"]) 中通过学生姓名关联数组让它很容易访问到成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assume that an associative array is used for storing student grades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085200Z" creationid="Hipter" creationdate="20160709T085200Z">
        <seg>$(P
假设使用关联数组来存储学生成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assuming that it defines a variable named $(C result) in its implementation, the way that $(C reduce()) works can be described by the following steps:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082153Z" creationid="Heromyth" creationdate="20170826T082153Z">
        <seg>$(P
假设它在执行过程中定义了一个名为 $(C result) 的变量，那 $(C reduce()) 就是按照下面这几步运作的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Atomic operations enable $(I lock-free data structures) as well, which are beyond the scope of this book.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003935Z" creationid="Heromyth" creationdate="20170826T003935Z">
        <seg>$(P
原子操作还能让我们实现$(I 无锁数据结构)，但这已经超出了本书的范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because Unicode adopts the letters of the basic Latin alphabet from the ASCII table, the strings that contain only the letters of the ASCII table will always be ordered correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153844Z" creationid="大处着手小处着眼" creationdate="20160715T035730Z">
        <seg>$(P
由于 Unicode 采用来自于 ASCII 表的基本拉丁字母，仅包含 ASCII 字母的字符串将会正确排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because all of the Unicode characters of "résumé" can be represented by a single $(C wchar) or $(C dchar), the last two lengths are equal to the number of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T143937Z" creationid="大处着手小处着眼" creationdate="20160715T031823Z">
        <seg>$(P
因为所有的“résumé”的 Unicode 字符都能用单个 $(C wchar) 或者 $(C dchar) 表示，所以最后两个的长度与字符个数是一致的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because classes are reference types, defining a new class variable as a copy of another makes two variables that provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012453Z" creationid="Hipter" creationdate="20160706T012143Z">
        <seg>$(P
因为类是引用类型，定义一个新的类变量做为另一个副本，将产生两个访问同一对象的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because each character has a unique code, every letter variant is different from the others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151559Z" creationid="大处着手小处着眼" creationdate="20160715T143244Z">
        <seg>$(P
因为每个字母都有一个唯一的编码，每个字母变体都与其它的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because strings are arrays (and as a corollary, $(I ranges)), the functions of the $(C std.array), $(C std.algorithm), and $(C std.range) modules are very useful with strings as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T124852Z" creationid="大处着手小处着眼" creationdate="20160715T143825Z">
        <seg>$(P
因为字符串是数组(进一步而言，是 $(I range))，所以 $(C std.array)、$(C std.algorithm) 和 $(C std.range) 模块中的函数对于字符串也都非常有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because the consumer is slower than the producer, the memory that the program above uses would grow continuously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134927Z" creationid="Heromyth" creationdate="20170825T134927Z">
        <seg>$(P
因为消费者处理消息的速度远低于生产者产生消息的速度，程序的内存占用会持续增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because this time both $(C synchronized) blocks are connected by the same lock, only one of them is executed at a given time and the result is zero as expected:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001026Z" creationid="Heromyth" creationdate="20170826T001026Z">
        <seg>$(P
这次两个 $(C synchronized) 块使用了同一个锁，因此在同一时间它们当中只有一个可以执行。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Before seeing an example of $(C setMaxMailboxSize()), let's first cause a mailbox to grow continuously.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T023949Z" creationid="Heromyth" creationdate="20170825T134800Z">
        <seg>$(P
在展示 $(C setMaxMailboxSize()) 示例之前，我们先来创建一个消息数量会持续增长的邮箱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Behind the scenes, the parallel algorithms from the $(C std.parallelism) module all use task objects that are elements of a $(C TaskPool) container.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T141926Z" creationid="Heromyth" creationdate="20170826T090201Z">
        <seg>$(P
在这些场景的背后，源自 $(C std.parallelism) 模块的所有并行算法使用的任务对象都是 $(C TaskPool) 容器里的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Being character arrays, strings can contain control characters like $(STRING '\n') as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T092733Z" creationid="Hipter" creationdate="20160711T092733Z">
        <seg>$(P
作为字符数组，字符串能包含像 $(STRING '\n') 这样的控制字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Being so close to hardware, machine code is not suitable for representing higher level concepts like $(I a playing card) or $(I a student record).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004014Z" creationid="Heromyth" creationdate="20170820T004014Z">
        <seg>$(P
由于机器码太靠近硬件，因此它并不适合用于表示 $(I 扑克牌) 或 $(I 学生记录) 等较为高级的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both $(C readf()) and $(C formattedRead()) $(I return) the number of items that they could parse and convert successfully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063405Z" creationid="Hipter" creationdate="20160712T035510Z">
        <seg>$(P
$(C readf()) 和 $(C formattedRead()) 函数 都可以$(I 返回)成功解析及转换的项目个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both of the arrays that we have defined above are fixed-length arrays because their element counts are specified as 5 and 12 at the time when the program is written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033000Z" creationid="大处着手小处着眼" creationdate="20160725T033000Z">
        <seg>$(P
上面我们定义的数组都为定长数组，因为元素的个数在写程序时已指定为 5 和 12。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both of the variables above provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015547Z" creationid="Hipter" creationdate="20160707T015547Z">
        <seg>$(P
上面的两个变量都提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
By the time parallel $(C foreach) ends, all of the operations inside the loop have been completed for all of the elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014626Z" creationid="Heromyth" creationdate="20170826T014626Z">
        <seg>$(P
对每个元素的所有操作完成后，并行的 $(C foreach) 才算完成执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Class objects are constructed by the $(C new) keyword; they do not have names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131126Z" creationid="Heromyth" creationdate="20170819T131126Z">
        <seg>$(P
类对象由关键字 $(C new) 构造；它们没有名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Class types can be defined as $(C synchronized) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001051Z" creationid="Heromyth" creationdate="20170826T001051Z">
        <seg>$(P
类也可以定义为 $(C synchronized)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Class variable and class object are separate concepts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130812Z" creationid="Heromyth" creationdate="20170819T130812Z">
        <seg>$(P
类变量和类对象是独立的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Classes are defined by the $(C class) keyword instead of the $(C struct) keyword:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032013Z" creationid="Hipter" creationdate="20160706T032013Z">
        <seg>$(P
类由 $(C class) 关键字定义而不是 $(C struct) 关键字：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Concurrency is similar to but different from the topic of the previous chapter, parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T005322Z" creationid="Heromyth" creationdate="20170824T011602Z">
        <seg>$(P
并发（concurrency）与上一章的并行（parallelism）很相似，但还是存在较多差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Consequently, when it is only a binary operation that needs to be synchronized, then there is no need for a $(C synchronized) block, which is known to be slow because of needing to acquire a lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003130Z" creationid="Heromyth" creationdate="20170826T003130Z">
        <seg>$(P
如果只是一个二元运算的话，我们没必要使用会影响效率的 $(C synchronized) 块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Conversely, the owner of a worker thread is obtained by the $(C ownerTid()) function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T013900Z" creationid="Heromyth" creationdate="20170824T232630Z">
        <seg>$(P
相应地，使用 $(C ownerTid()) 可以获得工作线程的所有者的 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Copying affects only the variables, not the object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011948Z" creationid="Hipter" creationdate="20160706T011948Z">
        <seg>$(P
复制只影响变量，而不是对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
D supports both models of concurrency: message passing and data sharing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012320Z" creationid="Heromyth" creationdate="20170824T012320Z">
        <seg>$(P
D 语言支持两种并发模型：消息传递和数据共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Data structures that bring elements of a certain type together are called $(I containers).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143201Z" creationid="大处着手小处着眼" creationdate="20160723T141510Z">
        <seg>$(P
聚集特定类型元素的数据结构称为 $(I 容器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Defining dynamic arrays is simpler than defining fixed-length arrays because omitting the length makes a dynamic array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033657Z" creationid="大处着手小处着眼" creationdate="20160725T033657Z">
        <seg>$(P
因为省略了长度，所以定义动态数组比定长数组简单：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Encapsulation is achieved by $(I protection attributes), which we will see in $(LINK2 /ders/d.en/encapsulation.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013433Z" creationid="Heromyth" creationdate="20170819T122633Z">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现的，关于这一点在 $(LINK2 /ders/d.cn/encapsulation.html, 后面章节) 会看到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Every thread has a private mailbox that holds the messages that are sent to that thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134333Z" creationid="Heromyth" creationdate="20170825T134253Z">
        <seg>$(P
每一个线程都有一个用来保存消息的邮箱。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Evidently, the assignment to $(C .length) operates like a function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044343Z" creationid="Heromyth" creationdate="20170906T044343Z">
        <seg>$(P
就像你看到的那样，对 $(C .length) 的赋值就像是调用了一个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Fix the bugs of this program and make it work as expected:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051752Z" creationid="大处着手小处着眼" creationdate="20160726T024805Z">
        <seg>$(P
请修复程序的 bug，让它按预期的方式执行：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Fixed-length arrays are also known as static arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033913Z" creationid="大处着手小处着眼" creationdate="20160725T033844Z">
        <seg>$(P
定长数组也被称为静态数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, although the following two functions have the same signature, the two $(C Task) instantiations that are produced through calls to the $(C task()) function template would have different types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034452Z" creationid="Heromyth" creationdate="20170826T034452Z">
        <seg>$(P
例如，虽然两个函数有相同的函数签名，但两个通过 $(C task()) 函数模版创建的 $(C Task) 示例类型是不同的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, an associative array that maps day names of type $(C string) to day numbers of type $(C int) can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095549Z" creationid="Hipter" creationdate="20160708T095549Z">
        <seg>$(P
例如，下面这个关联数组这样定义，它把日期名的类型 $(C string) 映射到日期的数字类型 $(C int) ：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the following $(C receive()) call specifies two message handlers that handle messages of types $(C int) and $(C string), respectively:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000100Z" creationid="Heromyth" creationdate="20170825T000100Z">
        <seg>$(P
例如，下面这个 $(C receive()) 使用了两个委托分别用来处理类型为 $(C int) 和 $(C string) 的消息：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the following code that tries to capitalize the first letter of a $(C string) would cause a compilation error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T134044Z" creationid="Hipter" creationdate="20160712T082540Z">
        <seg>$(P
例如，下面这段代码尝试着修改 $(C string) 的首字母为大写，这将引发一个编译错误： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the sum of the squares of the elements of an array can be calculated as in the following program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082250Z" creationid="Heromyth" creationdate="20170826T082250Z">
        <seg>$(P
例如，下面这个计算数组元素的平方和的程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, when the following numbers are entered,
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023108Z" creationid="大处着手小处着眼" creationdate="20160726T023000Z">
        <seg>$(P
例如，当输入了下面的数字，
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For more than one block to use the same lock or locks, the lock objects must be specified within the $(C synchronized) parentheses:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T043455Z" creationid="Heromyth" creationdate="20170826T000701Z">
        <seg>$(P
为了能够给多个代码块加上同一个锁，必须在 $(C synchronized) 后加一个圆括号，并在其中指定锁对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For plain arrays, index values are not stored at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T092502Z" creationid="Hipter" creationdate="20160708T092502Z">
        <seg>$(P
对于简单数组，索引值根本就没有存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For reasons like safety and performance, some languages have been designed to be compiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005003Z" creationid="Heromyth" creationdate="20170820T005003Z">
        <seg>$(P
出于对安全及效率等原因的考量，某些语言被设计为可编译的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For that assignment to actually change the area of the rectangle, the two members of the struct must be modified accordingly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053113Z" creationid="Heromyth" creationdate="20170906T053113Z">
        <seg>$(P
改变矩形面积时也要将长和宽修改为对应的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For that syntax to work, a constructor must be defined explicitly by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033504Z" creationid="Hipter" creationdate="20160706T033504Z">
        <seg>$(P
那样的语法要通过编译，就需要程序员显式的定义构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Further, $(C printAsXML()) and the attributes that it considers can be used with other types as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042701Z" creationid="Heromyth" creationdate="20170816T042701Z">
        <seg>$(P
此外，$(C printAsXML()) 和它涉及到的属性还可以与其他类型一起使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Further, as we have seen in $(LINK2 /ders/d.en/function_overloading.html, the Function Overloading chapter), these two functions could even have the same names:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070811Z" creationid="Heromyth" creationdate="20170906T070811Z">
        <seg>$(P
就像我们在 $(LINK2 /ders/d.cn/function_overloading.html, 函数重载) 一章中提到过的，这两个函数可以有相同的名字。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is a program that prints the Turkish names of colors that are specified in English:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133329Z" creationid="Hipter" creationdate="20160709T083500Z">
        <seg>$(P
这是一段打印英文颜色的土耳其语表达的程序，它的键指定为英文：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is another function that tests all three of these statements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035222Z" creationid="Hipter" creationdate="20160707T035222Z">
        <seg>$(P
这儿是另一个函数，来测试全部三个语句：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is the complete program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234706Z" creationid="Heromyth" creationdate="20170824T234706Z">
        <seg>$(P
下面是完整的程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
How can you solve this problem?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092601Z" creationid="Hipter" creationdate="20160709T092601Z">
        <seg>$(P
怎么解决这个问题？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, as we have seen in $(LINK2 /ders/d.en/encapsulation.html, the Encapsulation and Protection Attributes chapter), it is important to restrict direct access to member variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070913Z" creationid="Heromyth" creationdate="20170906T070913Z">
        <seg>$(P
我们曾在 $(LINK2 /ders/d.cn/encapsulation.html, 封装和访问控制) 一章中告诉过你：限制外部代码对成员变量的访问是非常重要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, programming languages adhere to much more strict and formal rules than any spoken language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004212Z" creationid="Heromyth" creationdate="20170820T004212Z">
        <seg>$(P
然而，编程语言依然比口语更严格、正规。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, the other functionality of this property proves that it cannot be a member variable: Assigning a new value to the $(C .length) property actually changes the length of the slice, sometimes by adding new elements to the underlying array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043504Z" creationid="Heromyth" creationdate="20170905T043504Z">
        <seg>$(P
但特性提供了成员变量所不能提供的功能：对 $(C .length) 赋值将会改变分片的真实长度。向数组中添加新元素时就包含这一过程：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, there are important differences between classes and structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123940Z" creationid="Heromyth" creationdate="20170819T123940Z">
        <seg>$(P
然而，类与结构之间有重要的区别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, there are important differences in the way $(C taskPool.reduce()) works.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083646Z" creationid="Heromyth" creationdate="20170826T083646Z">
        <seg>$(P
不过，与之前的函数相比，$(C taskPool.reduce()) 的行为有一个非常重要的不同点。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
I will start using that form after introducing the $(C string) type below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T131706Z" creationid="Hipter" creationdate="20160712T021829Z">
        <seg>$(P
在介绍了下面的 $(C string) 类型之后，我们将开始使用这种格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If $(C std.algorithm.map) were an eager algorithm, the messages about the starts and finishes of the operations would be printed altogether at the top.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074057Z" creationid="Heromyth" creationdate="20170826T074057Z">
        <seg>$(P
如果 $(C std.algorithm.map) 是一个即时取值的算法，那表示操作开始和操作结束的信息应该在程序最开始的时候一下全部显示出来。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If an exception is thrown, the output includes the $(C scope(exit)) and $(C scope(failure)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035711Z" creationid="Hipter" creationdate="20160707T035711Z">
        <seg>$(P
如果抛出异常， 输出包括 $(C scope(exit)) 和 $(C scope(failure)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If no exception is thrown, the output of the function includes only the $(C scope(exit)) and $(C scope(success)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035723Z" creationid="Hipter" creationdate="20160707T035405Z">
        <seg>$(P
如果没有抛出异常， 函数的输出只包括 $(C scope(exit)) 和 $(C scope(success)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If the array sizes are not equal, the program is terminated with an error during assignment:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T020045Z" creationid="大处着手小处着眼" creationdate="20160726T020045Z">
        <seg>$(P
如果数组大小不一致，会导致赋值期间出错而终止程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If the receiver does not have a message handler that matches the type of the priority message, then a $(C PriorityMessageException) is thrown:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135158Z" creationid="Heromyth" creationdate="20170825T135158Z">
        <seg>$(P
如果消息接收者没有能与优先级消息匹配的处理函数，它会抛出一个 $(C PriorityMessageException) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If there is no other class variable that still provides access to the object that has been disassociated from, then that object is going to be destroyed some time in the future by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031054Z" creationid="Hipter" creationdate="20160706T031054Z">
        <seg>$(P
如何没有别的类变量能访问已解除关联对象，那该对象将由垃圾回收器在将来某个时候销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In a loop, the elements of a range are normally processed one after the other, operations of each element following the operations of previous elements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T125249Z" creationid="Heromyth" creationdate="20170826T012942Z">
        <seg>$(P
对于循环，范围中的元素通常是一个一个按顺序被处理的，即上一个循环的操作结束后才会进行下一次循环：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In any case, keep in mind that the use of $(C dchar[]) and $(C dstring) does not solve all of the problems of manipulating Unicode characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T021458Z" creationid="大处着手小处着眼" creationdate="20160714T021458Z">
        <seg>$(P
无论如何，请记住使用 $(C dchar[]) 和 $(C dstring) 并不能解决所有的操作 Unicode 字符的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In fact, $(C parallel()) constructs a new $(C Task) object for every worker thread and starts that task automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T022235Z" creationid="Heromyth" creationdate="20170826T022235Z">
        <seg>$(P
实际上，$(C parallel()) 为每个工作线程构建并自动启动了一个 $(C Task)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In general, classes are very similar to structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123716Z" creationid="Heromyth" creationdate="20170819T123716Z">
        <seg>$(P
一般情况下，类与结构非常相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In most cases $(C yieldForce()) is the most suitable function to call when waiting for a task to complete; it suspends the thread that calls $(C yieldForce()) until the task is completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T150029Z" creationid="Heromyth" creationdate="20170826T045552Z">
        <seg>$(P
在大多数情况下，$(C yieldForce()) 是最适合用来等待任务完成的函数；$(C yieldForce()) 会将调用它的线程挂起，一直到任务完成为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In most cases, the features of the $(C core.atomic) module can be several times faster than using $(C synchronized) blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003914Z" creationid="Heromyth" creationdate="20170826T003914Z">
        <seg>$(P
在大多数情况下 $(C core.atomic) 模块中的功能要比 $(C synchronized) 块执行速度快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In order to avoid making a potentially fully-lazy input range a fully-eager range, it iterates the elements in $(I waves).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T150731Z" creationid="Heromyth" creationdate="20170826T045737Z">
        <seg>$(P
为了防止将输入的可能为延迟取值的范围转换为即时取值的范围，它会以$(I 轮动)的方式迭代这些元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In order to differentiate the variables in the exercise of the previous chapter, we had to append an underscore and a number to their names as in $(C value_1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T021122Z" creationid="大处着手小处着眼" creationdate="20160723T151308Z">
        <seg>$(P
为了与前一章练习中的变量有所区别，我们给变量的名字加上了下划线与数字，像 $(C value_1) 这样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In summary, the definition of an array variable consists of the type of the values, the number of values, and the name of the variable that refers to the array of values:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032617Z" creationid="大处着手小处着眼" creationdate="20160720T031809Z">
        <seg>$(P
总之，数组变量的定义包括值的类型、 值的个数和涉及数组值的变量名称：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In summary, the owner is identified by $(C ownerTid) and the worker is identified by the return value of $(C spawn()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232710Z" creationid="Heromyth" creationdate="20170824T232710Z">
        <seg>$(P
总之，调用 $(C ownerTid) 获取其所有者 ID，通过 $(C spawn()) 的返回值获取工作线程 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the call above, $(C asyncBuf()) makes two elements ready in its buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073206Z" creationid="Heromyth" creationdate="20170826T073206Z">
        <seg>$(P
通过上面 $(C asyncBuf()) 的调用，缓冲区中已经准备好了两个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the case of $(C taskPool.reduce()), the initial values of the results must be specified as a tuple:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085847Z" creationid="Heromyth" creationdate="20170826T085847Z">
        <seg>$(P
如果向 $(C taskPool.reduce()) 传入多个函数，那为其指定的初始值也需要改为元组类型：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the code above, $(C variable2) is being initialized by $(C variable1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T021450Z" creationid="Hipter" creationdate="20160706T021450Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the code above, we expect that the value of $(C i) is incremented before the value of $(C j) is incremented.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012843Z" creationid="Heromyth" creationdate="20170826T012843Z">
        <seg>$(P
对于上面的代码我们认为 $(C i) 将在 $(C j) 之前自增 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the programs that we have written so far we have been assuming that the expressions of a program are executed in a certain order, at least in general line-by-line:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012822Z" creationid="Heromyth" creationdate="20170826T012822Z">
        <seg>$(P
对于之前我们写过的程序，我们都假定程序中的表达式都是按照确定的顺序执行的，或者说至少通常情况下它们是顺序执行的。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the simple programs that we have used above, it was easy to pass the thread ids of owners and workers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135221Z" creationid="Heromyth" creationdate="20170825T135221Z">
        <seg>$(P
之前我们看到的程序都很简单，所以在线程间传递线程 ID 还是比较方便的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is equally wrong to allocate new memory $(I indirectly) from the garbage collector in a destructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002405Z" creationid="Heromyth" creationdate="20170820T002405Z">
        <seg>$(P
在析构函数里 $(I 间接地) 从垃圾回收器里分配新的内存，这种做法同样是错的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is not possible to add elements to fixed-length arrays:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T014134Z" creationid="大处着手小处着眼" creationdate="20160726T014134Z">
        <seg>$(P
不可能给定长数组添加元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is possible but highly unlikely that the result may even end up being "2 and 1" as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235501Z" creationid="Heromyth" creationdate="20170825T235501Z">
        <seg>$(P
当然最终结果也有可能是“2 and 1”，只不过这种情况的可能性比较小而已。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is possible to define variables with the $(C auto) keyword, which we will see in a later chapter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144206Z" creationid="大处着手小处着眼" creationdate="20160715T144206Z">
        <seg>$(P
也可以使用 $(C auto) 关键字定义变量，这个我们将在后面的一章中看到：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is possible to send more than one value as a part of the same message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T015327Z" creationid="Heromyth" creationdate="20170824T233324Z">
        <seg>$(P
也可以在消息中一次发送多个值，这些值都会成为同一消息的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is the responsibility of the programmer to call $(C parallel()) only when the operations applied to each element are independent for each iteration.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014356Z" creationid="Heromyth" creationdate="20170826T014356Z">
        <seg>$(P
只有在确定在每一次迭代中对元素的操作相互独立后，程序员才能调用 $(C parallel()) 来实现并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It may not be easy to chose between regular member functions and properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070833Z" creationid="Heromyth" creationdate="20170906T070833Z">
        <seg>$(P
并没有一种简单的方法能帮你快速在常规成员函数和特性间做出选择。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It may not make sense to wait for messages beyond a certain time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043226Z" creationid="Heromyth" creationdate="20170825T043226Z">
        <seg>$(P
可能经过一段时间后就不再需要继续等待消息了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Just like copying, assignment affects only the variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024635Z" creationid="Hipter" creationdate="20160706T024635Z">
        <seg>$(P
就像复制，赋值只影响变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Key-value pairs can be removed by using $(C .remove()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032137Z">
        <seg>$(P
通过 $(C .remove()) 可以移除键值对：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Lambda functions and objects of types that define the $(C opCall()) member function can also be passed to $(C receive()) as message handlers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000506Z" creationid="Heromyth" creationdate="20170825T000429Z">
        <seg>$(P
lambda 函数和定义了 $(C opCall()) 成员函数的对象都可以传递给 $(C receive()) 作为消息处理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Leaving members like $(C width) and $(C height) open to $(C public) access is acceptable only for very simple types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070947Z" creationid="Heromyth" creationdate="20170906T070947Z">
        <seg>$(P
像 $(C width) 和 $(C height) 简单类型的成员变量，$(C public) 访问权限也是可以接受的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's assume that a third property of this type becomes a requirement, which should provide the area of the rectangle:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044713Z" creationid="Heromyth" creationdate="20170906T044713Z">
        <seg>$(P
现在假设我们需要为这个类型添加一个新特性用于表示这个矩形的面积：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's compare these three algorithms using the $(C Student) example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073817Z" creationid="Heromyth" creationdate="20170826T073817Z">
        <seg>$(P
我们会用 $(C Student) 作为例子来比较个三个算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the following code that we have seen previously in the $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types chapter):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011152Z" creationid="Hipter" creationdate="20160706T011152Z">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the following code that we saw previously in the $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types chapter):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013414Z" creationid="Heromyth" creationdate="20170819T131840Z">
        <seg>$(P
一起来看看下面这段代码，之前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型一章)已见过，如下所示：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the state where $(C i) is 1 and $(C j) is 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235535Z" creationid="Heromyth" creationdate="20170825T235535Z">
        <seg>$(P
先来看下 $(C i) 为 1 $(C j) 为 2 的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's design a function template that prints the values of all members of a $(C struct) object in XML format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103704Z" creationid="Heromyth" creationdate="20170814T103704Z">
        <seg>$(P
一起来设计一个函数模板，让它以XML格式输出一个 $(C struct) 对象的所有成员的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's now revisit the exercise with the five values and write it again by using an array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072509Z" creationid="大处着手小处着眼" creationdate="20160725T072501Z">
        <seg>$(P
现在我们重温一下使用五个值的例子，用数组重写一下它：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's see an example of this in the following program that has two separate code blocks that access the same shared variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000347Z" creationid="Heromyth" creationdate="20170826T000347Z">
        <seg>$(P
下面的例子包含两个独立的访问共享变量的代码块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's use what we have seen so far in a simulation program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234055Z" creationid="Heromyth" creationdate="20170824T234055Z">
        <seg>$(P
现在我们在一个模拟程序里实践一下刚了解到的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Like every variable in D, the elements of arrays are automatically initialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082520Z" creationid="大处着手小处着眼" creationdate="20160725T082520Z">
        <seg>$(P
像在 D 语言中的每个变量，数组的元素自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Like the other parallel algorithms, $(C taskPool.reduce()) executes the functions in parallel by using elements in different tasks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083700Z" creationid="Heromyth" creationdate="20170826T083700Z">
        <seg>$(P
$(C taskPool.reduce()) 在不同的任务中并行执行函数，这与其它的并行算法相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Looking merely at that usage, one might think that $(C .length) has been implemented as a member variable:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043423Z" creationid="Heromyth" creationdate="20170905T043423Z">
        <seg>$(P
如果只看它的语法，你可能会认为 $(C .length) 是一个成员变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Messages can be sent with higher priority than regular messages by $(C prioritySend()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135130Z" creationid="Heromyth" creationdate="20170825T135130Z">
        <seg>$(P
可以使用 $(C prioritySend()) 发送高标准优先级的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Messages of type $(C int) would match $(C intHandler()) and messages of type $(C string) would match $(C stringHandler()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000129Z" creationid="Heromyth" creationdate="20170825T000129Z">
        <seg>$(P
$(C int) 消息匹配 $(C intHandler())，而 $(C string) 消息匹配 $(C stringHandler())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Most CPU architectures use machine code specific to that particular architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003639Z" creationid="Heromyth" creationdate="20170820T003620Z">
        <seg>$(P
大多数 CPU 都使用特定架构的机器码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Multiple attributes can be specified separately or as a parenthesized list of attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042405Z" creationid="Heromyth" creationdate="20170720T042405Z">
        <seg>$(P
多个属性可以分别指定，也可以采用括号列表形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Mutable variables that need to be shared must be defined with the $(C shared) keyword:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233602Z" creationid="Heromyth" creationdate="20170825T233602Z">
        <seg>$(P
需要共享的可变变量必须使用 $(C shared) 关键自定义：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Normally, a program would be executed on one of the cores of the microprocessor, which has been assigned by the operating system to execute the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T132331Z" creationid="Heromyth" creationdate="20170826T012957Z">
        <seg>$(P
正常情况下程序将会在某个操作系统指派的用于运行程序的处理器内核上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Note how the members are made $(C private) so that they can only be accessed by corresponding property functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071008Z" creationid="Heromyth" creationdate="20170906T071008Z">
        <seg>$(P
现在成员变量被封装为 $(C private)，所以只有与之相关联的特性函数可以访问它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Note that since the lifetime of $(C i) is defined by the scope of $(C main()), it is important that $(C main()) does not terminate before the worker thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235056Z" creationid="Heromyth" creationdate="20170825T235056Z">
        <seg>$(P
请注意：$(C i) 的生命期即为 $(C main()) 函数作用域，所以为了防止出现错误应确保 $(C main()) 函数在工作线程终止后才返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Obviously, the values of the elements can be changed later during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083134Z" creationid="大处着手小处着眼" creationdate="20160725T083134Z">
        <seg>$(P
显然，元素的值可以在以后程序执行期间发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other hand, associative arrays do store both the keys and the values of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T093619Z" creationid="Hipter" creationdate="20160708T093619Z">
        <seg>$(P
另一方面，关联数组既存储键又存储元素值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other hand, it may not be necessary to wait for preceding elements to be processed before starting to produce the successive elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073109Z" creationid="Heromyth" creationdate="20170826T073109Z">
        <seg>$(P
但我们并不需要严格的按照顺序等待上一个元素被处理完后才开始计算下一个元素的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other side, the worker receives the message that it needs as an $(C int), uses that value in a calculation, and sends the result as type $(C double) to its owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233236Z" creationid="Heromyth" creationdate="20170824T233236Z">
        <seg>$(P
另一方面，工作线程需要 $(C int) 类型的消息并对其进行计算，之后将计算得到的 $(C double) 类型的结果返回给其所有者：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Once a line is read from the input or from any other source, it is possible to parse and convert separate data that it may contain with $(C formattedRead()) of the $(C std.format) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T142725Z" creationid="Hipter" creationdate="20160712T031338Z">
        <seg>$(P
一但从输入流或其它任何来源中读取了一行字符，就可以用 $(C std.format) 模块的 $(C formattedRead()) 函数来解析并转换它所包含的独立数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One of the reasons why data sharing is not safe is $(I race conditions).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143616Z" creationid="Heromyth" creationdate="20170825T143616Z">
        <seg>$(P
$(I 竞态条件)是数据共享不够安全的原因之一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One thing that the worker can do is to catch the exception explicitly and to send it as a special error message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045106Z" creationid="Heromyth" creationdate="20170825T045106Z">
        <seg>$(P
工作线程能做的就是手动捕获异常并将其作为特殊的错误信息发送给所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One way of achieving that requirement is to define a third member:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044729Z" creationid="Heromyth" creationdate="20170906T044729Z">
        <seg>$(P
一种方法是在矩形结构体中定义第三个成员变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One way of terminating the standard input stream in a terminal is pressing Ctrl-D under Unix-based systems and Ctrl-Z under Windows systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T005431Z" creationid="Hipter" creationdate="20160712T004913Z">
        <seg>$(P
在终端结束标准输入流的方法随系统而不同，在 Unix 系统下按 Ctrl-D，在 Windows 系统下按 Ctrl-Z。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Only the index values between zero and one less than the length of the array are valid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T032531Z" creationid="大处着手小处着眼" creationdate="20160725T022637Z">
        <seg>$(P
只有与数组长度的差值在 0 与 1 之间的索引才有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Operations that are executed in parallel with other operations of a program are called $(I tasks).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142055Z" creationid="Heromyth" creationdate="20170826T022038Z">
        <seg>$(P
程序中以并行的方式执行的操作叫做$(I 任务（task）)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Other than the fact that $(C opAssign) cannot be overloaded for classes, operator overloading is the same as structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005026Z" creationid="Hipter" creationdate="20160707T005026Z">
        <seg>$(P
虽然 $(C opAssign) 不能被类重载，但与结构一样，可以实现运算符重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Parallel $(C amap()) works the same as parallel $(C map()) with two differences:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074736Z" creationid="Heromyth" creationdate="20170826T074736Z">
        <seg>$(P
并行 $(C amap()) 与并行 $(C map()) 作用基本相似，但有以下两点不同：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Parallel $(C reduce()) is faster in many other calculations like the calculation of the math constant $(I pi) (π) by quadrature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084958Z" creationid="Heromyth" creationdate="20170826T084958Z">
        <seg>$(P
不过对于许多算法来说并行 $(C reduce()) 要比其串行版本快，例如计算 $(I pi) （π）的算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Please note the two differences in the new code:
)
$(OL
$(LI The type of the string is $(C dchar[]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020223Z" creationid="大处着手小处着眼" creationdate="20160714T020156Z">
        <seg>$(P
请注意新代码的两个不同：
)
$(OL
$(LI 字符串的类型是 $(C dchar[])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Please see the online documentation of Phobos for the other member functions of $(C Task).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045653Z" creationid="Heromyth" creationdate="20170826T045653Z">
        <seg>$(P
要获得更多有关成 $(C Task) 员函数的信息请参见 Phobos 在线文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Programming languages are designed as efficient ways of programming a CPU, capable of representing higher-level concepts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004037Z" creationid="Heromyth" creationdate="20170820T004037Z">
        <seg>$(P
编程语言的设计目标是用来对 CPU 高效编程，且有能力描述高级概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Properties allow using member functions like member variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043310Z" creationid="Heromyth" creationdate="20170905T043310Z">
        <seg>$(P
特性能让我们使用像访问成员变量一样的语法调用成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Same as structs, the members are accessed by the $(I dot) operator:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002609Z" creationid="Hipter" creationdate="20160707T004024Z">
        <seg>$(P
与结构一样，可以使用 $(I 点) 运算符来访问成员：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similar to the $(C length) property of slices, the properties of user-defined types can be used in assignment operations as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053052Z" creationid="Heromyth" creationdate="20170906T053052Z">
        <seg>$(P
与分片的 $(C length) 特性一样，用户定义的特性也可以用于赋值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly to $(C parallel()), $(C asyncBuf()) iterates $(C InputRange) ranges in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045708Z" creationid="Heromyth" creationdate="20170826T045708Z">
        <seg>$(P
$(C asyncBuf()) 与 $(C parallel()) 相似，都是用来并行迭代 $(C InputRange) 的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, $(C char[]) cannot be used where a $(C string) is needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T030046Z" creationid="Hipter" creationdate="20160713T030046Z">
        <seg>$(P
同样的，$(C char[]) 不能被用到需要 $(C string) 的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, $(C shared static ~this()) is for final operations that must be executed only once per program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T044050Z" creationid="Heromyth" creationdate="20170826T002817Z">
        <seg>$(P
同样地，$(C shared static ~this()) 适用于结束操作——每个程序只会执行一次来释放资源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, an $(C immutable) copy of an object can be provided by a member function appropriately named $(C idup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133836Z" creationid="Heromyth" creationdate="20170819T132306Z">
        <seg>$(P
同样地，可以通过名为 $(C idup()) 的成员函数的提供对象的  $(C immutable) 副本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, an $(C immutable) copy of an object can be provided by a member function appropriately named $(C idup()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024412Z" creationid="Hipter" creationdate="20160706T024412Z">
        <seg>$(P
同样的，可以由命名为 $(C idup()) 的适当的成员函数提供对象的 $(C immutable) 副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since $(C char[]) is mutable and $(C string) is not, there is a mismatch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T024802Z" creationid="Hipter" creationdate="20160713T024802Z">
        <seg>$(P
由于 $(C char[]) 可变而 $(C string) 不可变，两者不批配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since each thread gets its own copy of data, $(C spawn()) does not allow passing references to thread-local variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145059Z" creationid="Heromyth" creationdate="20170825T145059Z">
        <seg>$(P
由于每个线程都有一份单独的数据拷贝，$(C spawn()) 不允许以引用的形式传递线程内的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since it is eager, all of the results are ready by the time $(C amap()) returns:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074905Z" creationid="Heromyth" creationdate="20170826T074905Z">
        <seg>$(P
因为它是即时计算，所以在 $(C amap()) 返回时所有元素都已被运算完成：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since it is more beneficial for you to debug the third mistake yourself, I would like you to first run the program after fixing the previous two bugs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084348Z" creationid="大处着手小处着眼" creationdate="20160726T031903Z">
        <seg>$(P
自行调试第三个错误对你来说更有益，建议你在修复了前两个 bug 之后先运行一下程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since no object gets copied, the postblit function $(C this(this)) is not available for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T013216Z" creationid="Hipter" creationdate="20160706T013139Z">
        <seg>$(P
由于没有复制对象， postblit 函数 $(C this(this)) 不能用于类变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the array does not contain a value for the key $(STRING "purple"), $(C .get()) returns -1:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094942Z" creationid="Hipter" creationdate="20160709T042816Z">
        <seg>$(P
由于键 $(STRING "purple") 的值不在数组中，$(C .get()) 返回 -1：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the objects of $(C myKing) and $(C yourKing) variables are different, the $(C !is) operator returns $(C true).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015100Z" creationid="Hipter" creationdate="20160707T015100Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the students are iterated over in sequence and since the work of each student takes 1 second, the total execution time comes out to be 4 seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013351Z" creationid="Heromyth" creationdate="20170826T013351Z">
        <seg>$(P
如果处理每个学生需要花费 1 秒，那按照顺序迭代学生总共需要花费 4 秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since there are equal number of threads that increment and decrement the same variable equal number of times, one would expect the final value of $(C number) to be zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000557Z" creationid="Heromyth" creationdate="20170826T000557Z">
        <seg>$(P
线程数相同且加减次数相同，可能有人就会认为 $(C number) 的最终结果是 0。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since they are actually arrays, all of the array operations can be applied to strings as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033032Z" creationid="大处着手小处着眼" creationdate="20160715T033032Z">
        <seg>$(P
由于它们实际上是数组，所有数组的操作也都能应用到字符串上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Some languages like Perl, Python and Ruby have been designed to be very flexible and dynamic, making code analysis harder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004655Z" creationid="Heromyth" creationdate="20170820T004655Z">
        <seg>$(P
一些语言被设计得非常灵活与动态，诸如 Perl、Python 和 Ruby，这使得代码分析困难重重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Sometimes it makes sense to use a default value if a key does not exist in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035616Z" creationid="Hipter" creationdate="20160709T035616Z">
        <seg>$(P
有时候在关联数组中，为不存在的键使用一个默认值是有道理的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Sometimes the desired values of the elements are known at the time when the array is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083707Z" creationid="大处着手小处着眼" creationdate="20160725T083707Z">
        <seg>$(P
有时在数组定义时元素的期望值是已知的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Such control characters as well as all whitespace characters at both ends of strings can be removed by $(C std.string.strip):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140053Z" creationid="Hipter" creationdate="20160712T020538Z">
        <seg>$(P
像字符串两端的空白字符这样的控制字符能被 $(C std.string.strip) 移除：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That also happened when reading a value from the input:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083509Z" creationid="大处着手小处着眼" creationdate="20160725T083509Z">
        <seg>$(P
从输入流中读取值时也发生了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That definition of $(C Rectangle) still presents $(C width) and $(C height) as if they are member variable:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071049Z" creationid="Heromyth" creationdate="20170906T071049Z">
        <seg>$(P
$(C Rectangle) 的定义依旧存在 $(C width) 和 $(C height)，它们也依旧表现的像是成员变量。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That expression can be read as $(I the element with the number 0 of the array named values).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T022700Z" creationid="大处着手小处着眼" creationdate="20160724T022700Z">
        <seg>$(P
这个表达式可以理解为 $(I 数组 values 位置 0 处的元素)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That function first modifies the reference parameter and then reverts this modification when an exception is thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022649Z" creationid="Hipter" creationdate="20160707T022649Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That information can be stored in the following $(C Job) struct:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234348Z" creationid="Heromyth" creationdate="20170824T234348Z">
        <seg>$(P
这些信息可以储存在下面这个 $(C Job) 结构中：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That property function enables the struct to be used as if it has a third member variable:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044957Z" creationid="Heromyth" creationdate="20170906T044957Z">
        <seg>$(P
特性函数让我们能像使用成员变量一样使用它：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That solution may be slow especially for large arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T141716Z" creationid="Hipter" creationdate="20160711T012152Z">
        <seg>$(P
对于大型数组这恐怕会非常慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C OwnerTerminated) and $(C LinkTerminated) exceptions can be received as messages as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052517Z" creationid="Heromyth" creationdate="20170825T052517Z">
        <seg>$(P
$(C OwnerTerminated) 和 $(C LinkTerminated) 都可以作为消息在线程间传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C TaskPool) constructor takes the number of threads to use during the parallel operations that are later started through it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T090320Z" creationid="Heromyth" creationdate="20170826T090320Z">
        <seg>$(P
$(C TaskPool) 构造函数有一个参数。通过指定这个参数就可以控制之后并行执行的线程个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C anOperation()) function is started twice in the following program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T022434Z" creationid="Heromyth" creationdate="20170826T022434Z">
        <seg>$(P
在下方的程序中 $(C anOperation()) 函数被调用两次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C calculate()) function below receives $(C string) messages, converts them to $(C double), adds 0.5, and sends the result back as a message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044801Z" creationid="Heromyth" creationdate="20170825T044801Z">
        <seg>$(P
下面这个 $(C calculate()) 接收一个 $(C string) 消息，将其转换为 $(C double) 并加 0.5，之后将运算的结果作为消息传递回去：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C colorAttributeOf()) function template can be implemented as in the following code:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052323Z" creationid="Heromyth" creationdate="20170815T052323Z">
        <seg>$(P
函数模板 $(C colorAttributeOf()) 可以实现成下面的样子：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dayNumbers) variable above is an associative array that can be used as a table that provides a mapping from day names to day numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030402Z" creationid="Hipter" creationdate="20160708T141034Z">
        <seg>$(P
上面的 $(C dayNumbers) 变量是一个关联数组，它能用来作为从日期名映射到日期数字的表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dup()) member function makes a new object by taking advantage of the constructor of $(C Foo) and returns the new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023149Z" creationid="Hipter" creationdate="20160706T023149Z">
        <seg>$(P
$(C dup())  成员函数利用 $(C Foo) 的构造函数，创建并返回新的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C in) operator determines whether a given key exists in the associative array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035220Z" creationid="Hipter" creationdate="20160709T035220Z">
        <seg>$(P
$(C in) 运算符确定一个给定的键是否存在于关联数组中：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C new) keyword constructs an anonymous class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011520Z" creationid="Hipter" creationdate="20160706T011520Z">
        <seg>$(P
 $(C new) 关键字构造了一个匿名的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope(failure)) statement above ensures that the $(C r -= addend) expression will be executed if the function's scope is exited due to an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T033858Z" creationid="Hipter" creationdate="20160707T033858Z">
        <seg>$(P
上面的 $(C scope(failure)) 确保 $(C r -= addend) 表达式在因异常退出时被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope) statements have similar functionality with the $(C catch) and $(C finally) scopes but they are better in many respects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024746Z" creationid="Hipter" creationdate="20160707T024746Z">
        <seg>$(P
$(C scope) 语句与 $(C catch) 和 $(C finally) 有相似功能，但在许多方面表现的更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C setMaxMailboxSize()) call above sets the main thread's mailbox size to 1000.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135011Z" creationid="Heromyth" creationdate="20170825T135011Z">
        <seg>$(P
$(C setMaxMailboxSize()) 将邮箱大小限制为 1000。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C static this()) block above would be executed once for the main thread and once for the worker thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002346Z" creationid="Heromyth" creationdate="20170826T002346Z">
        <seg>$(P
上面这个 $(C static this()) 会为主线程执行一次，为工作线程执行一次：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C strip()) expression above returns a new string that does not contain the trailing control characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160719T150826Z" creationid="Hipter" creationdate="20160712T020830Z">
        <seg>$(P
上面的 $(C strip()) 表达式返回一个不包含尾随控制符的新字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C to!double()) call above would throw an exception if the string cannot be converted to a $(C double) value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044939Z" creationid="Heromyth" creationdate="20170825T044827Z">
        <seg>$(P
如果该字符串不能转换为一个 $(C double) 值，则调用 $(C to!double()) 会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~) operator creates a new array by combining two arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T014946Z" creationid="大处着手小处着眼" creationdate="20160726T014946Z">
        <seg>$(P
 $(C ~) 运算符通过连接两个数组从而创建一个新数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~=) operator adds new elements to the end of a dynamic array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013844Z" creationid="大处着手小处着眼" creationdate="20160726T013844Z">
        <seg>$(P
$(C ~=) 运算符是指在动态数组的尾部添加新的元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~=) operator cannot be used when the left-hand side array is a fixed-length array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015809Z" creationid="大处着手小处着眼" creationdate="20160726T015809Z">
        <seg>$(P
左侧数组是定长数组时 $(C ~=) 运算符不能使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The Enter key that the user presses after the name does not terminate the input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004459Z" creationid="Hipter" creationdate="20160712T004052Z">
        <seg>$(P
用户在名字之后按的 Enter 键并没有结束输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The address of the mutable variable $(C isDone) cannot be passed between threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145201Z" creationid="Heromyth" creationdate="20170825T145201Z">
        <seg>$(P
可变变量 $(C isDone) 的地址无法在线程间传递：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment above makes $(C variable1) leave its object and start providing access to $(C variable2)'s object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031250Z" creationid="Hipter" creationdate="20160706T031250Z">
        <seg>$(P
上面的赋值让 $(C variable1) 离开其对象并且开始提供对 $(C variable2) 的对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment operator copies all of the elements from the right-hand side to the left-hand side:
)
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013149Z" creationid="大处着手小处着眼" creationdate="20160726T013149Z">
        <seg>$(P
赋值运算符将所有元素从右手侧复制到左手侧：
)
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment to $(C .length) above involves more complicated operations than a simple value change: Determining whether the array has capacity for the new length, allocating more memory if not, and moving the existing elements to the new place; and finally initializing each additional element by $(C .init).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044328Z" creationid="Heromyth" creationdate="20170906T044328Z">
        <seg>$(P
对 $(C .length) 赋值并不是简单的改变某个变量，实际上语言在后台做了很多复杂的工作：判断数组是否有足够的空间容纳新的元素，如果没有则在内存中分配更大的空间并将已存在的元素移动到新位置；最后再将添加的新元素以 $(C .init) 的方式初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The atomic operations of D are in the $(C core.atomic) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002921Z" creationid="Heromyth" creationdate="20170826T002921Z">
        <seg>$(P
D 语言中的原子操作都在 $(C core.atomic) 模块里。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The attributes of $(C a) and $(C b) above are of different kinds: The attribute of $(C a) is the type $(C Encrypted) itself, while the attribute of $(C b) is an $(I object) of type $(C Encrypted).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T054610Z" creationid="Heromyth" creationdate="20170803T054610Z">
        <seg>$(P
上面 $(C a) 和 $(C b) 的属性属于不同类别：$(C a) 的属性是 $(C Encrypted) 类型，而 $(C b) 的属性是 $(C Encrypted) 类型的一个$(I 对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The behavior of assignment cannot be changed for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031647Z" creationid="Hipter" creationdate="20160706T031647Z">
        <seg>$(P
赋值操作不能改变类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The benefit of user defined attributes is being able to change the attributes of declarations without needing to change any other part of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042134Z" creationid="Heromyth" creationdate="20170816T042134Z">
        <seg>$(P
自定义属性的好处在于能够更改声明的属性，且不需要更改程序的其他部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The biggest difference from structs is that structs are $(I value types) and classes are $(I reference types).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124110Z" creationid="Heromyth" creationdate="20170819T124110Z">
        <seg>$(P
与结构的最大区别在于结构是 $(I 值类型)  而类是 $(I 引用类型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The chart below demonstrates how the 3-line code inside the $(C for) loop may be executed by each thread over time, from top to bottom, operation 1 being the first operation and operation 6 being the last operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235616Z" creationid="Heromyth" creationdate="20170825T235616Z">
        <seg>$(P
下面这个表格展示了 $(C for) 循环中的 3 行语句是如何执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The compiler may also emit a $(I compilation warning) when it sees a suspicious piece of code that may cause concern but not necessarily an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005224Z" creationid="Heromyth" creationdate="20170820T005224Z">
        <seg>$(P
当编译器看到某段可疑但又不是错误的代码时，会发出 $(I 编译警告)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The complete program has more explanations:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052903Z" creationid="Heromyth" creationdate="20170815T052903Z">
        <seg>$(P
列出整个程序代码更能说明问题：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The concept of compilation and the function of the compiler must also be understood when using $(I compiled) languages like D.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003218Z" creationid="Heromyth" creationdate="20170820T003218Z">
        <seg>$(P
当使用类似 D 语言的 $(I 编译型) 语言时，需要理解编译的概念和编译器的功能。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The correctness of the program requires extra attention when mutable data is shared between threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235147Z" creationid="Heromyth" creationdate="20170825T235147Z">
        <seg>$(P
为了保证程序的正确性，我们需要为那些在线程间共享的可变数据付出额外的精力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The default value of buffer size is 100.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073241Z" creationid="Heromyth" creationdate="20170826T073241Z">
        <seg>$(P
缓冲区的默认大小为 100。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The default value of work unit size is 100 and is suitable for most cases.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T020457Z" creationid="Heromyth" creationdate="20170826T020457Z">
        <seg>$(P
工作单元大小的默认值是 100。在大多数情况下这个大小是合适的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The definition of array variables is very similar to the definition of normal variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022547Z" creationid="大处着手小处着眼" creationdate="20160720T022547Z">
        <seg>$(P
数组变量的定义与正常变量的定义非常相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The details of $(C Variant) are outside of the scope of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043202Z" creationid="Heromyth" creationdate="20170825T043202Z">
        <seg>$(P
有关 $(C Variant) 的详细内容已超出本章范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The distribution of threads to cores has some minimal cost.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T141446Z" creationid="Heromyth" creationdate="20170826T015659Z">
        <seg>$(P
虽然将线程分派给内核的开销极小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The element at index 0 has the value 31 (number of days in January); the element at index 1 has the value of 28 (number of days in February), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T032422Z" creationid="大处着手小处着眼" creationdate="20160725T031328Z">
        <seg>$(P
索引 0 处元素的值为 31（一月的天数）；索引1 处元素的值为 28（二月的天数）依次类推。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The elements are produced and used lazily.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T072831Z" creationid="Heromyth" creationdate="20170826T072831Z">
        <seg>$(P
这些元素都是采用惰性方式生成和使用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The examples in this chapter call $(C Thread.sleep) to slow down threads to demonstrate that they run at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054704Z" creationid="Heromyth" creationdate="20170824T054704Z">
        <seg>$(P
本章中的例子调用 $(C Thread.sleep) 减慢线程执行的速度来更方便的展示线程运行的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The examples in this chapter may look simplistic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143738Z" creationid="Heromyth" creationdate="20170825T143738Z">
        <seg>$(P
本章中的例子看起来都很简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The exceptions that the worker may throw cannot be caught by the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233756Z" creationid="Heromyth" creationdate="20170824T233756Z">
        <seg>$(P
所有者无法捕获由工作线程抛出的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The exclamation mark appears after those characters instead of being printed right after the name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135758Z" creationid="Hipter" creationdate="20160712T015039Z">
        <seg>$(P
感叹号出现在了那些字符之后，而不是在名字之后立即输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The execution time of the program can be measured in a terminal by $(C time):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013327Z" creationid="Heromyth" creationdate="20170826T013327Z">
        <seg>$(P
可以使用终端中的 $(C time) 来测量程序的执行时间。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that $(C std.algorithm.map) operates lazily is very powerful in many programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073526Z" creationid="Heromyth" creationdate="20170826T073526Z">
        <seg>$(P
实际上对很多程序来说，$(C std.algorithm.map) 的延迟取值是非常有用的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that plain arrays provide access to their values through index numbers can be described as an $(I association) of indexes with values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023126Z" creationid="Hipter" creationdate="20160708T084434Z">
        <seg>$(P
事实上简单数组通过索引访问值可以被描述为索引与值的$(I 关联) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that the same initial value is used for all of the tasks, effectively being used in the calculations multiple times, $(C taskPool.reduce()) may calculate a result that is different from what $(C std.algorithm.reduce()) calculates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084000Z" creationid="Heromyth" creationdate="20170826T084000Z">
        <seg>$(P
又由于所有任务都是用相同的初始值，这些初始值会被多次使用，因此 $(C taskPool.reduce()) 的运算结果可能和 $(C std.algorithm.reduce()) 不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that the value of the variable still equals $(C currentValue) when $(C cas()) is operating is an indication that no other thread has mutated the variable since it has last been read by this thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003709Z" creationid="Heromyth" creationdate="20170826T003557Z">
        <seg>$(P
在 $(C cas()) 开始执行时，如果变量的值还是等于 $(C currentValue)，则说明自当前线程读入后这个变量没有被其他线程修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The final values of the results that each task produces are themselves used in the same $(C result) calculation one last time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083756Z" creationid="Heromyth" creationdate="20170826T083756Z">
        <seg>$(P
每个任务都会得到一个结果，这些最终结果将会按照与计算元素相同的方法计算，得到最终的 $(C result)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first line above is the definition of a variable which stores a single value, just like the variables that we have defined so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T023154Z" creationid="大处着手小处着眼" creationdate="20160720T023154Z">
        <seg>$(P
上面的第一行定义了一个存储单个值的变量，就像我们以前定义过的变量那样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first line above removes the key-value pair "Tuesday" / $(C 1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032313Z">
        <seg>$(P
上面第一行移除了键值对 "Tuesday" / $(C 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first parameter of $(C receiveTimeout()) determines how long the message should be waited for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043309Z" creationid="Heromyth" creationdate="20170825T043309Z">
        <seg>$(P
$(C receiveTimeout()) 的第一个参数决定等待消息时要等待多长时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following additional definition of $(C area()) enables using that property in assignment operations and effectively modifying the area of $(C Rectangle) objects:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T054259Z" creationid="Heromyth" creationdate="20170906T053929Z">
        <seg>$(P
在下面示例里，新增 $(C area()) 定义之后，我们可以在赋值中使用该特性，并高效地更改 $(C Rectangle) 对象的面积：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following code makes use of $(C dup()) to create a new object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133505Z" creationid="Hipter" creationdate="20160706T023705Z">
        <seg>$(P
下面的代码利用 $(C dup()) 创建一个新的对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following code shows how the attributes of a specific $(C struct) member (e.g. $(C Person.name)) can be accessed by $(C __traits(getAttributes)):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043714Z" creationid="Heromyth" creationdate="20170804T043714Z">
        <seg>$(P
下面代码展示的是如何使用使用$(C __traits(getAttributes))来访问某个特定 $(C struct) 成员（如 $(C Person.name)）的属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following example calls $(C parallel()) on a local $(C TaskPool) object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091043Z" creationid="Heromyth" creationdate="20170826T091043Z">
        <seg>$(P
下面这个例子使用了一个局部 $(C TaskPool) 对象来调用 $(C parallel())。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following example uses $(C OnCrowding.throwException), which causes a $(C MailboxFull) exception to be thrown when sending a message to a mailbox that is full:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135050Z" creationid="Heromyth" creationdate="20170825T135050Z">
        <seg>$(P
下面这个例子使用了 $(C OnCrowding.throwException)。它将在邮箱满时抛出 $(C MailboxFull) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following functions re-read the current value and call $(C cas()) until the operation succeeds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003831Z" creationid="Heromyth" creationdate="20170826T003831Z">
        <seg>$(P
下面这个函数使用将重新读取当前值并调用 $(C cas()) 直到操作成功。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following is the equivalent of the class definition above:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001144Z" creationid="Heromyth" creationdate="20170826T001144Z">
        <seg>$(P
下面的类和上面的是等价的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following program demonstrates multiple functions with $(C std.algorithm.map).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085251Z" creationid="Heromyth" creationdate="20170826T085251Z">
        <seg>$(P
下面这个例子演示如何向 $(C std.algorithm.map) 传入多个函数并使用其返回的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following program simulates independent robots moving around randomly in a two dimensional space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234125Z" creationid="Heromyth" creationdate="20170824T234125Z">
        <seg>$(P
下面这个程序模拟的是两个互不相关的机器人在二维空间中随机移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following program starts two threads that find each other by their names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135509Z" creationid="Heromyth" creationdate="20170825T135443Z">
        <seg>$(P
下面这个程序启动了两个线程。它们会通过线程名找到对方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following three functions define an interface to an associative array that every thread has access to:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135311Z" creationid="Heromyth" creationdate="20170825T135311Z">
        <seg>$(P
下面这三个函数定义了一个接口。通过这个接口每个线程都可以访问一个关联线程与线程名的数组：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The function may be specified by the $(C =&gt;) syntax as a $(I lambda expression) as we have seen in earlier chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073927Z" creationid="Heromyth" creationdate="20170826T073927Z">
        <seg>$(P
这个函数也可以是由 $(C =&gt;) 语法声明的 $(I lambda 表达式)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The function that enables such an assignment syntax is also named as $(C area) and is also marked by $(C @property).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053826Z" creationid="Heromyth" creationdate="20170906T053658Z">
        <seg>$(P
只需你将函数命名为 $(C area) 并将其标记为 $(C @property)，你就能够使用赋值语法调用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The functions above work correctly without the need for $(C synchronized) blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003902Z" creationid="Heromyth" creationdate="20170826T003902Z">
        <seg>$(P
上面这个程序在不使用 $(C synchronized) 块的情况下也能正确工作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The grades can also be assigned in one go with an array literal:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022153Z" creationid="Hipter" creationdate="20160711T022153Z">
        <seg>$(P
成绩也可以作为数组文本一次性赋值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The high performance of hash tables comes at the expense of storing the elements in an unordered way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131431Z" creationid="Hipter" creationdate="20160708T092120Z">
        <seg>$(P
hash 表的高性能的代价是元素的存储是无序的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The highlighted parts of the code are explained below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103955Z" creationid="Heromyth" creationdate="20170814T103955Z">
        <seg>$(P
下面来解释一下这段代码的高亮部分：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The incorrect program behavior above is due to more than one thread accessing the same mutable data (and at least one of them modifying it).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235901Z" creationid="Heromyth" creationdate="20170825T235901Z">
        <seg>$(P
程序出错的原因是多个线程访问同一块可变数据（并且其中至少有一条线程修改了数据）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The interpreter must read and understand the instructions every time the program is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004509Z" creationid="Heromyth" creationdate="20170820T004509Z">
        <seg>$(P
每一次执行程序之前，解释器都必须重新读入源码并了解它们的含义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The keys of associative arrays can be of any type, including user-defined $(C struct) and $(C class) types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142042Z" creationid="Hipter" creationdate="20160708T141705Z">
        <seg>$(P
关联数组的键可以是任何类型，包括用户定义的 $(C struct) 和 $(C class) 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The length of associative arrays cannot be specified when defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142139Z" creationid="Hipter" creationdate="20160708T142139Z">
        <seg>$(P
定义时，不能指定关联数组的长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The length of such an array can increase or decrease during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033816Z" creationid="大处着手小处着眼" creationdate="20160725T033816Z">
        <seg>$(P
在程序的执行过程中这种数组的长度可以增加或减少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The line above is the equivalent of the following line, with the difference that the $(C +=) operation would be executed without interruptions by other threads (i.e. it would be executed $(I atomically)):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003109Z" creationid="Heromyth" creationdate="20170826T003109Z">
        <seg>$(P
上面这一行和下面这一行功能相同，但原子操作会使 $(C +=) 不被其他线程打断（或者说它们$(I 像原子一样)不可拆分）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The lines of the output may be different at different times depending on how the threads are paused and resumed by the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T231803Z" creationid="Heromyth" creationdate="20170824T231803Z">
        <seg>$(P
程序的输出顺序可能会和上面有所不同，具体情况取决于操作系统对线程的调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The main thread reports the messages that it sends and the messages that it receives:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233258Z" creationid="Heromyth" creationdate="20170824T233258Z">
        <seg>$(P
主线程会将它发送的和接收的消息一起输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The name of a specific day can be accessed by its index in that array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T235015Z" creationid="Hipter" creationdate="20160708T084239Z">
        <seg>$(P
在数组里通过索引访问特定的英文日期名：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The name of this function is the abbreviation of "compare and swap".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003518Z" creationid="Heromyth" creationdate="20170826T003518Z">
        <seg>$(P
这个函数的名字是“比较并交换（compare and swap）”的缩写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The new function takes advantage of the $(C sqrt) function from the $(C std.math) module, which returns the square root of the specified value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070651Z" creationid="Heromyth" creationdate="20170906T070617Z">
        <seg>$(P
新增的特性函数利用 $(C std.math) 模块中的 $(C sqrt) 函数来开平方根。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The number of an element is called its $(I index) and the act of accessing an element is called $(I indexing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T020218Z" creationid="大处着手小处着眼" creationdate="20160725T020218Z">
        <seg>$(P
元素的位置数称为 $(I index)，访问元素的行为称为$(I 索引)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The operating system can pause threads at unpredictable times for unpredictable durations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012545Z" creationid="Heromyth" creationdate="20170824T012545Z">
        <seg>$(P
操作系统会不定期的将线程暂停一段时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The operation above involves three steps: Reading the value of the variable, incrementing the value, and assigning the new value back to the variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054020Z" creationid="Heromyth" creationdate="20170824T054020Z">
        <seg>$(P
上面这个看似简单的操作实际上包含三个步骤：读取变量的值、将其加一、将结果写回变量所在的内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The optional character that is specified after string literals determines the type of the elements of the string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T031212Z" creationid="大处着手小处着眼" creationdate="20160715T020121Z">
        <seg>$(P
在字符串字面量之后指定的可选字符决定了字符串的元素类型：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The optional second parameter of $(C amap()) is the work unit size as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075110Z" creationid="Heromyth" creationdate="20170826T075110Z">
        <seg>$(P
$(C amap()) 的第二个参数也是工作单元大小，也同样是可选的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output indicates that the values 0 and 1 correspond to keys "Monday" and "Tuesday", respectively:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091105Z" creationid="Hipter" creationdate="20160709T024828Z">
        <seg>$(P
下面的输出表明了元素值 0 和 1 分别对应着键 “Monday” 和 “Tuesday”：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of one of the threads is highlighted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055331Z" creationid="Heromyth" creationdate="20170824T055331Z">
        <seg>$(P
其中一个线程的输出被高亮了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program demonstrates that $(C map()) operates lazily; $(C averageGrade()) is called for each result as the $(C foreach) loop iterates:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074012Z" creationid="Heromyth" creationdate="20170826T074012Z">
        <seg>$(P
从程序的输出可以看出 $(C map()) 是延迟取值的；它调用 $(C averageGrade()) 的行为与 $(C foreach) 循环相似：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program in the environment that this chapter has been written is the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013459Z" creationid="Heromyth" creationdate="20170826T013459Z">
        <seg>$(P
在本章编写时使用的环境上运行上面的代码将会输出这样的结果：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program indicates that first the calculations are performed in parallel, and then their results are calculated sequentially.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084046Z" creationid="Heromyth" creationdate="20170826T084046Z">
        <seg>$(P
程序的输出信息表明起初对元素的计算是并行的，而之后对结果的计算是串行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program indicates that the messages are handled by matching functions on the receiver's side:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T021002Z" creationid="Heromyth" creationdate="20170825T000358Z">
        <seg>$(P
程序的输出说明了接收端的函数是如何匹配和处理消息的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program lists all attributes of all members of $(C Person):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T135005Z" creationid="Heromyth" creationdate="20170805T135005Z">
        <seg>$(P
此程序的输出会列出 $(C Person) 的所有成员的所有属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program lists the attributes of $(C Person.name):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T044037Z" creationid="Heromyth" creationdate="20170804T044037Z">
        <seg>$(P
这个程序的输出内容是 $(C Person.name) 的各个属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program should be similar to the following.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143336Z" creationid="Heromyth" creationdate="20170826T034211Z">
        <seg>$(P
程序的输出类似下面这个样子：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program shows that the members have the correct color and that the $(C name) member is encrypted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121614Z" creationid="Heromyth" creationdate="20170815T121507Z">
        <seg>$(P
上面程序的输出内容包含那些拥有正确颜色的成员和被加密过的  $(C name) 成员：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program shows that the uncaught exception that has been thrown by the task does not terminate the entire program right away (it terminates only the task):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T144839Z" creationid="Heromyth" creationdate="20170826T035015Z">
        <seg>$(P
这个程序的输出表明由任务抛出的异常并不会立刻导致整个程序终止运行（它只终止了那个任务）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033423Z" creationid="大处着手小处着眼" creationdate="20160715T033423Z">
        <seg>$(P
输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner above waits for a message for up to 600 milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044510Z" creationid="Heromyth" creationdate="20170825T044510Z">
        <seg>$(P
上面的线程所有者将等待消息 600 毫秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner can catch the exception to do something special like terminating gracefully:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052442Z" creationid="Heromyth" creationdate="20170825T052442Z">
        <seg>$(P
所有者线程可以捕获这个异常并执行某些操作，比如优雅地退出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner in the following program sends its worker a message of type $(C int) and waits for a message from the worker of type $(C double).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T014656Z" creationid="Heromyth" creationdate="20170824T232941Z">
        <seg>$(P
在下面程序里，所有者线程会向工作线程发送 $(C int) 类型的消息，并等待工作线程返回 $(C double) 类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner receives the response for "1.2" as 1.7 but because the worker has been terminated, the owner would be blocked waiting for a message that would never arrive:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045039Z" creationid="Heromyth" creationdate="20170825T045039Z">
        <seg>$(P
由于工作线程已被终止，所有者只会收到将“1.2”变为 1.7 的消息的反馈。而它并不知道工作线程已经终止，所有者线程会被阻塞来等待永远不会到达的消息：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner simply waits for these messages in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234434Z" creationid="Heromyth" creationdate="20170824T234434Z">
        <seg>$(P
线程所有者仅仅通过一个死循环等待消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The parameters that the thread function takes are passed to $(C spawn()) as its second and later arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T002512Z" creationid="Heromyth" creationdate="20170824T055237Z">
        <seg>$(P
线程函数所需的参数可以通过 $(C spawn()) 的第二个及以后面的参数传入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The previous chapter was about threads sharing information through message passing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143338Z" creationid="Heromyth" creationdate="20170825T143338Z">
        <seg>$(P
在上一章中，我们使用消息传递实现线程间的信息共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program automatically waits for all of the threads to finish executing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054954Z" creationid="Heromyth" creationdate="20170824T054954Z">
        <seg>$(P
程序在所有线程执行完毕后才会退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program can now be compiled and will print the modified string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025856Z" creationid="Hipter" creationdate="20160713T025856Z">
        <seg>$(P
现在程序能通过编译并且打印修改后的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program is terminated with an exception:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002254Z" creationid="Heromyth" creationdate="20170820T002254Z">
        <seg>$(P
这个程序会抛一个异常，并中断：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program outputs the sum of 25 and 100, the squares of 5 and 10:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082324Z" creationid="Heromyth" creationdate="20170826T082324Z">
        <seg>$(P
这个程序将输出 5 和 10 的平方的和：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program prints every movement until terminated:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235641Z" creationid="Heromyth" creationdate="20170824T235641Z">
        <seg>$(P
程序会不停地显示所有机器人的运动信息，除非手动终止：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The reason is that, the $(C ==) operator may need to consult the values of the members of the objects and that attempting to access the members through a potentially $(C null) variable would cause a memory access error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130649Z" creationid="Heromyth" creationdate="20170819T130649Z">
        <seg>$(P
原因是，运算符 $(C ==) 会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The reason why the $(C shared) specifiers are necessary is explained in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T023609Z" creationid="Heromyth" creationdate="20170825T051942Z">
        <seg>$(P
下一章会解释为什么此处必须使用 $(C shared) 说明符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The reason why the program works incorrectly can be explained by the following scenario between just two threads that are in a race condition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235512Z" creationid="Heromyth" creationdate="20170825T235512Z">
        <seg>$(P
下面这两个处在竞态条件的线程可以用来解释为什么之前的程序不能得到正确的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The results can also be stored in a $(C RandomAccessRange) that is passed to $(C amap()) as its third parameter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075125Z" creationid="Heromyth" creationdate="20170826T075125Z">
        <seg>$(P
还可以通过 $(C amap()) 的第三个参数传递一个 $(C RandomAccessRange) 进去来储存运算结果：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The return type of $(C thisTid()) is $(C Tid), which has no significance for the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T003240Z" creationid="Heromyth" creationdate="20170824T232512Z">
        <seg>$(P
$(C thisTid()) 返回的类型为 $(C Tid)，它对程序没有意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The return value of $(C spawn()), which I have been ignoring until this point, is the id of the worker thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232612Z" creationid="Heromyth" creationdate="20170824T232612Z">
        <seg>$(P
我们之前一直没有用到的 $(C spawn()) 的返回值即为工作线程的 ID：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The scenario above is just one example that is sufficient to explain the incorrect results of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235828Z" creationid="Heromyth" creationdate="20170825T235828Z">
        <seg>$(P
上面那种情况只是为了解释程序得出错误结果的原因而创建的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The second parameter of $(C map()) has the same meaning as $(C asyncBuf()): It determines the size of the buffer that $(C map()) uses to store the results in.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074631Z" creationid="Heromyth" creationdate="20170826T074631Z">
        <seg>$(P
$(C map()) 的第二个参数与 $(C asyncBuf()) 的第二个参数含义相同：它决定了 $(C map()) 储存结果的缓冲区的大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The second parameter of $(C parallel()) has an overloaded meaning and is ignored in some cases:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014708Z" creationid="Heromyth" creationdate="20170826T014708Z">
        <seg>$(P
$(C parallel()) 的重载为其第二个参数赋予了多个含义，或使其在某些情况下被忽略：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The solution here is to take a copy of the immutable string by using the $(C .dup) property:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T151110Z" creationid="Hipter" creationdate="20160713T025651Z">
        <seg>$(P
此处的解决办法是通过 $(C .dup) property（属性）得到一个不可变字符串的副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The solution to this problem is to define an ordering relation between the objects and to lock them in that order, which is handled automatically by the $(C synchronized) statement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002057Z" creationid="Heromyth" creationdate="20170826T001414Z">
        <seg>$(P
解决方法是为对象定义一个顺序并按照这个顺序锁住对象。如果使用 $(C synchronized) 语句这个过程将被自动实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The syntax of associative arrays is similar to the array syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094902Z" creationid="Hipter" creationdate="20160708T094902Z">
        <seg>$(P
关联数组的语法与数组相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The table grows automatically with each association.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132057Z" creationid="Hipter" creationdate="20160708T145054Z">
        <seg>$(P
随着每次的关联，该表会自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The task function above has been specified as a template parameter to $(C task()) as $(C task!anOperation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034401Z" creationid="Heromyth" creationdate="20170826T034401Z">
        <seg>$(P
上面的任务函数是 $(C task()) 的一个参数模版 $(C task!anOperation) 的实参。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The thread function that moves each robot sends the id of the robot and its movement to the owner thread continuously:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234407Z" creationid="Heromyth" creationdate="20170824T234407Z">
        <seg>$(P
移动机器人的线程会不断地将对应机器人的 ID 和它的移动情况发送给所有者线程：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The two 'e' characters do not replace the two 'é' characters; they replace single code units, resulting in an invalid UTF-8 encoding:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T150159Z" creationid="大处着手小处着眼" creationdate="20160714T015145Z">
        <seg>$(P
两个‘e’字符不能代替两个‘é’字符；用单字节编码单元替换后，结果就是得到一个无效的 UTF-8 编码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The type of the elements of string literals like $(STRING "hello") is $(C char) and each $(C char) value represents a UTF-8 code unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T014126Z" creationid="大处着手小处着眼" creationdate="20160714T013933Z">
        <seg>$(P
像 $(STRING "hello") 这样的字符串字面量的元素类型是 $(C char)，并且每个 $(C char) 值对应一个 UTF-8 编码单元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The type of the values can also be a user-defined type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032844Z" creationid="大处着手小处着眼" creationdate="20160720T032844Z">
        <seg>$(P
值的类型也可以是用户定义的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The value of $(C i) is 5 when the first $(C while) loop terminates, and that value is causing the logical expression of the second loop to be $(C false), which in turn is preventing the second loop to be entered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032634Z" creationid="大处着手小处着眼" creationdate="20160726T032634Z">
        <seg>$(P
当第一个 $(C while) 循环结束时 $(C i) 值为 5，该值导致第二个循环的逻辑表达式的值为 $(C false)，是它阻止进入第二个循环。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The variables of a container are called $(I elements).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143213Z" creationid="大处着手小处着眼" creationdate="20160723T142747Z">
        <seg>$(P
容器的变量称为 $(I 元素)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The worker above terminates after sending two messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052413Z" creationid="Heromyth" creationdate="20170825T052413Z">
        <seg>$(P
发送两条消息后工作线程立刻终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The worker can catch that exception to exit gracefully:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052215Z" creationid="Heromyth" creationdate="20170825T052215Z">
        <seg>$(P
工作线程也可以通过捕获这个异常来优雅地退出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are surprises even when reading strings from the terminal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T094459Z" creationid="Hipter" creationdate="20160711T092623Z">
        <seg>$(P
从终端读字符串您会有一些惊奇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three $(I aliases) of the $(I immutable) versions of those types: $(C string), $(C wstring), and $(C dstring).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T082950Z" creationid="Hipter" creationdate="20160712T081640Z">
        <seg>$(P
这些类型的 $(I immutable) 版本有三个$(I 别名)：$(C string)、$(C wstring) 和 $(C dstring)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three anonymous functions below that are passed to $(C receive()) as message handlers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000621Z" creationid="Heromyth" creationdate="20170825T000621Z">
        <seg>$(P
有 3 个匿名函数被传递给了 $(C receive()) 来作为消息处理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three functions to wait for the completion of a task:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T145219Z" creationid="Heromyth" creationdate="20170826T045437Z">
        <seg>$(P
有三个用来等待任务完成的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three string types that correspond to the three character types: $(C char[]), $(C wchar[]), and $(C dchar[]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160719T145013Z" creationid="Hipter" creationdate="20160712T080418Z">
        <seg>$(P
对应着三种字符类型，分别存在着三种字符串类型：$(C char[])、$(C wchar[]) 和 $(C dchar[])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are two different ways of using $(C remove()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144240Z" creationid="Heromyth" creationdate="20170817T144240Z">
        <seg>$(P
$(C remove()) 的使用方式有以下两种：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are two important points worth stressing here:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023255Z" creationid="大处着手小处着眼" creationdate="20160724T023255Z">
        <seg>$(P
还有两点值得强调：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There can be only one value per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132156Z" creationid="Hipter" creationdate="20160709T025550Z">
        <seg>$(P
每个键有且仅有一个对应值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There is no need for a special lock type in D because any class object can be used as a $(C synchronized) lock.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000857Z" creationid="Heromyth" creationdate="20170826T000857Z">
        <seg>$(P
D 语言中没有专门的锁类型，任何类型都可以作为 $(C synchronized) 锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There is only one copy of such a variable in the entire program and all threads can share that variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233513Z" creationid="Heromyth" creationdate="20170825T233513Z">
        <seg>$(P
这样的话，程序中只会有一 $(C globallyShared)，它会在所有线程间共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These machine code instructions are special numbers, which represent various operations supported by the CPU.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003718Z" creationid="Heromyth" creationdate="20170820T003718Z">
        <seg>$(P
机器码指令都是特定的数字，它们表示 CPU 支持的各种操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These operators operate on class variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013802Z" creationid="Hipter" creationdate="20160707T013802Z">
        <seg>$(P
这些运算符应用在类变量上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These options have different prices, shipping times, shipping costs, customs and other fees, availability at local book stores, etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T042617Z" creationid="Heromyth" creationdate="20170801T042617Z">
        <seg>$(P
以上各个版本受诸多因素影响而存在差异，如价格、运送时间、运送成本、关税与其他费用，以及当地书店是否有售等等
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This chapter covers only some of the features of arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022235Z" creationid="大处着手小处着眼" creationdate="20160720T022235Z">
        <seg>$(P
本章仅涉及数组的部分功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This chapter covers the following range algorithms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124929Z" creationid="Heromyth" creationdate="20170826T012609Z">
        <seg>$(P
本章涉及以下范围（range）算法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This chapter will introduce classes at a high level, underlining the fact that they are reference types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123555Z" creationid="Heromyth" creationdate="20170819T123555Z">
        <seg>$(P
本章将深入介绍类，特别强调一点，类是引用类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This exception can be received as a message as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052456Z" creationid="Heromyth" creationdate="20170825T052456Z">
        <seg>$(P
这个异常也可以被当作消息发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This exception is thrown when receiving a message from the owner if the owner has been terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T023800Z" creationid="Heromyth" creationdate="20170825T052036Z">
        <seg>$(P
如果所有者线程已被终止，工作线程在接收消息时会抛出这个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This feature is closely related to properties because properties are used almost always without parentheses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044639Z" creationid="Heromyth" creationdate="20170906T044639Z">
        <seg>$(P
这个功能与特性很像，因为在使用特性时都不带圆括号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This function applies its template parameter to its two function parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002942Z" creationid="Heromyth" creationdate="20170826T002942Z">
        <seg>$(P
这个函数会将它的模版参数应用到两个函数参数上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This function can also be called simply as $(C parallel()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T133841Z" creationid="Heromyth" creationdate="20170826T013532Z">
        <seg>$(P
此函数可以简单地使用 $(C parallel()) 来调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This is important for controlled modifications of members.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071111Z" creationid="Heromyth" creationdate="20170906T071111Z">
        <seg>$(P
对成员变量的写入控制也是非常重要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This method of defining variables individually does not scale to cases where even more variables are needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T020639Z" creationid="大处着手小处着眼" creationdate="20160720T020639Z">
        <seg>$(P
这种定义个别变量的方法不能扩展到需要更多变量的情况下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This program demonstrates how helpful message passing concurrency can be: Movements of robots are calculated independently by separate threads without knowledge of each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235707Z" creationid="Heromyth" creationdate="20170824T235707Z">
        <seg>$(P
这个程序展现了并发的强大之处：机器人的移动可以在单独的线程中独立计算，而且它们之间无需相互交换信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This simple definition may be misleading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091239Z" creationid="Hipter" creationdate="20160711T091239Z">
        <seg>$(P
这个简单的定义可能是个误导。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the compilation error is due to the combination of two factors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150238Z" creationid="Hipter" creationdate="20160713T023816Z">
        <seg>$(P
这次的编译错误是因为两个因素的联合作用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the exception is caught by the main thread instead of terminating the program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045240Z" creationid="Heromyth" creationdate="20170826T045240Z">
        <seg>$(P
这次异常将会被主线程捕获而不是终止程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the operations are executed in waves of three elements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074549Z" creationid="Heromyth" creationdate="20170826T074549Z">
        <seg>$(P
这次每轮将会对三个元素进行操作：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the reason of the failure is printed by the owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051831Z" creationid="Heromyth" creationdate="20170825T051831Z">
        <seg>$(P
这次错误的原因会被所有者输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This would cause problems for $(C shared) module variables because initializing a variable more than once would be wrong especially in concurrency due to race conditions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002443Z" creationid="Heromyth" creationdate="20170826T002356Z">
        <seg>$(P
对于指定了 $(C shared) 的模块变量来说，重复初始化有可能导致并发中的竞态条件而造成程序出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Threads can detect that the receiver of a message has terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052007Z" creationid="Heromyth" creationdate="20170825T052007Z">
        <seg>$(P
线程可以检测消息的接收者是否已经终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
To see an example of a race condition let's consider multiple threads sharing the same mutable variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235159Z" creationid="Heromyth" creationdate="20170825T235159Z">
        <seg>$(P
下面这个竞态条件的例子就是多个线程共享同一个可变变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
To see an example of this let's use $(C reduce()) with a function that is slowed down again artificially:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T151557Z" creationid="Heromyth" creationdate="20170826T082948Z">
        <seg>$(P
下面来看一个示例，将 $(C reduce()) 与一个人为减慢的函数一起使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
To see how this program is better than the previous one, imagine needing to read 20 values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T134911Z" creationid="大处着手小处着眼" creationdate="20160725T081024Z">
        <seg>$(P
要看一看这个程序怎样才能比以前的更好，让我们设想需要读取 20 个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
To see the effects of $(C asyncBuf()), let's use a range that takes half a second to iterate and half a second to process each element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T072606Z" creationid="Heromyth" creationdate="20170826T072606Z">
        <seg>$(P
为了能突出 $(C asyncBuf()) 的作用，示例中的范围与之前的范围有些不同：遍历一次要耗时半秒，处理一个元素也要耗费半秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Two other $(C __traits) expressions are useful when dealing with user defined attributes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053206Z" creationid="Heromyth" creationdate="20170804T053206Z">
        <seg>$(P
在处理自定义属性时，还有其他两个 $(C __traits) 表达式可以使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unfortunately, marking those blocks individually with $(C synchronized) is not sufficient, because the anonymous locks of the two blocks would be independent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000500Z" creationid="Heromyth" creationdate="20170826T000500Z">
        <seg>$(P
很可惜，直接使用 $(C synchronized) 并不能起到我们预期的效果，因为两个代码块的匿名锁是相互独立的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike an interpreter, the compiler reads and understands the source code only once, during compilation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004834Z" creationid="Heromyth" creationdate="20170820T004834Z">
        <seg>$(P
不像解释器，编译器一次性地在编译期读入和理解源码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike most other programming languages, data is not automatically shared in D; data is thread-local by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T144801Z" creationid="Heromyth" creationdate="20170825T144003Z">
        <seg>$(P
与其他大部分编程语言的不同之处在于，D 语言里的数据不会自动共享（默认情况下，数据仅限于线程本地。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike structs, there is no automatic object construction where the constructor parameters are assigned to members sequentially:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032818Z" creationid="Hipter" creationdate="20160706T032818Z">
        <seg>$(P
不像结构，构造函数参数按顺序分配给成员时，类没有自动构造对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Using the assignment operator is sufficient to build the association between a key and a value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144951Z" creationid="Hipter" creationdate="20160708T144951Z">
        <seg>$(P
使用赋值运算符就足以构建键与值的关联：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Values that are passed as parts of a single message appear as a tuple on the receiver's side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T015551Z" creationid="Heromyth" creationdate="20170824T233401Z">
        <seg>$(P
如果在一次消息中传递多个值的话，接收者会将它们看作一个元组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Violating these rules is undefined behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001909Z" creationid="Heromyth" creationdate="20170820T001909Z">
        <seg>$(P
违反这些规则即会产生未定义行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We are familiar with this feature from slices.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043403Z" creationid="Heromyth" creationdate="20170905T043403Z">
        <seg>$(P
在学习分片（slice）的时候我们已经多次用到它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We can make the following observations about the use of these blocks:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022106Z" creationid="Hipter" creationdate="20160707T022106Z">
        <seg>$(P
对于这些块的用法，我们可以作以下观测：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have already seen that $(C static this()) can be used for initializing modules, including their variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002318Z" creationid="Heromyth" creationdate="20170826T002318Z">
        <seg>$(P
我们已经见到过 $(C static this())，它是用来初始化模块和模块中包含的变量的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have defined five variables in one of the exercises of the last chapter, and used them in certain calculations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T043538Z" creationid="大处着手小处着眼" creationdate="20160716T144940Z">
        <seg>$(P
在上一章的一个练习中我们定义过五个变量，并用它们做过特定计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen above how $(C Rectangle) can be used as if it has a third member variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070740Z" creationid="Heromyth" creationdate="20170906T070740Z">
        <seg>$(P
之前我们通过定义特性为 $(C Rectangle) 添加了“第三个变量”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen earlier in the $(LINK2 /ders/d.en/foreach_opapply.html, $(C foreach) for structs and classes chapter) that the expressions that are in $(C foreach) blocks are passed to $(C opApply()) member functions as delegates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013733Z" creationid="Heromyth" creationdate="20170826T013733Z">
        <seg>$(P
在之前 $(LINK2 /ders/d.cn/foreach_opapply.html, $(C foreach) 结构体和类) 一章中我们了解到： $(C foreach)  块中的表达式将会被包装成委托传递给对象的 $(C opApply()) 成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that single quotes are used to define character literals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005300Z" creationid="Hipter" creationdate="20160712T075903Z">
        <seg>$(P
我们已经看到单引号用于定义字符字面量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that some Unicode characters are represented by more than one byte.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T011246Z" creationid="大处着手小处着眼" creationdate="20160714T011246Z">
        <seg>$(P
我们已经知道一些 Unicode 字符串由多个字节表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that the two tools that are used most in D programming are $(I the text editor) and $(I the compiler).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003058Z" creationid="Heromyth" creationdate="20170820T003058Z">
        <seg>$(P
用 D 编程时经常会用到两个工具，它们分别是 $(I 文本编辑器) 和 $(I 编译器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have used comparison operators $(C &lt;), $(C &gt;=), etc. with integer and floating point values before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T034612Z" creationid="大处着手小处着眼" creationdate="20160715T034612Z">
        <seg>$(P
我们以前把比较运算符 $(C &lt;)，$(C &gt;=) 等等用于整型和浮点数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have used strings in many programs that we have seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T090616Z" creationid="Hipter" creationdate="20160711T090616Z">
        <seg>$(P
迄今为至，我们已经看到，好多程序都用到了字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We may think of defining the variable as a $(C char[]) instead of the $(C string) alias but that cannot be compiled either:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150152Z" creationid="Hipter" creationdate="20160713T023409Z">
        <seg>$(P
我们可能想到把变量定义为 $(C char[]) 而不是别名 $(C string)，但这也不能通过编译：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We saw in the $(LINK2 /ders/d.en/arrays.html, Arrays chapter) that plain arrays are containers that store their elements side-by-side and provide access to them by index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T151814Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/arrays.html, 数组) 一章中我们已经看到简单数组作为容器逐个存储元素，按索引访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We will see below that this exception can be received as a message as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052231Z" creationid="Heromyth" creationdate="20170825T052231Z">
        <seg>$(P
之后我们会看到也可以将这个异常当作消息发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When $(C parallel()) works on the results of $(C asyncBuf()) or $(C map()), it ignores the work unit size parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T021751Z" creationid="Heromyth" creationdate="20170826T021751Z">
        <seg>$(P
若使用 $(C parallel()) 处理 $(C asyncBuf()) 或 $(C map()) 的返回值时，它将忽略工作单元大小参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When blocks of code need to be synchronized on more than one object, those objects must be specified together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001155Z" creationid="Heromyth" creationdate="20170826T001155Z">
        <seg>$(P
如果几块代码需要锁住多个对象来同步，指定在一个 $(C synchronized) 中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When dealing with letters, symbols, and other Unicode characters directly, as in the code above, the correct type to use is $(C dchar):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020029Z" creationid="大处着手小处着眼" creationdate="20160714T015921Z">
        <seg>$(P
当直接处理字母、符号或其它 Unicode 字符的时候，比如在上面代码中，应该使用正确的类型 $(C dchar)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When initializing arrays, it is possible to use a single value on the right-hand side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011926Z" creationid="大处着手小处着眼" creationdate="20160726T011926Z">
        <seg>$(P
当初始化数组时，也可以在右手侧使用单个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When it is needed to synchronize more than one block of code, it is possible to specify one or more locks with the $(C synchronized) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000322Z" creationid="Heromyth" creationdate="20170826T000322Z">
        <seg>$(P
当需要 synchronize 多个代码块时，最好是使用多个 $(C synchronized) 关键字指定多个锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When it later makes sense that a member variable should be allowed to be modified from the outside, then it is simply a matter of defining another property function for that member.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071133Z" creationid="Heromyth" creationdate="20170906T071133Z">
        <seg>$(P
如果将来的某一天这个成员变量需要在外部修改，那我们仅需为其添加一个特性函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the actual object needs to be copied, the class must have a member function for that purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022112Z" creationid="Hipter" creationdate="20160706T021806Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the compile-time evaluations are completed, the $(C printAsXML()) function template would be instantiated for the $(C Person) type as the equivalent of the following function:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052641Z" creationid="Heromyth" creationdate="20170815T052641Z">
        <seg>$(P
当编译时计算完成时，函数模板 $(C printAsXML()) 会根据 $(C Person) 类型实例化，并与下面这个函数相似：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the function is specified by the $(C =&gt;) syntax as in the program above, the first parameter (here $(C a)) represents the current value of the result (initialized by the parameter $(C 0) above) and the second parameter (here $(C b)) represents the current element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082303Z" creationid="Heromyth" creationdate="20170826T082303Z">
        <seg>$(P
如果传入的函数是以 $(C =&gt;) 声明的，那它的第一个参数（即上方程序中的 $(C a)）代表当前运算结果（使用 reduce 的参数 $(C 0) 初始化），第二个参数（即上方程序中的 $(C b)）代表当前元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the input cannot be converted to $(C name) and $(C age), the program prints an error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144631Z" creationid="Hipter" creationdate="20160712T075010Z">
        <seg>$(P
当输入不能转换到 $(C name) 和 $(C age) 时，程序将打印一个错误：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the length of an array is specified when the program is written, that array is a $(I fixed-length array).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T085322Z" creationid="大处着手小处着眼" creationdate="20160725T032037Z">
        <seg>$(P
当数组的长度是在写程序时指定时，该数组就是一个$(I 定长数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the type of $(C s) is $(C char[]), the type of the expression on the right-hand side of the assignment above is $(C char[]) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T000923Z" creationid="Hipter" creationdate="20160713T032929Z">
        <seg>$(P
当 $(C s) 的类型是 $(C char[])，上面右手侧赋值的表达式类型也是 $(C char[])，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the value of $(C monthIndex) is 2, the expression above would print the value of $(C monthDays[2]), the number of days in March.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021903Z" creationid="大处着手小处着眼" creationdate="20160725T021903Z">
        <seg>$(P
当 $(C monthIndex) 的值为 2，上面的表达式将输出 $(C monthDays[2]) 的值，即三月的天数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the variables provide access to the same object, $(C is) returns $(C true):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015456Z" creationid="Hipter" creationdate="20160707T015456Z">
        <seg>$(P
当变量提供对同一对象的访问时，$(C is) 返回 $(C true)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When there is no property function that modifies a member variable, then that member is effectively read-only from the outside:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071101Z" creationid="Heromyth" creationdate="20170906T071101Z">
        <seg>$(P
如果成员变量没有写特性，那在对象外部看来它将是只读的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
You may also want to investigate the $(C core.sync) package, which contains classic concurrency primitives in the following modules:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004732Z" creationid="Heromyth" creationdate="20170826T004216Z">
        <seg>$(P
你也可以深入看看 $(C core.sync) 包中，在它的以下模块中包含了很多经典的并发基本操作：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
You may find the $(C indexOf()) and $(C lastIndexOf()) functions useful to get the two indexes needed to produce a slice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154350Z" creationid="大处着手小处着眼" creationdate="20160715T144100Z">
        <seg>$(P
你或许会发现 $(C indexOf()) 和 $(C lastIndexOf()) 函数对生成切片所需要的两个索引很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
have the program print the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023131Z" creationid="大处着手小处着眼" creationdate="20160726T023131Z">
        <seg>$(P
程序会输出以下内容：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T021046Z" creationid="Hipter" creationdate="20160708T021046Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的一章) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020733Z" creationid="Hipter" creationdate="20160708T020733Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章) 中我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035217Z" creationid="Hipter" creationdate="20160708T035045Z">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 而类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034510Z" creationid="Hipter" creationdate="20160708T034510Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104213Z" creationid="Hipter" creationdate="20160707T104213Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
原因是， $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104345Z" creationid="Hipter" creationdate="20160707T104345Z">
        <seg>$(P
原因是 $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035630Z" creationid="Hipter" creationdate="20160708T035630Z">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I 对象)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, The $(CH4 null) 值和 $(CH4 is) 运算符章节)， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020020Z" creationid="Hipter" creationdate="20160708T020020Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, $(CH4 null) 值和 $(CH4 is) 运算符一章) 中， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104919Z" creationid="Hipter" creationdate="20160707T104919Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的章节) 将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034923Z" creationid="Hipter" creationdate="20160708T015803Z">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的一章) 中将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T103944Z" creationid="Hipter" creationdate="20160707T103944Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
我们将在后面看到 $(LINK2 /ders/d.cn/memory.html, 内存管理章节)，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020446Z" creationid="Hipter" creationdate="20160708T020446Z">
        <seg>$(P
我们将在后面 $(LINK2 /ders/d.cn/memory.html, 内存管理一章) 中看到，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041227Z" creationid="Hipter" creationdate="20160708T041227Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造， 它们仍是两个单独的对象。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020547Z" creationid="Hipter" creationdate="20160708T020547Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承一章) 中我们将看到相关内容。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020154Z" creationid="Hipter" creationdate="20160708T020154Z">
        <seg>$(P
让我们考虑一下下面的我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型一章) 中看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(B Observations:) The value of $(C counter) determines how many times the loops are repeated (iterated).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T074518Z" creationid="大处着手小处着眼" creationdate="20160725T074518Z">
        <seg>$(P $(B 观测：) $(C counter) 的值决定了循环的重复次数（迭代）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(I $(B Note:) As you would remember from $(LINK2 /ders/d.en/const_member_functions.html, the $(CH4 const ref) Parameters and $(CH4 const) Member Functions chapter), the $(C const) specifier on the function declaration ensures that the object is not modified by this function.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044943Z" creationid="Heromyth" creationdate="20170906T044943Z">
        <seg>$(P $(I $(B 注意：) 如果你还记得我们在 $(LINK2 /ders/d.cn/const_member_functions.html, $(CH4 const ref) 参数和 $(CH4 const) 成员函数) 一章中所讲的，函数声明中的 $(C const) 说明符表示函数不会修改其对象。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(I $(B Note:) The $(C .length) property of fixed-length arrays cannot be modified.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043616Z" creationid="Heromyth" creationdate="20170905T043616Z">
        <seg>$(P $(I $(B 注意：) 无法修改定长数组的 $(C .length) 特性。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(LINK2 /ders/d.en/ix.html, $(B The Index Section)) (useful for keyword searches))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052832Z" creationid="Heromyth" creationdate="20170801T052832Z">
        <seg>$(P $(LINK2 /ders/d.en/ix.html, $(B 索引)) （可以使用关键字搜索）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Browse the documentations of the $(C std.string), $(C std.array), $(C std.algorithm), and $(C std.range) modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T083116Z" creationid="大处着手小处着眼" creationdate="20160715T143846Z">
        <seg>$(PROBLEM
浏览 $(C std.string)、$(C std.array)、$(C std.algorithm) 和 $(C std.range) 模块的文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
How can all of the key-value pairs of an associative array be removed other than calling $(C .clear)?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094612Z" creationid="Hipter" creationdate="20160709T083844Z">
        <seg>$(PROBLEM
除 $(C .clear) 函数外还有什么方法能移除关联数组的全部键值对？ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Just like with arrays, there can be only one value for each key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085009Z" creationid="Hipter" creationdate="20160709T085009Z">
        <seg>$(PROBLEM
与数组一样，每个键有且仅有一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Read a line from the input and print the part between the first and last 'e' letters of the line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144015Z" creationid="大处着手小处着眼" creationdate="20160715T144015Z">
        <seg>$(PROBLEM
从输入中读取一行并打印该行的第一个和最后一个‘e’字母之间的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
The following is a program that does not work as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024119Z" creationid="大处着手小处着眼" creationdate="20160726T024119Z">
        <seg>$(PROBLEM
以下为预期不起作用的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that asks the user how many values will be entered and then reads all of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T022157Z" creationid="大处着手小处着眼" creationdate="20160726T022157Z">
        <seg>$(PROBLEM
编写一个程序，要求用户输入多少值，然后全部读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that makes use of the $(C ~) operator: The user enters the first name and the last name, all in lowercase letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154258Z" creationid="大处着手小处着眼" creationdate="20160715T143917Z">
        <seg>$(PROBLEM
写一个使用 $(C ~) 运算符的程序：让用户都以小写键入英文名字和姓氏，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that reads numbers from the input, and prints the odd and even ones separately but in order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051538Z" creationid="大处着手小处着眼" creationdate="20160726T022628Z">
        <seg>$(PROBLEM
编写一个程序，从输入流中读取数字，并先后按顺序分别输出奇数和偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 0
Finished working on student 0
85                   $(SHELL_NOTE calculated as foreach iterates)
Started working on student 1
Finished working on student 1
86
...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074030Z" creationid="Heromyth" creationdate="20170826T074030Z">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 0
Finished working on student 0
85                   $(SHELL_NOTE 像 foreach 一样迭代元素)
Started working on student 1
Finished working on student 1
86
...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 1    $(SHELL_NOTE all are executed up front)
Started working on student 0
Started working on student 2
Started working on student 3
Finished working on student 1
Started working on student 4
Finished working on student 2
Finished working on student 3
Started working on student 6
Finished working on student 0
Started working on student 7
Started working on student 5
Finished working on student 4
Started working on student 8
Finished working on student 6
Started working on student 9
Finished working on student 7
Finished working on student 5
Finished working on student 8
Finished working on student 9
85
86
87
88
89
90
91
92
93
94</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074935Z" creationid="Heromyth" creationdate="20170826T074935Z">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 1    $(SHELL_NOTE 所有元素已被提前准备好)
Started working on student 0
Started working on student 2
Started working on student 3
Finished working on student 1
Started working on student 4
Finished working on student 2
Finished working on student 3
Started working on student 6
Finished working on student 0
Started working on student 7
Started working on student 5
Finished working on student 4
Started working on student 8
Finished working on student 6
Started working on student 9
Finished working on student 7
Finished working on student 5
Finished working on student 8
Finished working on student 9
85
86
87
88
89
90
91
92
93
94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 1  $(SHELL_NOTE in parallel)
Started working on student 2  $(SHELL_NOTE but in unpredictable order)
Started working on student 0
Finished working on student 1
Finished working on student 2
Finished working on student 0
85
86
87
Started working on student 4
Started working on student 5
Started working on student 3
Finished working on student 4
Finished working on student 3
Finished working on student 5
88
89
90
Started working on student 7
Started working on student 8
Started working on student 6
Finished working on student 7
Finished working on student 6
Finished working on student 8
91
92
93
Started working on student 9
Finished working on student 9
94</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074610Z" creationid="Heromyth" creationdate="20170826T074610Z">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
Started working on student 1  $(SHELL_NOTE 并行)
Started working on student 2  $(SHELL_NOTE 但是顺序不确定)
Started working on student 0
Finished working on student 1
Finished working on student 2
Finished working on student 0
85
86
87
Started working on student 4
Started working on student 5
Started working on student 3
Finished working on student 4
Finished working on student 3
Finished working on student 5
88
89
90
Started working on student 7
Started working on student 8
Started working on student 6
Finished working on student 7
Finished working on student 6
Finished working on student 8
91
92
93
Started working on student 9
Finished working on student 9
94</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
started  - element: 3, result: 0 $(SHELL_NOTE first, the tasks in parallel)
started  - element: 2, result: 0
started  - element: 1, result: 0
started  - element: 4, result: 0
finished - element: 3, result: 3
finished - element: 1, result: 1
$(HILITE started  - element: 1, result: 0) $(SHELL_NOTE then, their results sequentially)
finished - element: 4, result: 4
finished - element: 2, result: 2
$(HILITE finished - element: 1, result: 1)
$(HILITE started  - element: 2, result: 1)
$(HILITE finished - element: 2, result: 3)
$(HILITE started  - element: 3, result: 3)
$(HILITE finished - element: 3, result: 6)
$(HILITE started  - element: 4, result: 6)
$(HILITE finished - element: 4, result: 10)
Result: 10</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084823Z" creationid="Heromyth" creationdate="20170826T084823Z">
        <seg>$(SHELL
$ time ./deneme
$(SHELL_OBSERVED
started  - element: 3, result: 0 $(SHELL_NOTE 首先，使用任务并行计算)
started  - element: 2, result: 0
started  - element: 1, result: 0
started  - element: 4, result: 0
finished - element: 3, result: 3
finished - element: 1, result: 1
$(HILITE started  - element: 1, result: 0) $(SHELL_NOTE 接着，顺序计算结果)
finished - element: 4, result: 4
finished - element: 2, result: 2
$(HILITE finished - element: 1, result: 1)
$(HILITE started  - element: 2, result: 1)
$(HILITE finished - element: 2, result: 3)
$(HILITE started  - element: 3, result: 3)
$(HILITE finished - element: 3, result: 6)
$(HILITE started  - element: 4, result: 6)
$(HILITE finished - element: 4, result: 10)
Result: 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Before: résumé
After : re�sueé    $(SHELL_NOTE_WRONG INCORRECT)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T015218Z" creationid="大处着手小处着眼" creationdate="20160714T015218Z">
        <seg>$(SHELL
Before: résumé
After : re�sueé    $(SHELL_NOTE_WRONG 不正确)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Final value: -672    $(SHELL_NOTE_WRONG not zero)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000645Z" creationid="Heromyth" creationdate="20170826T000645Z">
        <seg>$(SHELL
Final value: -672    $(SHELL_NOTE_WRONG 不是 0)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Final value: 0       $(SHELL_NOTE correct result)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001034Z" creationid="Heromyth" creationdate="20170826T001034Z">
        <seg>$(SHELL
Final value: 0       $(SHELL_NOTE 正确结果)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Initializing per-program variable at 6B0120    $(SHELL_NOTE only once)
Initializing per-thread variable at 7FBDB36557D0
Initializing per-thread variable at 7FBDB3554670
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002703Z" creationid="Heromyth" creationdate="20170826T002703Z">
        <seg>$(SHELL
Initializing per-program variable at 6B0120    $(SHELL_NOTE 只有一次)
Initializing per-thread variable at 7FBDB36557D0
Initializing per-thread variable at 7FBDB3554670
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Owner : Tid(std.concurrency.MessageBox)
Worker: Tid(std.concurrency.MessageBox)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T003557Z" creationid="Heromyth" creationdate="20170827T003557Z">
        <seg>$(SHELL
Owner : Tid(22310e53100)
Worker: Tid(22310e53000)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
There are 4 cores on this system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T132855Z" creationid="Heromyth" creationdate="20170826T013521Z">
        <seg>$(SHELL
此系统里有 4 个内核。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 1    $(SHELL_NOTE_WRONG incorrect result)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235442Z" creationid="Heromyth" creationdate="20170825T235442Z">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 1    $(SHELL_NOTE_WRONG 错误结果)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 2      $(SHELL_NOTE correct result)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000008Z" creationid="Heromyth" creationdate="20170826T000008Z">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 2      $(SHELL_NOTE 正确结果)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 2    $(SHELL_NOTE expected result)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235419Z" creationid="Heromyth" creationdate="20170825T235357Z">
        <seg>$(SHELL
before: 1 and 2
after : 1 and 2    $(SHELL_NOTE 期望的结果)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
before: 1 and 2
after : 2 and 2    $(SHELL_NOTE_WRONG incorrect result)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235449Z" creationid="Heromyth" creationdate="20170825T235449Z">
        <seg>$(SHELL
before: 1 and 2
after : 2 and 2    $(SHELL_NOTE_WRONG 错误结果)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
main is continuing
mayThrow() is started
mayThrow() is throwing an exception                 $(SHELL_NOTE thrown)
main is waiting for the task
Detected an error in the task: 'Error message'      $(SHELL_NOTE caught)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045302Z" creationid="Heromyth" creationdate="20170826T045302Z">
        <seg>$(SHELL
main is continuing
mayThrow() is started
mayThrow() is throwing an exception                 $(SHELL_NOTE 抛出)
main is waiting for the task
Detected an error in the task: 'Error message'      $(SHELL_NOTE 捕获)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
main is continuing
mayThrow() is started
mayThrow() is throwing an exception                 $(SHELL_NOTE thrown)
main is waiting for the task
object.Exception@deneme.d(10): Error message        $(SHELL_NOTE terminated)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T035030Z" creationid="Heromyth" creationdate="20170826T035030Z">
        <seg>$(SHELL
main is continuing
mayThrow() is started
mayThrow() is throwing an exception                 $(SHELL_NOTE 抛出)
main is waiting for the task
object.Exception@deneme.d(10): Error message        $(SHELL_NOTE 终止)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE (Let's assume that Enter is pressed a second time here))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135416Z" creationid="Hipter" creationdate="20160712T004651Z">
        <seg>$(SHELL_NOTE （让我们假设在这儿第二次按了 Enter 键）)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE The input is not terminated although Enter has been pressed)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144927Z" creationid="Hipter" creationdate="20160712T004632Z">
        <seg>$(SHELL_NOTE 虽然按了 Enter 键，但输入没有中断)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE no new-line character)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140423Z" creationid="Hipter" creationdate="20160712T021122Z">
        <seg>$(SHELL_NOTE 没有换行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE waiting for a message that will never arrive)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045053Z" creationid="Heromyth" creationdate="20170825T045053Z">
        <seg>$(SHELL_NOTE 等待永远不会到达的消息)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG (one more before the exclamation mark))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135551Z" creationid="Hipter" creationdate="20160712T014834Z">
        <seg>$(SHELL_NOTE_WRONG （在感叹号前还有一个）)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character after the name)
!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135540Z" creationid="Hipter" creationdate="20160712T014717Z">
        <seg>$(SHELL_NOTE_WRONG 名字之后的换行符)
!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character before the exclamation mark)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135845Z" creationid="Hipter" creationdate="20160712T020346Z">
        <seg>$(SHELL_NOTE_WRONG 感叹号前有换行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(STRING 'a') is a character; $(STRING "a") is a string that contains a single character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T080044Z" creationid="Hipter" creationdate="20160712T080044Z">
        <seg>$(STRING 'a') 是一个字符；$(STRING "a") 是一个包含单字符的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(C scope(exit)): the expression is always executed when exiting the scope, regardless of whether successfully or due to an exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025349Z" creationid="Hipter" creationdate="20160707T025349Z">
        <seg>$(UL
$(LI $(C scope(exit))：表达式总是在退出作用域时被执行， 无论是否成功或出现异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(LINK2 $(ROOT_DIR)/ders/d/, $(IMG bullet_black.png) This book in Turkish))
$(LI $(LINK2 mailto:acehreli@yahoo.com, $(IMG bullet_black.png) Contact))
$(BR)
$(LI $(LINK2 $(ROOT_DIR)/copyright.html, $(IMG cc_80x15.png) Rights))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060209Z" creationid="Heromyth" creationdate="20170718T105411Z">
        <seg>$(UL
$(LI $(LINK2 $(ROOT_DIR)/ders/d/, $(IMG bullet_black.png) 土耳其语版))
$(LI $(LINK2 mailto:acehreli@yahoo.com, $(IMG bullet_black.png) 联系方式))
$(BR)
$(LI $(LINK2 $(ROOT_DIR)/copyright.html, $(IMG cc_80x15.png) 版权))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(LINK2 /ders/d.en/struct.html, Structs))
$(LI $(LINK2 /ders/d.en/member_functions.html, Member Functions))
$(LI $(LINK2 /ders/d.en/const_member_functions.html, $(CH4 const ref) Parameters and $(CH4 const) Member Functions))
$(LI $(LINK2 /ders/d.en/special_functions.html, Constructor and Other Special Functions))
$(LI $(LINK2 /ders/d.en/operator_overloading.html, Operator Overloading))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013521Z" creationid="Heromyth" creationdate="20170819T123920Z">
        <seg>$(UL
$(LI $(LINK2 /ders/d.cn/struct.html, 结构))
$(LI $(LINK2 /ders/d.cn/member_functions.html, 成员函数))
$(LI $(LINK2 /ders/d.cn/const_member_functions.html, $(CH4 const ref) 参数和 $(CH4 const) 成员函数))
$(LI $(LINK2 /ders/d.cn/special_functions.html, 构造函数和其它特殊函数))
$(LI $(LINK2 /ders/d.cn/operator_overloading.html, 运算符重载))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(WORK_IN_PROCESS
$(LI $(LINK2 /ders/d.en/foreword1.html, Foreword by Walter Bright))
)
$(LI $(LINK2 /ders/d.en/foreword2.html, Foreword by Andrei Alexandrescu))
$(LI $(LINK2 /ders/d.en/preface.html, Preface))
$(LI $(LINK2 /ders/d.en/hello_world.html, The Hello World Program) $(INDEX_KEYWORDS main))
$(LI $(LINK2 /ders/d.en/writeln.html, writeln and write))
$(LI $(LINK2 /ders/d.en/compiler.html, Compilation))
$(LI $(LINK2 /ders/d.en/types.html, Fundamental Types) $(INDEX_KEYWORDS char int double (and more)))
$(LI $(LINK2 /ders/d.en/assignment.html, Assignment and Order of Evaluation) $(INDEX_KEYWORDS =))
$(LI $(LINK2 /ders/d.en/variables.html, Variables))
$(LI $(LINK2 /ders/d.en/io.html, Standard Input and Output Streams) $(INDEX_KEYWORDS stdin stdout))
$(LI $(LINK2 /ders/d.en/input.html, Reading from the Standard Input))
$(LI $(LINK2 /ders/d.en/logical_expressions.html, Logical Expressions) $(INDEX_KEYWORDS bool true false !</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T012639Z" creationid="Heromyth" creationdate="20170801T100252Z">
        <seg>$(UL
$(WORK_IN_PROCESS
$(LI $(LINK2 /ders/d.cn/foreword1.html, Walter Bright 序))
)
$(LI $(LINK2 /ders/d.cn/foreword2.html, Andrei Alexandrescu 序))
$(LI $(LINK2 /ders/d.cn/preface.html, 前言))
$(LI $(LINK2 /ders/d.cn/hello_world.html, Hello World程序) $(INDEX_KEYWORDS main))
$(LI $(LINK2 /ders/d.cn/writeln.html, writeln 和 write))
$(LI $(LINK2 /ders/d.cn/compiler.html, 编译))
$(LI $(LINK2 /ders/d.cn/types.html, 基础类型) $(INDEX_KEYWORDS char int double (等)))
$(LI $(LINK2 /ders/d.cn/assignment.html, 赋值与计算顺序) $(INDEX_KEYWORDS =))
$(LI $(LINK2 /ders/d.cn/variables.html, 变量))
$(LI $(LINK2 /ders/d.cn/io.html, 标准输入、输出流) $(INDEX_KEYWORDS stdin stdout))
$(LI $(LINK2 /ders/d.cn/input.html, 从标准输入读取))
$(LI $(LINK2 /ders/d.cn/logical_expressions.html, 逻辑表达式) $(INDEX_KEYWORDS bool true false !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="black"&amp;gt;Dbooft&amp;lt;/address&amp;gt;       $(SHELL_NOTE encrypted)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042758Z" creationid="Heromyth" creationdate="20170816T042458Z">
        <seg>&amp;lt;address color="black"&amp;gt;Dbooft&amp;lt;/address&amp;gt;       $(SHELL_NOTE 已加密)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="red"&amp;gt;Avignon&amp;lt;/address&amp;gt;         $(SHELL_NOTE red)
&amp;lt;/Person&amp;gt;
&amp;lt;Person&amp;gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121650Z" creationid="Heromyth" creationdate="20170815T121650Z">
        <seg>&amp;lt;address color="red"&amp;gt;Avignon&amp;lt;/address&amp;gt;         $(SHELL_NOTE 红色)
&amp;lt;/Person&amp;gt;
&amp;lt;Person&amp;gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="red"&amp;gt;Bordeaux&amp;lt;/address&amp;gt;        $(SHELL_NOTE red)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121720Z" creationid="Heromyth" creationdate="20170815T121720Z">
        <seg>&amp;lt;address color="red"&amp;gt;Bordeaux&amp;lt;/address&amp;gt;        $(SHELL_NOTE 红色)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;lastName color="black"&amp;gt;ef!Dbooft&amp;lt;/lastName&amp;gt;  $(SHELL_NOTE encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042755Z" creationid="Heromyth" creationdate="20170816T042453Z">
        <seg>&amp;lt;lastName color="black"&amp;gt;ef!Dbooft&amp;lt;/lastName&amp;gt;  $(SHELL_NOTE 已加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;message color="blue"&amp;gt;hello world&amp;lt;/message&amp;gt;    $(SHELL_NOTE blue)
&amp;lt;/Data&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042713Z" creationid="Heromyth" creationdate="20170816T042713Z">
        <seg>&amp;lt;message color="blue"&amp;gt;hello world&amp;lt;/message&amp;gt;    $(SHELL_NOTE 蓝色)
&amp;lt;/Data&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="black"&amp;gt;Djoez&amp;lt;/name&amp;gt;              $(SHELL_NOTE encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042750Z" creationid="Heromyth" creationdate="20170816T042446Z">
        <seg>&amp;lt;name color="black"&amp;gt;Djoez&amp;lt;/name&amp;gt;              $(SHELL_NOTE 已加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="blue"&amp;gt;Bmjdf&amp;lt;/name&amp;gt;                $(SHELL_NOTE blue and encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121639Z" creationid="Heromyth" creationdate="20170815T121639Z">
        <seg>&amp;lt;name color="blue"&amp;gt;Bmjdf&amp;lt;/name&amp;gt;                $(SHELL_NOTE 蓝色且加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="blue"&amp;gt;Cfo&amp;lt;/name&amp;gt;                  $(SHELL_NOTE blue and encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121714Z" creationid="Heromyth" creationdate="20170815T121714Z">
        <seg>&amp;lt;name color="blue"&amp;gt;Cfo&amp;lt;/name&amp;gt;                  $(SHELL_NOTE 蓝色且加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($(C .clear) is the most natural method.) There are at least three methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144029Z" creationid="Hipter" creationdate="20160709T084034Z">
        <seg>（$(C .clear) 是最自然的方法。） 至少有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Because $(C hasUDA) requires $(I symbols) to work with, note how $(C __traits(getMember)) is used to get the member as a symbol (e.g. $(C Person.name)).))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T043031Z" creationid="Heromyth" creationdate="20170815T043031Z">
        <seg>（因为 $(C hasUDA) 需要 $(I 符号) 才能工作，请参考一下如何使用 $(C __traits(getMember)) 以符号方式（如 $(C Person.name)）获取成员的。）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By this distinction, class destructors should have more accurately been called $(I finalizers)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T135044Z" creationid="Heromyth" creationdate="20170819T135044Z">
        <seg>（基于此点差异，类的析构函数被叫作 $(I 终结函数) 会更加确切）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For that reason, I recommend that you prefer $(C fold()) for non-parallel code as it can take advantage of $(LINK2 /ders/d.en/ufcs.html, UFCS) in chained range expressions.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075315Z" creationid="Heromyth" creationdate="20170826T075315Z">
        <seg>（因此，我建议你最好在非并行代码中使用 $(C fold())。因为它可以利用链式范围表达式的 $(LINK2 /ders/d.cn/ufcs.html, UFCS)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Priority is an operating system concept that determines execution priorities of threads.))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045422Z" creationid="Heromyth" creationdate="20170826T045422Z">
        <seg>（优先级是一个操作系统概念，它决定了线程执行的优先次序。）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That applies to $(C immutable) variables as well because they are implicitly $(C shared).) The solution is to use $(C shared static this()) blocks, which are executed only once per program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002506Z" creationid="Heromyth" creationdate="20170826T002506Z">
        <seg>（这也适用于 $(C immutable) 因为它已隐含 $(C shared)。）解决方案是使用 $(C shared static this()) 块，它只会在程序中执行一次：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is also $(C prioritySend()), $(C receive()), and $(C receiveTimeout()), which will be explained later below.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T014333Z" creationid="Heromyth" creationdate="20170824T232913Z">
        <seg>（此外还有 $(C prioritySend())、$(C receive()) 和 $(C receiveTimeout()) ——在后面章节介绍它们。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is also $(C std.algorithm.each), which is for generating side effects for each element, as opposed to producing a result from it.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073509Z" creationid="Heromyth" creationdate="20170826T073509Z">
        <seg>（标准库中还有一个与之相似的 $(C std.algorithm.each)。但不同的是它并不会返回新的范围来储存结果，而是直接将结果应用到传入的范围的元素上。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Warning: Caesar cipher is a very weak encryption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121011Z" creationid="Heromyth" creationdate="20170815T121011Z">
        <seg>（警告：Caesar cipher 是一种强度很弱的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see D's $(I immutability) concept in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T134539Z" creationid="Hipter" creationdate="20160712T082117Z">
        <seg>（在稍后的章节我们将看到 D 的$(I 不可变性)概念。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see functions in a later chapter.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021526Z" creationid="大处着手小处着眼" creationdate="20160726T021515Z">
        <seg>（在后面的章节我们将看到这些函数。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see user-defined types later.) For example:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032924Z" creationid="大处着手小处着眼" creationdate="20160720T032924Z">
        <seg>（我们将在后面看到用户定义类型。）例如：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(anonymous MyClass object)    variable1    variable2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131919Z" creationid="Hipter" creationdate="20160706T011847Z">
        <seg>(匿名 MyClass 对象)    变量1    变量2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)
$(LI The $(C char[]) on the left-hand side is a slice, which, if the code compiled, would provide access to all of the characters of the right-hand side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150532Z" creationid="Hipter" creationdate="20160713T024324Z">
        <seg>)
$(LI 左手侧的 $(C char[]) 是一个切片，这意味着，一旦代码编译成功，它将会访问右手侧的全部字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*          program is running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134844Z" creationid="Heromyth" creationdate="20170825T134844Z">
        <seg>*          失去响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The default color is Color.black.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120021Z" creationid="Heromyth" creationdate="20170815T120021Z">
        <seg>* 默认颜色为 Color.black。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* anOperation().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142835Z" creationid="Heromyth" creationdate="20170826T024732Z">
        <seg>* anOperation() 的任务对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* arbitrarily returns the value 1 to simulate functions that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024344Z" creationid="Heromyth" creationdate="20170826T024124Z">
        <seg>* 会随意返回值 1，以便模拟函数正在</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* associative array is being defined with an extra</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122913Z" creationid="Hipter" creationdate="20160711T020244Z">
        <seg>*关联数组在定义时附加了额外的空格，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* attributes of its members.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121232Z" creationid="Heromyth" creationdate="20170815T121232Z">
        <seg>* 以 XML 格式输出它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120448Z" creationid="Heromyth" creationdate="20170815T120448Z">
        <seg>* 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* been started directly from within main has been</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033559Z" creationid="Heromyth" creationdate="20170826T033559Z">
        <seg>* 直接在 main 函数中启动的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* being called again, this time directly in main.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T025916Z" creationid="Heromyth" creationdate="20170826T025916Z">
        <seg>* ‘anOperation()’一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* blue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120350Z" creationid="Heromyth" creationdate="20170815T120350Z">
        <seg>* 蓝色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* completed, because it has been started by a regular</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033611Z" creationid="Heromyth" creationdate="20170826T033611Z">
        <seg>* 已经执行完成，因为它是一个常规</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033858Z" creationid="Heromyth" creationdate="20170826T033858Z">
        <seg>* 返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* do calculations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024513Z" creationid="Heromyth" creationdate="20170826T024513Z">
        <seg>* 进行计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* encrypted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T115828Z" creationid="Heromyth" creationdate="20170815T115236Z">
        <seg>* 的那个符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* function call, not as a task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143004Z" creationid="Heromyth" creationdate="20170826T033622Z">
        <seg>* 函数调用，而不是一个任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* function parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024757Z" creationid="Heromyth" creationdate="20170826T024757Z">
        <seg>* 传递给任务函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* member has that attribute, Color.black otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120805Z" creationid="Heromyth" creationdate="20170815T120805Z">
        <seg>* 则输出它的值，否则输出 Color.black。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* method.) */
auto encrypted(string value) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121025Z" creationid="Heromyth" creationdate="20170815T121025Z">
        <seg>* 加密方法。） */
auto encrypted(string value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* of the neighbors at eight directions, or the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235342Z" creationid="Heromyth" creationdate="20170824T235342Z">
        <seg>* 八个方向中的一个，也可能是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* operations; it returns only when the task has been</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033847Z" creationid="Heromyth" creationdate="20170826T033847Z">
        <seg>* 操作，只有在任务完成时它才会</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* position itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235411Z" creationid="Heromyth" creationdate="20170824T235411Z">
        <seg>* 指定那个位置本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* robots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235540Z" creationid="Heromyth" creationdate="20170824T235540Z">
        <seg>* 的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* see the 'foreach' loop in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011359Z" creationid="Hipter" creationdate="20160711T011324Z">
        <seg>*看到‘foreach’循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* space in between to help distinguish the value type: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122942Z" creationid="Hipter" creationdate="20160711T020350Z">
        <seg>* 以易于区分值类型： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* specified here are passed to the task function as its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024745Z" creationid="Heromyth" creationdate="20170826T024745Z">
        <seg>* 将会被作为将要并行执行的任务函数的实参</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120911Z" creationid="Heromyth" creationdate="20170815T120911Z">
        <seg>* 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* terminates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233148Z" creationid="Heromyth" creationdate="20170824T233148Z">
        <seg>*使其终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* the task function, i.e. anOperation().</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034154Z" creationid="Heromyth" creationdate="20170826T034154Z">
        <seg>* 任务执行的函数的返回值，如 anOperation()。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* the value type is int[], i.e. an array of ints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120729Z" creationid="Hipter" creationdate="20160711T014929Z">
        <seg>* 值类型为 int[] ，即整型数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* used for appending the new grade to that array: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021222Z" creationid="Hipter" creationdate="20160711T021222Z">
        <seg>* 将用于附加新成绩：*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* whether 'theTask' has completed its operations</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033755Z" creationid="Heromyth" creationdate="20170826T033755Z">
        <seg>* ‘theTask’执行的操作是否已经</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033812Z" creationid="Heromyth" creationdate="20170826T033812Z">
        <seg>* 完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*value += 1;                 // NOT atomic
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003117Z" creationid="Heromyth" creationdate="20170826T003117Z">
        <seg>*value += 1;                 // 非原子的
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
/* The equivalent of the printAsXML!Person instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052807Z" creationid="Heromyth" creationdate="20170815T052807Z">
        <seg>---
/* printAsXML!Person 实例的等同函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
/* WARNING: Your system may become unresponsive when this</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134831Z" creationid="Heromyth" creationdate="20170825T134831Z">
        <seg>---
/* 注意：在运行这个程序时你的系统可能会</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
// ... at the worker ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051905Z" creationid="Heromyth" creationdate="20170825T051905Z">
        <seg>---
// ... 工作线程中 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
int a;              // thread-local
immutable int b;    // shared by all threads</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002646Z" creationid="Heromyth" creationdate="20170826T002646Z">
        <seg>---
int a;              // 仅限线程本地
immutable int b;    // 所有线程共享</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* 'foreach' is similar but superior to 'for'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115742Z" creationid="Hipter" creationdate="20160711T011155Z">
        <seg>/* ‘foreach’类似于‘for’，但比它更有优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* ... other operations may be executed here ... */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043409Z" creationid="Heromyth" creationdate="20170825T043409Z">
        <seg>/* ... 可在此处执行其他操作... */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* As 'theTask' continues executing, 'anOperation()' is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T025846Z" creationid="Heromyth" creationdate="20170826T025846Z">
        <seg>/* 在‘theTask’执行的时候，main 函数会直接调用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* At this point we are sure that the operation that has</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T025947Z" creationid="Heromyth" creationdate="20170826T025947Z">
        <seg>/* 此处我们可以确认</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Construct a task object that will execute</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142854Z" creationid="Heromyth" creationdate="20170826T024710Z">
        <seg>/* 构建一个用于执行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Failed to send; will try again later.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135105Z" creationid="Heromyth" creationdate="20170825T135105Z">
        <seg>/* 无法发送消息；稍候会重新发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* On the other hand, it is not certain at this point</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033643Z" creationid="Heromyth" creationdate="20170826T033643Z">
        <seg>/* 另一方面，但在此处我们无法确定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Print the movement of this robot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235618Z" creationid="Heromyth" creationdate="20170824T235618Z">
        <seg>/* 输出机器人的运动情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Printing the grades of "emre": */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021258Z" creationid="Hipter" creationdate="20160711T021258Z">
        <seg>/* 打印“emre”的成绩： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Prints the first letter of 'id' every half a second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024048Z" creationid="Heromyth" creationdate="20170826T024048Z">
        <seg>/* 每半秒打印一次‘id’的首字母函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Prints the specified object in XML format according to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121156Z" creationid="Heromyth" creationdate="20170815T121156Z">
        <seg>/* 根据指定对象的各个成员的属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Ready to collect information about the movements of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235522Z" creationid="Heromyth" creationdate="20170824T235522Z">
        <seg>/* 准备好接收有关机器人的移动情况</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns a neighbor of the specified Position.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235307Z" creationid="Heromyth" creationdate="20170824T235307Z">
        <seg>/* 返回指定位置周围的坐标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns a random position around 0,0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235044Z" creationid="Heromyth" creationdate="20170824T234849Z">
        <seg>/* 返回一个坐标在 0,0 周边的随机位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns at most one step from the specified coordinate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235236Z" creationid="Heromyth" creationdate="20170824T234940Z">
        <seg>/* 返回一个坐标，它相对从指定坐标最多变化一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns the Caesar-encrypted version of the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120903Z" creationid="Heromyth" creationdate="20170815T120903Z">
        <seg>/* 返回指定字符串的 Caesar 加密</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns the value of the Colored attribute if the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T041914Z" creationid="Heromyth" creationdate="20170815T120718Z">
        <seg>/* 如果被特定要求的成员拥有 Colored 属性，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Robots with various restDurations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235435Z" creationid="Heromyth" creationdate="20170824T235435Z">
        <seg>/* 不同移动时间间隔的机器人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Sending a negative value to the worker so that it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233138Z" creationid="Heromyth" creationdate="20170824T233138Z">
        <seg>/* 向工作线程发送一个负数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Specifies that the symbol that it is assigned to should be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120233Z" creationid="Heromyth" creationdate="20170815T115215Z">
        <seg>/* 特别要求加密应用此自定义属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Specifies the color of the symbol that it is assigned to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120216Z" creationid="Heromyth" creationdate="20170815T115939Z">
        <seg>/* 特别指定应用此自定义属性的那个符号的颜色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Start a mover thread for each robot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235453Z" creationid="Heromyth" creationdate="20170824T235453Z">
        <seg>/* 为每一个机器人启动一个移动线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Start the task object */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024827Z" creationid="Heromyth" creationdate="20170826T024827Z">
        <seg>/* 启动任务对象 */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The array of ints that correspond to "emre" is being</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021215Z" creationid="Hipter" creationdate="20160711T021215Z">
        <seg>/* 与“emre” 对应的整型数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The key type of this associative array is string and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120710Z" creationid="Hipter" creationdate="20160711T014817Z">
        <seg>/* 该关联数组的键类型为 string，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member does not have any user defined</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120442Z" creationid="Heromyth" creationdate="20170815T120442Z">
        <seg>/* 这个成员没有自定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member is specified to be encrypted and printed in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042034Z" creationid="Heromyth" creationdate="20170815T120327Z">
        <seg>/* 此成员被特定要求加密，并且输出为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member is specified to be printed in red.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T041920Z" creationid="Heromyth" creationdate="20170815T120529Z">
        <seg>/* 此成员被特定要求输出为红色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Two grades for each student */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073953Z" creationid="Heromyth" creationdate="20170826T073953Z">
        <seg>/* 每个学生有两个成绩 */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Wait for a message composed of Tid, int, and double.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233458Z" creationid="Heromyth" creationdate="20170824T233458Z">
        <seg>/* 等待一个包含 Tid、int 和 double 类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//          in a class destructor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002129Z" creationid="Heromyth" creationdate="20170820T002129Z">
        <seg>//          显式分配内存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   false: overcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033314Z" creationid="大处着手小处着眼" creationdate="20160720T033314Z">
        <seg>//   false：阴天</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   has terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052144Z" creationid="Heromyth" creationdate="20170825T052144Z">
        <seg>//   它将抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   thrown if the owner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052149Z" creationid="Heromyth" creationdate="20170825T052134Z">
        <seg>//   拥有者线程已经终止，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   thrown if the worker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052348Z" creationid="Heromyth" creationdate="20170825T052348Z">
        <seg>//   工作线程已经终止，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   true : sunny</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033338Z" creationid="大处着手小处着眼" creationdate="20160720T033338Z">
        <seg>//   true ：晴天</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ... at the owner ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051928Z" creationid="Heromyth" creationdate="20170825T051928Z">
        <seg>// ... 所有者线程 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A thread whose partner is named "first"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135624Z" creationid="Heromyth" creationdate="20170825T135624Z">
        <seg>// 兄弟线程为 "first"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A thread whose partner is named "second"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135608Z" creationid="Heromyth" creationdate="20170825T135608Z">
        <seg>// 兄弟线程为 "second"</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Adding to the corresponding array, depending on</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030303Z" creationid="大处着手小处着眼" creationdate="20160726T030303Z">
        <seg>// 根据值的奇偶性，把值添加到</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An array that holds the weather information of all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044505Z" creationid="大处着手小处着眼" creationdate="20160720T033122Z">
        <seg>// 保存所有城市气象信息的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An array that holds the weights of a hundred boxes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033502Z" creationid="大处着手小处着眼" creationdate="20160720T033502Z">
        <seg>// 保存一百个箱子重量的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Concatenate:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153500Z" creationid="大处着手小处着眼" creationdate="20160715T033356Z">
        <seg>// 连接：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// For the unregister() calls to succeed, main() must wait</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135629Z" creationid="Heromyth" creationdate="20170825T135629Z">
        <seg>// 为了能成功调用 unregister()，main() 需要等待</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hoping to signal the worker to terminate:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145123Z" creationid="Heromyth" creationdate="20170825T145123Z">
        <seg>// 希望通知工作线程终止：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Inconsistent object: The area is not 10 * 20 == 200.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044904Z" creationid="Heromyth" creationdate="20170906T044904Z">
        <seg>// 不一致的对象：面积不是10 * 20 == 200.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Information about the students of a school</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033532Z" creationid="大处着手小处着眼" creationdate="20160720T033532Z">
        <seg>// 有关学校学生的信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Note: dmd 2.074.0 does not support this feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000813Z" creationid="Heromyth" creationdate="20170826T000813Z">
        <seg>// 注意：dmd 2.074.0 并不支持此功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Printing the array elements in a loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030650Z" creationid="大处着手小处着眼" creationdate="20160726T030650Z">
        <seg>// 在循环中输出数组元素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reading the value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030108Z" creationid="大处着手小处着眼" creationdate="20160726T030108Z">
        <seg>// 从输入流中读取值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reading the values in a loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025423Z" creationid="大处着手小处着眼" creationdate="20160725T073220Z">
        <seg>// 在循环中从输入流读取元素值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Signalling the worker to terminate:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233631Z" creationid="Heromyth" creationdate="20170825T233631Z">
        <seg>// 通知工作线程终止：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Spends time for each message</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134915Z" creationid="Heromyth" creationdate="20170825T134915Z">
        <seg>// 每条消息都要花费一点时间来处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The counter is commonly named as 'i'</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025710Z" creationid="大处着手小处着眼" creationdate="20160726T025710Z">
        <seg>// 计数器通常命名作‘i’</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The definition of a fixed-length array of five</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072914Z" creationid="大处着手小处着眼" creationdate="20160725T072914Z">
        <seg>// 定义了一个可包含五个 double </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The loop that calculates the fifths of the values would</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050503Z" creationid="大处着手小处着眼" creationdate="20160725T074237Z">
        <seg>// 经过计算的五个数值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The odds and evens arrays are sorted separately</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030529Z" creationid="大处着手小处着眼" creationdate="20160726T030529Z">
        <seg>// 分别排序奇偶数的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The special value of -1 breaks the loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030137Z" creationid="大处着手小处着眼" creationdate="20160726T030137Z">
        <seg>// 特殊值 -1 中断循环</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The two arrays are then appended to form a new array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084011Z" creationid="大处着手小处着眼" creationdate="20160726T030624Z">
        <seg>// 连接两个数组从而形成一个新数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014411Z" creationid="大处着手小处着眼" creationdate="20160724T025327Z">
        <seg>// 这个是数组的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is an access.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014444Z" creationid="大处着手小处着眼" creationdate="20160725T014130Z">
        <seg>// 这个是数组的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is another access.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014618Z" creationid="大处着手小处着眼" creationdate="20160725T014618Z">
        <seg>// 这是另一个访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This variable is used as a loop counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050225Z" creationid="大处着手小处着眼" creationdate="20160725T072652Z">
        <seg>// 该变量用作循环计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Using dynamic arrays because it is not known how many</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030010Z" creationid="大处着手小处着眼" creationdate="20160726T030010Z">
        <seg>// 使用动态数组的原因是不知道有多少</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Wait for a while to simulate a long-lasting operation</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013311Z" creationid="Heromyth" creationdate="20170826T013311Z">
        <seg>// 在此处暂停一会以模拟耗时长的操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Wait for all threads to finish their tasks</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235226Z" creationid="Heromyth" creationdate="20170825T235226Z">
        <seg>// 等待所有线程完成它们的任务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 0 with key "Monday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090946Z" creationid="Hipter" creationdate="20160708T145014Z">
        <seg>// 关联值 0 与 键 “Monday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 1 with key "Tuesday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090956Z" creationid="Hipter" creationdate="20160708T145024Z">
        <seg>// 关联值 1 与 键 “Tuesday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// be written similarly
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050445Z" creationid="大处着手小处着眼" creationdate="20160725T074248Z">
        <seg>//将在循环中输出
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044438Z" creationid="大处着手小处着眼" creationdate="20160720T033142Z">
        <seg>// 数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// corresponds to December and sets its value to 31.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014554Z" creationid="大处着手小处着眼" creationdate="20160725T014554Z">
        <seg>// 十二月的元素，并设置它的值为 31。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// corresponds to January, the value of which is passed to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014818Z" creationid="大处着手小处着眼" creationdate="20160725T014726Z">
        <seg>// 一月的元素，并把它的值传给</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// elements of type double</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072939Z" creationid="大处着手小处着眼" creationdate="20160725T072939Z">
        <seg>// 类型元素的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" does not exist in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T145133Z" creationid="Hipter" creationdate="20160709T035323Z">
        <seg>// 这张表里不存在 “purple” 键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" exists in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091115Z" creationid="Hipter" creationdate="20160709T035300Z">
        <seg>// 键 “purple” 在表中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// number if there is no remainder when divided by 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141551Z" creationid="大处着手小处着眼" creationdate="20160726T030452Z">
        <seg>// 除时没有余数，那这个数就是偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// of 12 elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025446Z" creationid="大处着手小处着眼" creationdate="20160724T025446Z">
        <seg>// 12个元素的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// of days in each month.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025653Z" creationid="大处着手小处着眼" creationdate="20160724T025653Z">
        <seg>// 每个月的天数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// until the workers terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135642Z" creationid="Heromyth" creationdate="20170825T135642Z">
        <seg>// 工作线程终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// values are going to be read from the input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030041Z" creationid="大处着手小处着眼" creationdate="20160726T030041Z">
        <seg>// 值要从输入流中读取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// whether the value is odd or even.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030322Z" creationid="大处着手小处着眼" creationdate="20160726T030322Z">
        <seg>//相应的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// writeln.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014829Z" creationid="大处着手小处着眼" creationdate="20160725T014829Z">
        <seg>// writeln 函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt; &lt;= &gt; &gt;= || &amp;&amp;))
$(LI $(LINK2 /ders/d.en/if.html, if Statement) $(INDEX_KEYWORDS if else))
$(LI $(LINK2 /ders/d.en/while.html, while Loop) $(INDEX_KEYWORDS while continue break))
$(LI $(LINK2 /ders/d.en/arithmetic.html, Integers and Arithmetic Operations) $(INDEX_KEYWORDS ++ -- + - * / % ^^ += -= *= /= %= ^^=))
$(LI $(LINK2 /ders/d.en/floating_point.html, Floating Point Types) $(INDEX_KEYWORDS .nan .infinity isNaN))
$(LI $(LINK2 /ders/d.en/arrays.html, Arrays) $(INDEX_KEYWORDS [] .length ~ ~=))
$(LI $(LINK2 /ders/d.en/characters.html, Characters) $(INDEX_KEYWORDS char wchar dchar))
$(LI $(LINK2 /ders/d.en/slices.html, Slices and Other Array Features) $(INDEX_KEYWORDS ..</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T100919Z" creationid="Heromyth" creationdate="20170801T100919Z">
        <seg>== != &lt; &lt;= &gt; &gt;= || &amp;&amp;))
$(LI $(LINK2 /ders/d.cn/if.html, if 语句) $(INDEX_KEYWORDS if else))
$(LI $(LINK2 /ders/d.cn/while.html, while 循环) $(INDEX_KEYWORDS while continue break))
$(LI $(LINK2 /ders/d.cn/arithmetic.html, 整型和算术运算) $(INDEX_KEYWORDS ++ -- + - * / % ^^ += -= *= /= %= ^^=))
$(LI $(LINK2 /ders/d.cn/floating_point.html, 浮点类型) $(INDEX_KEYWORDS .nan .infinity isNaN))
$(LI $(LINK2 /ders/d.cn/arrays.html, 数组) $(INDEX_KEYWORDS [] .length ~ ~=))
$(LI $(LINK2 /ders/d.cn/characters.html, 字符) $(INDEX_KEYWORDS char wchar dchar))
$(LI $(LINK2 /ders/d.cn/slices.html, 分片与其他数组功能) $(INDEX_KEYWORDS ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@$(HILITE $(PARANTEZ_AC))Encrypted, Colored$(HILITE $(PARANTEZ_KAPA)) string address;    $(CODE_NOTE together)
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043202Z" creationid="Heromyth" creationdate="20170803T043202Z">
        <seg>@$(HILITE $(PARANTEZ_AC))Encrypted, Colored$(HILITE $(PARANTEZ_KAPA)) string address;    $(CODE_NOTE 组合一起)
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@(42)                int d;    $(CODE_NOTE literal (discouraged))
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043642Z" creationid="Heromyth" creationdate="20170803T043642Z">
        <seg>@(42)                int d;    $(CODE_NOTE 文字量（不赞成）)
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Colored(Color.blue) int c;    $(CODE_NOTE object)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043625Z" creationid="Heromyth" creationdate="20170803T043625Z">
        <seg>@Colored(Color.blue) int c;    $(CODE_NOTE 对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted           int a;    $(CODE_NOTE type name)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043608Z" creationid="Heromyth" creationdate="20170803T043608Z">
        <seg>@Encrypted           int a;    $(CODE_NOTE 类型名)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted @Colored string lastName;     $(CODE_NOTE separately)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043207Z" creationid="Heromyth" creationdate="20170803T043139Z">
        <seg>@Encrypted @Colored string lastName;     $(CODE_NOTE 单独分开)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted()         int b;    $(CODE_NOTE object)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043617Z" creationid="Heromyth" creationdate="20170803T043617Z">
        <seg>@Encrypted()         int b;    $(CODE_NOTE 对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A benefit of $(C scope(failure)) is the fact that the expression that reverts another expression is written close to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T034926Z" creationid="Hipter" creationdate="20160707T034511Z">
        <seg>$(C scope(failure)) 的好处是靠近它的表达式可以还原已写的另一个表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A continuously growing mailbox puts stress on the entire system and may point to a design flaw in the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134354Z" creationid="Heromyth" creationdate="20170825T134354Z">
        <seg>邮箱中持续增加的消息不仅会加重整个系统的负担，还会成为程序设计的瑕疵。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A problem that this may cause is when we try to replace a two-code-unit character with a single-code-unit character:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T014415Z" creationid="大处着手小处着眼" creationdate="20160714T014341Z">
        <seg>当我们试着用一个单字节字符替换一个双字节字符时问题就来了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A race condition occurs when more than one thread accesses the same mutable data in an uncontrolled order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143635Z" creationid="Heromyth" creationdate="20170825T143635Z">
        <seg>当多个线程以无法控制的顺序访问同一块数据时就会引发竞态条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread that is busily working at a given time is said to be $(I CPU bound) at that point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232048Z" creationid="Heromyth" creationdate="20170824T232048Z">
        <seg>在指定运行时间消耗大量 CPU 资源的线程叫做 $(I CPU 密集型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing an array with an invalid index causes the program to be terminated with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T023148Z" creationid="大处着手小处着眼" creationdate="20160725T023148Z">
        <seg>访问具有无效索引的数组将导致出错从而终止程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to this definition, arrays are containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T141542Z" creationid="大处着手小处着眼" creationdate="20160723T141542Z">
        <seg>根据定义，数组就是容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ada, C, C++, and D are some of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005030Z" creationid="Heromyth" creationdate="20170820T005030Z">
        <seg>Ada、C、C++ 和 D 都属于这样的语言。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, interpreters usually perform very little analysis on the code before executing it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004604Z" creationid="Heromyth" creationdate="20170820T004604Z">
        <seg>此外，解释器在执行代码之前对代码的分析大都非常有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the languages that are easy to compile are usually less dynamic than those that run in an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004927Z" creationid="Heromyth" creationdate="20170820T004927Z">
        <seg>此外，容易编译的语言与在解释器中运行的语言相比往往缺乏灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, this program takes advantage of a special message type to signal to the worker when it is time to exit:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045140Z" creationid="Heromyth" creationdate="20170825T045140Z">
        <seg>此外，这个程序还使用了特殊的消息类型来通知工作线程退出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, these calls can be described as $(I if the value of the variable equals this old value, replace with this new value):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003849Z" creationid="Heromyth" creationdate="20170826T003849Z">
        <seg>你可以这样描述这种调用：$(I 如果变量值没有被其它线程改变则将新值赋给它)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All members may have already been finalized when the destructor is executing.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001709Z" creationid="Heromyth" creationdate="20170820T001709Z">
        <seg>当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the features that we have seen in this chapter can be applied to a separate $(C TaskPool) object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091026Z" creationid="Heromyth" creationdate="20170826T091026Z">
        <seg>本章介绍的所有功能都可以通过使用一个单独的 $(C TaskPool) 来调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the operations of the program are normally executed on that thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012510Z" creationid="Heromyth" creationdate="20170824T012510Z">
        <seg>通常情况下程序的所有操作都将在这个线程中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allowing user code to freely modify member variables always ends up causing issues with code maintenance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070923Z" creationid="Heromyth" creationdate="20170906T070923Z">
        <seg>允许外部代码随意修改成员变量可能会对将来的维护工作造成极大的不便。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Almost always a better design is to use property functions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070957Z" creationid="Heromyth" creationdate="20170906T070957Z">
        <seg>但最好还是使用特性函数包装：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the number of the month, which is in the range &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt;, is converted to a valid array index in the range &lt;span style="white-space: nowrap"&gt;0-11&lt;/span&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011231Z" creationid="大处着手小处着眼" creationdate="20160726T010435Z">
        <seg>另外请注意， &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; 范围内的月份数字转换为了有效的数组索引范围 &lt;span style="white-space: nowrap"&gt;0-11&lt;/span&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, although these examples use the $(C std.concurrency) module, the concepts of this chapter apply to the $(C core.thread) module as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T030015Z" creationid="Heromyth" creationdate="20170825T143811Z">
        <seg>此外，虽然本章的示例都在使用 $(C std.concurrency) 模块，但这些概念同样适用于 $(C core.thread) 模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, unlike arrays, the elements of hash tables are not stored side-by-side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131420Z" creationid="Hipter" creationdate="20160708T092324Z">
        <seg>不像数组，hash 表的元素不是逐个排列存储的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although $(C spinForce()) makes the microprocessor busy while waiting, it is suitable when the task is expected to be completed in a very short time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T150104Z" creationid="Heromyth" creationdate="20170826T045604Z">
        <seg>虽然在等待时 $(C spinForce()) 会使处理器忙碌，但它非常适合等待耗时短的任务。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it may seem syntactically that operations are being performed on a class $(I variable), the operations are actually dispatched to a class $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T010501Z" creationid="Hipter" creationdate="20160706T010501Z">
        <seg>虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although module-level variables may give the impression of being accessible by all threads, each thread actually gets its own copy:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T144819Z" creationid="Heromyth" creationdate="20170825T144819Z">
        <seg>虽然每个线程都可以访问模块级的变量，但实际上它们访问的都是对应变量在自己线程中的副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although simple, arrays are the most common data structure used to store a collection of values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022207Z" creationid="大处着手小处着眼" creationdate="20160720T022155Z">
        <seg>虽然简单，但数组是用于存储值的集合中最常见的数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although that is semantically correct, it is rarely the case in reality: microprocessors and compilers use optimization techniques to have some variables reside in microprocessor's registers that are independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012854Z" creationid="Heromyth" creationdate="20170826T012854Z">
        <seg>虽然从语义上看这种判断是正确的，但实际上我们预计的这种情况很少发生：微处理器和编译器使用的优化技术会将彼此独立的值储存在处理器寄存器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two threads execute the same $(C swapper()) function, remember that the local variable $(C temp) is separate for each thread and it is independent from the other $(C temp) variables of other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235546Z" creationid="Heromyth" creationdate="20170825T235546Z">
        <seg>虽然两个线程执行的都是 $(C swapper()) 函数，但别忘了由于 $(C temp) 是是个局部变量，每个线程都会拥有一个独立的 $(C temp) 副本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this difference makes associative arrays use more memory, it also allows them to use $(I sparse) key values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233339Z" creationid="Hipter" creationdate="20160708T093947Z">
        <seg>虽然这种不同让关联数组使用更多内存，但它也允许它们使用$(I 稀疏)键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this method works well in most cases, as we have seen in $(LINK2 /ders/d.en/templates.html, the Templates chapter), each different instantiation of a template is a different type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034416Z" creationid="Heromyth" creationdate="20170826T034416Z">
        <seg>虽然这种方法在大多数情况下都工作的很好，但就如我们在 $(LINK2 /ders/d.cn/templates.html, 模版) 一章中看到的那样：每个不同的模版实例都是一个不同的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array that stores the names of the days of the week can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143411Z" creationid="Hipter" creationdate="20160708T083910Z">
        <seg>一个存储一周当中每天的英文名称的数组可以定义下面这样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An effective usage is with $(C foreach) loops.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013653Z" creationid="Heromyth" creationdate="20170826T013653Z">
        <seg>它可以在 $(C foreach) 循环中起到非常大的作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of a concurrent program would be a server program that is responding to requests of more than one client at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221021Z" creationid="Heromyth" creationdate="20170824T012047Z">
        <seg>比如说服务器程序就是并发的，它需要同时处理多个客户端的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another example would be where the owner starts multiple workers with the address of the same variable so that the variable gets modified by more than one worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143555Z" creationid="Heromyth" creationdate="20170825T143555Z">
        <seg>或者所有者线程将同一个变量地址发给多个工作线程，这些工作线程可通过修改或读取这个变量来从其他线程获取信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any operations that are carried out by that function, including other functions that it may call, would be executed on the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T002357Z" creationid="Heromyth" creationdate="20170824T054254Z">
        <seg>该函数（包括它可能调用的其他函数）包含的所有操作都会在新线程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any value that is entered outside of the &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; range would cause the program to be terminated with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011653Z" creationid="大处着手小处着眼" creationdate="20160726T011653Z">
        <seg>&lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; 范围外的任何值都将导致程序出现错误而终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of these character types lead to three separate string types, some of which may have surprising outcomes in some string operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T110916Z" creationid="Hipter" creationdate="20160711T092039Z">
        <seg>这些字符类型的数组对应着三种独立的字符串类型，其中一些可能会在一些字符串操作上有出人意料的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result of the $(I race conditions) that they are in, they inadvertently spoil the operations of other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235257Z" creationid="Heromyth" creationdate="20170825T235257Z">
        <seg>由于它们处在$(I 竞态条件)，这些线程会在不经意间破坏其他线程的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, even operations as simple as incrementing a variable may be paused mid operation:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012558Z" creationid="Heromyth" creationdate="20170824T012558Z">
        <seg>也就是说，即使是一个简单的自增操作也可能会在执行到一半时被操作系统暂停：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, most interpreters discover programming errors only after they start executing the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004620Z" creationid="Heromyth" creationdate="20170820T004620Z">
        <seg>最后，大多数解释器在执行程序之后方能发现编程错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the program uses invalid indexes and attempts to access elements that are not parts of the arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031254Z" creationid="大处着手小处着眼" creationdate="20160726T031254Z">
        <seg>结果是，程序使用无效的索引，试图访问不在数组中的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, they cannot be members of the same array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034551Z" creationid="Heromyth" creationdate="20170826T034551Z">
        <seg>因此，它们不能被放在同一个数组里：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it has been mentioned in that chapter, message passing is a safe method of concurrency.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222627Z" creationid="Heromyth" creationdate="20170825T143348Z">
        <seg>前面章节已提到，消息传递是一种比较安全的并发方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it should be in every design decision that concerns program performance, one must take actual measurements to be exactly sure whether that really is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T003112Z" creationid="Heromyth" creationdate="20170824T232153Z">
        <seg>出于性能设计的考量，我们需要谨慎分析并确定线程的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As its function parameters, it takes a value to be used as the initial value of the result, and a range.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075353Z" creationid="Heromyth" creationdate="20170826T075353Z">
        <seg>除了用于接收函数的模版形参，它需要传入一个运算结果的初始值和一个范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the $(C foreach) loop normally operates on elements one after the other, $(C aSlowOperation()) would be called for each student sequentially.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013006Z" creationid="Heromyth" creationdate="20170826T013006Z">
        <seg>因为 $(C foreach) 循环通常是顺序操作元素的，学生的 $(C aSlowOperation()) 也会被顺序调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the operating system pauses and restarts the threads at indeterminate times, the following order of execution of the operations of the two threads is likely as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235524Z" creationid="Heromyth" creationdate="20170825T235524Z">
        <seg>由于操作系统暂停和继续线程的不确定性，这两个线程操作的执行顺序也是不确定的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the value of that variable is incremented at the end of each iteration, the $(C values[counter]) expression refers to the elements of the array one by one: $(C values[0]), $(C values[1]), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T080800Z" creationid="大处着手小处着眼" creationdate="20160725T080744Z">
        <seg>在每个迭代结束时该变量值都会递增，$(C values[counter]) 表达式指的是数组的逐个元素：$(C values[0])、$(C values[1]) 等等。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As these two concepts both involve executing programs on threads, and as parallelism is based on concurrency, they are sometimes confused with each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T005405Z" creationid="Heromyth" creationdate="20170824T011615Z">
        <seg>这两个概念都涉及多线程，且并行是基于并发的，刚接触它们时感到有些迷惑也属正常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen above, the destructor is executed some time in the future during a garbage collection cycle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T134733Z" creationid="Heromyth" creationdate="20170819T134733Z">
        <seg>正如上面看到的，析构函数会在未来垃圾回收周期内的某个时候被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen in the $(LINK2 /ders/d.en/characters.html, Characters chapter), D has three separate character types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135037Z" creationid="Hipter" creationdate="20160711T091315Z">
        <seg>正如我们在 $(LINK2 /ders/d.cn/characters.html, 字符) 一章中看到的，D 具有三种独立的字符类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we will see below, it is also possible to receive $(C OwnerTerminated) and $(C LinkTerminated) exceptions as messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044720Z" creationid="Heromyth" creationdate="20170825T044720Z">
        <seg>就像我们下面看到的那样，可以将 $(C OwnerTerminated) 和 $(C LinkTerminated) 当作消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning that return value back to $(C name) produces the intended output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021109Z" creationid="Hipter" creationdate="20160712T021109Z">
        <seg>返回值再赋值给 $(C name)，得到预期的输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays are initialized similarly to regular arrays, using a colon to separate each key from its respective value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T024011Z" creationid="Hipter" creationdate="20160709T031925Z">
        <seg>关联数组的初始化与常规数组相似，不同的是用冒号分隔每个键与相应的值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays store their elements as key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T090211Z">
        <seg>关联数组通过键值对存储它们的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming that the leftmost 3 bits are the operation number and the rightmost 5 bits are the value that is used in that operation, a sample program in machine code for this CPU might look like the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003804Z" creationid="Heromyth" creationdate="20170820T003804Z">
        <seg>假定最左边 3 位表示操作码，最右边 5 位表示用于运算的值，该 8 位 CPU 上机器码示例程序如下所示：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the lowest level these machine code instructions are implemented as electrical signals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003654Z" creationid="Heromyth" creationdate="20170820T003654Z">
        <seg>它们在最底层由电子信号实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BREADCRUMBS_FULL=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; $(LINK2 /ders/d.en/index.html, Prg in D)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170823T010647Z" creationid="Heromyth" creationdate="20170820T014719Z">
        <seg>BREADCRUMBS_FULL=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; $(LINK2 /ders/d.cn/index.html, D 语言编程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BREADCRUMBS_INDEX=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; Prg in D</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014714Z" creationid="Heromyth" creationdate="20170820T014714Z">
        <seg>BREADCRUMBS_INDEX=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; D 语言编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because array elements are stored side-by-side in memory, index values are implicitly the relative positions of elements from the beginning of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093155Z" creationid="Hipter" creationdate="20160708T093357Z">
        <seg>因为在内存中数组元素是逐个存储的，索引值就是元素位置与数组的起始位置的相对值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because data is thread-local by default, $(C static this()) must be executed by every thread so that module-level variables are initialized for all threads:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T043938Z" creationid="Heromyth" creationdate="20170826T002330Z">
        <seg>因为默认情况下数据都是本地线程所有，因此每个线程都必须执行一次 $(C static this())，以便为所有线程初始化模块级的变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because such an exception would terminate the worker thread right away, the owner in the following program can receive a response only for the first message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044959Z" creationid="Heromyth" creationdate="20170825T044959Z">
        <seg>由于异常会立刻终止工作线程，所有者只能收到第一条消息的反馈：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because that loop is normally executed on a single core, it may be unnecessarily slow when the function calls for each element are independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082347Z" creationid="Heromyth" creationdate="20170826T082347Z">
        <seg>因为通常情况下这个操作时运行在一个处理器核心上的，那么如果对每个元素的操作是独立的，这将造成不必要的执行速度的降低。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the ease of coding is not a primary consideration at this level, writing programs directly in the form of the machine code of the CPU is a very difficult task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003705Z" creationid="Heromyth" creationdate="20170820T003705Z">
        <seg>在这层，编码的舒适度不是主要考虑因素，所以直接按照 CPU 机器码形式编写程序非常困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there may be more than one $(I slice) to the same elements, $(C remove()) cannot actually change the number of element of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144435Z" creationid="Heromyth" creationdate="20170817T143753Z">
        <seg>由于数组里可能拥有多个具有相同元素的 $(I 分片) ，$(C remove()) 实际上不会改变原有数组的元素个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being value types, $(C o) and $(C i) are copied automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023459Z" creationid="Hipter" creationdate="20160706T023459Z">
        <seg>做为值类型，$(C o) 和 $(C i) 自动被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By this definition, classes are $(I user defined types).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T115500Z" creationid="Heromyth" creationdate="20170819T115500Z">
        <seg>根据此定义，类是 $(I 自定义类型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>COZUM_METIN=the solution
COZUMLER_METIN=the solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060242Z" creationid="Heromyth" creationdate="20170718T105637Z">
        <seg>COZUM_METIN=答案
COZUMLER_METIN=答案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can you figure out the remaining problem before reading the following paragraph?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031548Z" creationid="大处着手小处着眼" creationdate="20160726T031548Z">
        <seg>在没有读下面这段话之前你能指出剩下的问题吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining the result of $(C readln()) to $(C strip()) enables a shorter and more readable syntax:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140612Z" creationid="Hipter" creationdate="20160712T021719Z">
        <seg>把 $(C readln()) 的结果放到 $(C strip()) 中，能得到更短且可读性更好的语法：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking against $(C null) must be done by $(C is) or $(C !is), not by $(C ==) or $(C !=).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020106Z" creationid="Hipter" creationdate="20160707T020106Z">
        <seg>检查 $(C null) 必须使用 $(C is) 或 $(C !is)，而不是 $(C ==) 或 $(C !=)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class variables do not have members, the class objects do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004327Z" creationid="Hipter" creationdate="20160707T004327Z">
        <seg>类变量没有成员，类对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class variables do not have values themselves; the actual class objects must be constructed by the $(C new) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T125718Z" creationid="Heromyth" creationdate="20170819T125718Z">
        <seg>类变量并不拥有值本身；实际的类对象必须使用关键字 $(C new) 来构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes will be explained in more detail in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123613Z" creationid="Heromyth" creationdate="20170819T123613Z">
        <seg>稍后的章节中将展示类的更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compilers usually perform advanced analysis on the code, which help with producing fast programs and catching programming errors before the program even starts running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004854Z" creationid="Heromyth" creationdate="20170820T004854Z">
        <seg>编译器素来对源码进行深入的分析，这有助于生成更高效的程序，甚至于在程序执行之前就捕捉到编程错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency is about making a program run on more than one thread at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T220948Z" creationid="Heromyth" creationdate="20170824T012037Z">
        <seg>并发可以让一个程序同时在多个线程上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency is easy only when it is based on $(I message passing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221504Z" creationid="Heromyth" creationdate="20170824T012251Z">
        <seg>并发只有在基于 $(I 消息传递) 实现时才比较简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency is the topic of the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T134126Z" creationid="Heromyth" creationdate="20170826T014517Z">
        <seg>关于并发，下一章会主要讲解它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency makes use of threads explicitly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221157Z" creationid="Heromyth" creationdate="20170824T012205Z">
        <seg>而并发则需要显式利用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency on the other hand, is a concept that may be needed even on a single-core environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T220813Z" creationid="Heromyth" creationdate="20170824T012004Z">
        <seg>而并发则是一个在单核环境里也可以使用的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider $(I concurrency) only when threads depend on operations of other threads.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T025215Z" creationid="Heromyth" creationdate="20170825T135814Z">
        <seg>只有在线程间有相互依赖的操作时才考虑 $(I 并发)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20080919T151013Z" creationid="ZXP" creationdate="20080919T151013Z">
        <seg>内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D programs are written in text editors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003147Z" creationid="Heromyth" creationdate="20170820T003147Z">
        <seg>D 程序需要在文本编辑器里编写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D programs start executing with $(C main()) on a thread that has been assigned to that program by the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012459Z" creationid="Heromyth" creationdate="20170824T012459Z">
        <seg>D 语言程序在操作系统指定的线程上执行 $(C main()) 函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DERLEME_HATASI_METIN=compilation ERROR</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105651Z" creationid="Heromyth" creationdate="20170718T105651Z">
        <seg>DERLEME_HATASI_METIN=编译出错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Assigning user defined attributes to declarations, determining the attributes at compile time, and compiling the code according to those attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053512Z" creationid="Heromyth" creationdate="20170815T053512Z">
        <seg>DESCRIPTION=为声明加上自定义属性、在编译时检测属性，并根据那些属性编译代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Basic array operations of the D programming language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T150219Z" creationid="大处着手小处着眼" creationdate="20160726T024919Z">
        <seg>DESCRIPTION=D 语言的数组基本操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=D programming language tutorial from the ground up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T032110Z" creationid="Heromyth" creationdate="20170726T032110Z">
        <seg>DESCRIPTION=全新编写的 D 编程语言教程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Enabling using member functions like member variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071200Z" creationid="Heromyth" creationdate="20170906T071200Z">
        <seg>DESCRIPTION=像访问成员变量一样调用成员函数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Executing multiple threads that share data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004846Z" creationid="Heromyth" creationdate="20170826T004846Z">
        <seg>DESCRIPTION=执行多条共享数据的线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Parallel programming that enables taking advantage of microprocessor cores</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091429Z" creationid="Heromyth" creationdate="20170826T091429Z">
        <seg>DESCRIPTION=并行编程来利用多核心微处理器的运算能力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022345Z" creationid="Hipter" creationdate="20160711T022345Z">
        <seg>DESCRIPTION=D语言习题解答：关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032947Z" creationid="大处着手小处着眼" creationdate="20160726T032947Z">
        <seg>DESCRIPTION=D 语言编程习题解答：数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T134924Z" creationid="大处着手小处着眼" creationdate="20160714T095637Z">
        <seg>DESCRIPTION=D 语言编程习题解答：字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Starting multiple threads in the D programming language and the interactions of threads by message passing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T141037Z" creationid="Heromyth" creationdate="20170825T141037Z">
        <seg>DESCRIPTION=在 D 语言中启动多个线程并通过消息传递实现多线程交互。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The associative arrays of the d programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092656Z" creationid="Hipter" creationdate="20160709T092656Z">
        <seg>DESCRIPTION=D语言的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The basic object oriented programming (OOP) feature of the D programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013728Z" creationid="Hipter" creationdate="20160707T020838Z">
        <seg>DESCRIPTION=基本的 D 语言面向对象编程（OOP） 功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The introduction of the compiler and compiled languages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005338Z" creationid="Heromyth" creationdate="20170820T005338Z">
        <seg>DESCRIPTION=编译与编译型编程语言简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The scope(success), scope(failure), and scope(exit) statements that are used for specifying expressions that must be executed when exiting scopes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045751Z" creationid="Hipter" creationdate="20160707T045751Z">
        <seg>DESCRIPTION=scope(success)，scope(failure)，和 scope(exit) 语句用于当退出作用域时一定要执行的特殊表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The strings of the D programming language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154816Z" creationid="大处着手小处着眼" creationdate="20160715T144240Z">
        <seg>DESCRIPTION=D 语言的字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DUSEY_NAVIGASYON=
&lt;div class="vertinavheader"&gt;Other D Resources&lt;/div&gt;
$(UL
$(LI $(LINK2 http://wiki.dlang.org/Books, $(IMG bullet_black.png) Books))
$(LI $(LINK2 http://forum.dlang.org/, $(IMG bullet_black.png) Newsgroups))
$(LI $(LINK2 http://dlang.org/lex.html, $(IMG bullet_black.png) Language spec))
$(LI $(LINK2 http://dlang.org/phobos/index.html, $(IMG bullet_black.png) Standard library))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105310Z" creationid="Heromyth" creationdate="20170718T105310Z">
        <seg>DUSEY_NAVIGASYON=
&lt;div class="vertinavheader"&gt;其他D语言资源&lt;/div&gt;
$(UL
$(LI $(LINK2 http://wiki.dlang.org/Books, $(IMG bullet_black.png) 书籍))
$(LI $(LINK2 http://forum.dlang.org/, $(IMG bullet_black.png) 社区))
$(LI $(LINK2 http://dlang.org/lex.html, $(IMG bullet_black.png) 语言规范))
$(LI $(LINK2 http://dlang.org/phobos/index.html, $(IMG bullet_black.png) 标准库))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ddoc</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070111T134422Z" creationid="ZXP" creationdate="20070111T134422Z">
        <seg>Ddoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define an associative array that can store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092617Z" creationid="Hipter" creationdate="20160709T092617Z">
        <seg>定义一个能存储每个学生的多个成绩的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite being an unrealistic tool, it is still useful in this chapter to demonstrate the power of parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013258Z" creationid="Heromyth" creationdate="20170826T013258Z">
        <seg>虽然使用了一个和真实任务有差别的工具，但本章的示例还是能很好的展现出并行编程的威力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different from an interpreter, it does not execute the code; rather, it produces a program written in another language (usually machine code).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004734Z" creationid="Heromyth" creationdate="20170820T004734Z">
        <seg>与解释器不同的是，它不立即执行代码，而是生成一个用其他语言（通常为机器码）表示的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different from structs, classes provide the $(I object oriented programming) (OOP) paradigm in D. The major aspects of OOP are the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120242Z" creationid="Heromyth" creationdate="20170819T120242Z">
        <seg>不同于结构的是，D 语言中的类提供的是 $(I 面向对象编程) （OOP）模型。OOP 的主要内容有以下几个方面：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the relatively high value of 100, $(C parallel()) may give the wrong impression that it is not effective when tried on short non-$(C RandomAccessRange) ranges.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T021711Z" creationid="Heromyth" creationdate="20170826T021711Z">
        <seg>由于提供的默认值 100 相对较高，$(C parallel()) 会给人一种错觉：在处理较短的非 $(C RandomAccessRange) 范围时效率不高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each task works on the elements that it is assigned to and calculates a $(C result) that corresponds to the elements of that task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083709Z" creationid="Heromyth" creationdate="20170826T083709Z">
        <seg>但每一个任务都会去计算分派给它的元素并最终得出一个对应的 $(C result)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Elements are produced in parallel while they are being used:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073216Z" creationid="Heromyth" creationdate="20170826T073216Z">
        <seg>在元素被使用时，剩下的元素也在被并行求值
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even its $(C toString()) function is not overloaded:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T003440Z" creationid="Heromyth" creationdate="20170824T232544Z">
        <seg>它甚至没重载 $(C toString())：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even so, explicit $(C TaskPool) objects may be created and used as needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T142257Z" creationid="Heromyth" creationdate="20170826T090241Z">
        <seg>即便如此，也可以在需要的时候显示创建和使用 $(C TaskPool) 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the two objects are constructed by the same character $(C'♔'), they are still two separate objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015411Z" creationid="Hipter" creationdate="20160707T015411Z">
        <seg>即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executing the $(C scope) statements in reverse order enables undoing side effects of earlier expressions in a consistent order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045550Z" creationid="Hipter" creationdate="20160707T045428Z">
        <seg>这样按相反顺序执行 $(C scope) 语句，让程序能按一致的顺序撤消前边表达式的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For classes, the meaning of $(C opAssign) is always $(I associating a class variable with a class object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005153Z" creationid="Hipter" creationdate="20160707T005153Z">
        <seg>对于类， $(C opAssign) 意味着 $(I 一个类变量总是关联着一个类对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C __traits(getMember, Person, $(STRING "name"))) produces the symbol $(C Person.name).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T134631Z" creationid="Heromyth" creationdate="20170805T134631Z">
        <seg>例如，$(C __traits(getMember, Person, $(STRING "name"))) 生成的符号是 $(C Person.name)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C char[]) is a type of string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144519Z" creationid="Hipter" creationdate="20160711T091203Z">
        <seg>例如，$(C char[]) 是一个字符串类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C dayNumbers) would have two key-value pairs after the operations above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T145157Z">
        <seg>例如，上面的操作结束后 $(C dayNumbers) 将有两个键值对。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 'A' and 'a' are different letters, when directly comparing Unicode strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143527Z" creationid="大处着手小处着眼" creationdate="20160715T143527Z">
        <seg>例如，当直接比较 Unicode 字符串时，‘A’和‘a’是不同的字母。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 'B' comes before 'a'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143708Z" creationid="大处着手小处着眼" creationdate="20160715T143708Z">
        <seg>例如，‘B’排在‘a’之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, all of the members of $(C Person) can become encrypted in the XML output by the trivial change below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042440Z" creationid="Heromyth" creationdate="20170816T042440Z">
        <seg>例如，$(C Person) 的所有成员在 XML 格式输出里都会被加密，类似下面内容：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an array that holds the air temperatures of the days in July can bring 31 $(C double) values together and form $(I a container of elements of type $(C double)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044854Z" creationid="大处着手小处着眼" creationdate="20160723T142638Z">
        <seg>例如，一个保存了七月每天的气温的数组能汇集 31 个 double 值，形成一个 $(I $(C double) 类型元素的容器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, as the $(C formattedRead()) call above expects to read $(I two) items (a $(C string) as name and an $(C int) as age), the following check ensures that it really is the case:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063415Z" creationid="Hipter" creationdate="20160712T074138Z">
        <seg>例如，像上面的 $(C formattedRead()) 函数期望去读$(I 两个)项目(一个 $(C string) 型 name 和一个 $(C int) 型 age)，下面的检查确定它真是这样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, assuming that a $(C Student) class represents students by their names and grades, such information would be stored by the members of $(C Student) $(I objects).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131502Z" creationid="Heromyth" creationdate="20170819T131502Z">
        <seg>例如，有一个 $(C Student) 类，它通过姓名和成绩来表示学生， 此时 $(C Student) $(I 对象)的成员会存储这些信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both of the following variables have the same attributes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042510Z" creationid="Heromyth" creationdate="20170720T042510Z">
        <seg>例如，下面的变量拥有的属性是相同的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, for an imaginary 8-bit CPU, the number 4 might represent the operation of loading, the number 5 might represent the operation of storing, and the number 6 might represent the operation of incrementing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003729Z" creationid="Heromyth" creationdate="20170820T003729Z">
        <seg>例如，对于虚构的 8 位 CPU 来说，数字 4 可能表示载入操作，数字 5 可能表示存储操作，而数字 6 可能表示递增操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, for the code above, an interpreter would understand to first execute $(C a_card_has_been_played()) and then conditionally execute $(C display_the_card()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004312Z" creationid="Heromyth" creationdate="20170820T004312Z">
        <seg>例如，对于上述代码，解释器会首先执行 $(C a_card_has_been_played()) ，而后根据其执行结果选择性地执行 $(C display_the_card())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if $(C s) is a variable of type $(C char[]), the following line will fail to compile:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T032200Z" creationid="Hipter" creationdate="20160713T030425Z">
        <seg>例如，如果 $(C s) 的变量类型是 $(C char[])，下面这行将编译失败：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if it were important that the messages appear in a certain order in the output, calling $(C parallel()) should be considered an error in the program above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014423Z" creationid="Heromyth" creationdate="20170826T014423Z">
        <seg>例如，如果输出信息的顺序非常重要，那么上面程序中的 $(C parallel()) 调用将会使程序出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's assume that the grades 90, 85, 95, etc. are to be stored for the student named "emre".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233623Z" creationid="Hipter" creationdate="20160709T090853Z">
        <seg>例如，我们假设存储学生“emre”的成绩 90，85，95 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, memory used for the elements of a dynamic array is allocated by the garbage collector as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002415Z" creationid="Heromyth" creationdate="20170820T002415Z">
        <seg>例如，用于一个动态数组的元素的内存由垃圾回收器来分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the character 'é' (the latin letter 'e' combined with an acute accent) is represented by Unicode encodings using at least two bytes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T150017Z" creationid="大处着手小处着眼" creationdate="20160714T011821Z">
        <seg>例如，字符‘é’ (拉丁字母‘e’包含了一个重音符) 由 Unicode 编码表示，至少用了两个字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the characters of a $(C wchar[]) can be modified but the characters of a $(C wstring) cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T132216Z" creationid="Hipter" creationdate="20160712T081951Z">
        <seg>例如，可以修改一个 $(C wchar[]) 中的字符，但不可以修改一个 $(C wstring) 中的字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the elements of the array holding the number of days in each month can be shown like the following (assuming a year when February has 28 days):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024134Z" creationid="大处着手小处着眼" creationdate="20160725T023841Z">
        <seg>例如，下面数组的元素保存了每个月的天数（假定一年中二月有 28 天）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code assigns the $(C Encrypted) attribute to the declaration of $(C name):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042203Z" creationid="Heromyth" creationdate="20170720T042203Z">
        <seg>例如，下面代码会将 $(C Encrypted) 属性赋予 $(C name) 声明：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code removes the element at index 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145128Z" creationid="Heromyth" creationdate="20170817T145128Z">
        <seg>例如，下面这段代码将删除索引1上的那个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code removes the elements of the array that are equal to 42.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145726Z" creationid="Heromyth" creationdate="20170817T145726Z">
        <seg>例如，下面这段代码将删除数组里等于 42 的所有元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code uses the return value of $(C asyncBuf()) as an $(C InputRange) which operates semi-eagerly:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073339Z" creationid="Heromyth" creationdate="20170826T073339Z">
        <seg>例如，下面这个例子就将 $(C asyncBuf()) 的返回值作为一个半延迟取值的 $(C InputRange)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code would make ready the results of the function calls for three elements at a time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074507Z" creationid="Heromyth" creationdate="20170826T074507Z">
        <seg>例如，下面的代码每次都会为三个元素准备好函数调用的结果：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following program that tries to pass the address of a $(C bool) variable to another thread cannot be compiled:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T145110Z" creationid="Heromyth" creationdate="20170825T145110Z">
        <seg>例如，下面这个程序，试图传递 $(C bool) 值的地址只会导致编译错误：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the month can be determined by the value of the $(C monthIndex) variable below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021651Z" creationid="大处着手小处着眼" creationdate="20160725T021651Z">
        <seg>例如，下面通过变量 $(C monthIndex) 的值来确定该月：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the owner thread can start the worker with the address of a $(C bool) variable and the worker can determine whether to terminate or not by reading the current value of that variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143550Z" creationid="Heromyth" creationdate="20170825T143550Z">
        <seg>例如，所有者线程在启动工作线程的同时向其传递了一个 $(C bool) 值的地址，工作线程可通过读取这个值来判断是否需要终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the result of the first function is the first member of the tuple.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085239Z" creationid="Heromyth" creationdate="20170826T085239Z">
        <seg>例如，第一个函数的结果即为元组的第一个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the special value of -1 can be used as the code for colors that are not in $(C colorCodes).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035915Z" creationid="Hipter" creationdate="20160709T035915Z">
        <seg>例如，特殊值 -1 用作不在 $(C colorCodes) 中的  colors 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the valid indexes of a three-element array are 0, 1, and 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T022748Z" creationid="大处着手小处着眼" creationdate="20160725T022748Z">
        <seg>例如，一个具有三个元素的数组的有效索引是 0、1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the line is "this line has five words" the program should print "e has five".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144021Z" creationid="大处着手小处着眼" creationdate="20160715T144021Z">
        <seg>例如，若这行是“this line has five words”程序就应该打印出“e has five”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the member is $(STRING "name"), the right-hand side expression becomes $(C object.name.to!string).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042157Z" creationid="Heromyth" creationdate="20170815T042157Z">
        <seg>例如，当成员为 $(STRING "name") 时，对应的表达式会变成 $(C object.name.to!string)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the strings are "ebru" and "domates" the program should print "Ebru&amp;nbsp;Domates".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143945Z" creationid="大处着手小处着眼" creationdate="20160715T143945Z">
        <seg>例如，字符串是“ebru”和“domates”，程序应该打印出“Ebru&amp;nbsp;Domates”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when there are just two elements to store for keys 0 and 999, an associative array stores just two elements, not 1000 as a plain array has to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233433Z" creationid="Hipter" creationdate="20160708T094744Z">
        <seg>例如，对于键 0 和 999，当只有两个元素要存储时，关联数组就只存储两个元素，而不像简单数组那样必须 1000 个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20100615T034848Z" creationid="ZXP" creationdate="20070103T141309Z">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if the user inputs the text "résumé" you and your program cannot assume that the string length will be 6 even for $(C dchar) strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152446Z" creationid="大处着手小处着眼" creationdate="20160715T005840Z">
        <seg>例如，如果用户输入文本“résumé”，即使使用 $(C dchar) 字符串，你和你的程序仍然不能确保字符串的长度会是6。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason and in general, a compiled program runs faster compared to executing that program with an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004843Z" creationid="Heromyth" creationdate="20170820T004843Z">
        <seg>出于这个原因，通常情况下被编译的程序较被解释器所执行的程序运行更快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, $(C immutable) implies $(C shared):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233817Z" creationid="Heromyth" creationdate="20170825T233817Z">
        <seg>因此，$(C immutable) 隐含了 $(C shared)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, $(C taskPool.reduce()) may execute slower in short examples as in this chapter as will be observed in the following output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083947Z" creationid="Heromyth" creationdate="20170826T083947Z">
        <seg>因此，在某些耗时少的例子（例如本章中的某些例子）中 $(C taskPool.reduce()) 可能会比非并行版本执行速度慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, class variables must always be compared by the $(C is) and $(C !is) operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130731Z" creationid="Heromyth" creationdate="20170819T130731Z">
        <seg>因此，类变量必须总是通过运算符 $(C is) 和 $(C !is) 进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, member variables better be encapsulated either by regular member functions or by property functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070932Z" creationid="Heromyth" creationdate="20170906T070932Z">
        <seg>所以，我们最好将对成员变量的访问封装在常规成员函数或特性函数中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, running a program with an interpreter is usually slower than running the compiled version of the same program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004518Z" creationid="Heromyth" creationdate="20170820T004518Z">
        <seg>这也就是为什么使用解释器执行程序往往要比直接执行编译版本的同一程序要慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, the exceptions that are thrown are automatically caught by the tasks themselves, to be rethrown later when $(C Task) member functions like $(C yieldForce()) are called.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T144454Z" creationid="Heromyth" creationdate="20170826T034914Z">
        <seg>因此，所有抛出的异常会自动被任务自已捕获到，然后在调用类似 $(C yieldForce()) 那样的 $(C Task) 成员函数时，再重新抛出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, the initial value must be the $(I identity value) for the calculation that is being performed, e.g. the $(C 0) in this example which does not have any effect in addition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084010Z" creationid="Heromyth" creationdate="20170826T084010Z">
        <seg>所以指定的初始值应为$(I 恒等值)。例如本例中的 $(C 0) 就不会产生任何副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, the result of the remove operation must be assigned back to the same array variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144130Z" creationid="Heromyth" creationdate="20170817T144130Z">
        <seg>基于此，删除操作的结果必须回赋给同一个数组变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, usually there is no need to create any other $(C TaskPool) object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T142224Z" creationid="Heromyth" creationdate="20170826T090232Z">
        <seg>因此，通常不需要创建其他的 $(C TaskPool) 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, when we assign a new key-value pair and the key already exists, the table does not grow; instead, the value of the existing key changes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132325Z" creationid="Hipter" creationdate="20160709T030446Z">
        <seg>因而，给一个存在的键赋值，表不增长，而现有键所对应的值会发生变化：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, you may get results that don't match your expectations below.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153710Z" creationid="大处着手小处着眼" creationdate="20160715T034256Z">
        <seg>因此，下面的输出结果不是你所期望的那样。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these reasons, $(C readf()) does not work as intended when reading strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T095603Z" creationid="Hipter" creationdate="20160711T095603Z">
        <seg>因而，$(C readf()) 不能如愿读取字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this function to work correctly in a multi-threaded environment, both of the accounts must first be locked.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001229Z" creationid="Heromyth" creationdate="20170826T001229Z">
        <seg>为了能让函数在多线程环境中正确运行，每个账户都要先被锁锁住。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fortunately, in some cases program correctness can be ensured without the use of a $(C synchronized) block, by taking advantage of $(I atomic operations) that will be explained below.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000305Z" creationid="Heromyth" creationdate="20170826T000234Z">
        <seg>幸运的是大多数程序可以使用 $(I 原子操作) 替代 $(C synchronized) 块（随后会介绍它）。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the point of view of the programmer, executing with a compiler involves three steps: writing the source code, compiling it, and running the produced program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004821Z" creationid="Heromyth" creationdate="20170820T004821Z">
        <seg>这时，从程序员的角度来看，执行指令就分三个步骤：写代码、编译和执行生成的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the point of view of the programmer, executing with an interpreter involves just two steps: writing the source code and giving it to the interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004456Z" creationid="Heromyth" creationdate="20170820T004456Z">
        <seg>从程序员的角度来看，依赖解释器执行指令只涉及两个步骤：编写源代码和将源代码交由解释器处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, because there is no way to tell $(C readf()) how many characters to read, it continues to read until the end of the entire input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144815Z" creationid="Hipter" creationdate="20160711T095339Z">
        <seg>另外，因为没有办法告诉 $(C readf()) 要读取多少字符，它持续读，直到整个输入结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, since you would be unable to use a loop to iterate the 20 values, you would also have to repeat several lines 20 times, one time for each single-valued variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082255Z" creationid="大处着手小处着眼" creationdate="20160725T081423Z">
        <seg>此外，因为您无法使用循环遍历 20 个值，您也不得不把那几行代码重复 20 次，每个单值变量来一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GERI_METIN=Prev
ILERI_METIN=Next
PROBLEM_METIN=Exercise
PROBLEM_COK_METIN=Exercises
PROBLEM_TEK_COZUMSUZ_METIN=the solution will be posted later...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105551Z" creationid="Heromyth" creationdate="20170718T105551Z">
        <seg>GERI_METIN=上一章
ILERI_METIN=下一章
PROBLEM_METIN=练习
PROBLEM_COK_METIN=练习
PROBLEM_TEK_COZUMSUZ_METIN=答案将随后公布……</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HORIZNAV_CONTENT_DERSE_OZEL=$(LINK2 /ders/d.en/rss.xml, RSS&amp;nbsp;&lt;img src="$(ROOT_DIR)/image/rss-icon.png" border="0" width="16" height="16" alt="Programming in D RSS Feed"/&gt;)
$(BR)
$(LINK2 /ders/d.en/index.html,
Download or buy $(IMG book.png))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060009Z" creationid="Heromyth" creationdate="20170721T060009Z">
        <seg>HORIZNAV_CONTENT_DERSE_OZEL=$(LINK2 /ders/d.cn/rss.xml, RSS&amp;nbsp;&lt;img src="$(ROOT_DIR)/image/rss-icon.png" border="0" width="16" height="16" alt="RSS 订阅"/&gt;)
$(BR)
$(LINK2 /ders/d.cn/index.html,
下载或购买 $(IMG book.png))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash tables are among the fastest collections for storing and accessing elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T091320Z" creationid="Hipter" creationdate="20160708T091320Z">
        <seg>Hash 表是存储和访问元素的最快的集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Have the program sort the elements using $(C sort()) and then reverse the sorted elements using $(C reverse()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T022317Z" creationid="大处着手小处着眼" creationdate="20160726T022317Z">
        <seg>让程序使用 $(C sort()) 函数排序元素，然后使用 $(C reverse()) 函数反转排序的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the bool values may mean</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033302Z" creationid="大处着手小处着眼" creationdate="20160720T033302Z">
        <seg>在这里，bool 值可能意味着</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because their meanings may not be clear, attributes consisting of literal values like $(C 42) are discouraged:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043559Z" creationid="Heromyth" creationdate="20170803T043559Z">
        <seg>不过，因为它们的含义可能不是很清楚，因此不赞成大家使用文字量值（如 $(C 42) ）构成的属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the function needs to be called with every element anyway and the operations on each element are independent from each other, laziness may be unnecessarily slower than parallel execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073540Z" creationid="Heromyth" creationdate="20170826T073540Z">
        <seg>但如果范围中的每个元素都注定要被作为实参传递给函数而且每次操作又都是独立的的话，我们根本就没必要使用速度较慢的延迟取值而不是并行操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if these operations were executed in an environment that had 4 cores, they could be operated on at the same time and the total time would be reduced to about 1 second.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T132344Z" creationid="Heromyth" creationdate="20170826T013400Z">
        <seg>然而如果把这 4 个操作分配给 4 个内核执行，它们将会被同时处理。那么处理完这 4 个学生总共耗时 1 秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in many cases it is not necessary for the operations of preceding students to be completed before starting the operations of successive students.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013014Z" creationid="Heromyth" creationdate="20170826T013014Z">
        <seg>然而大部分时候这种处理的顺序并不是必须的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, regular member functions could also be used instead of properties:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070755Z" creationid="Heromyth" creationdate="20170906T070755Z">
        <seg>当然，除了特性，普通成员函数也可以实现我们需要的功能：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that is almost never the case:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000626Z" creationid="Heromyth" creationdate="20170826T000626Z">
        <seg>但是，这个程序几乎不会得出这个结果：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the exceptions can be caught and sent explicitly by the worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044707Z" creationid="Heromyth" creationdate="20170825T044707Z">
        <seg>但你也可以在工作线程中手动捕获异常并将其发送给所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the following attempt would be incorrect:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001239Z" creationid="Heromyth" creationdate="20170826T001239Z">
        <seg>但下面这个程序并不能实现我们的要求：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the grades cannot be inserted as in the following code because each grade would overwrite the previous one:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233816Z" creationid="Hipter" creationdate="20160709T092351Z">
        <seg>然而，不能像下面的代码这样插入成绩，因为后来的成绩将覆盖前一个：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the issues that they convey appear in real programs at greater scales.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143807Z" creationid="Heromyth" creationdate="20170825T143807Z">
        <seg>但是在实际编程中它们代表的问题通常规模很大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, warnings almost always indicate an actual error or bad style, so it is a common practice to consider most or all warnings as errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005229Z" creationid="Heromyth" creationdate="20170820T005229Z">
        <seg>但是，警告几乎总是指示一个实际错误或糟糕的代码风格，所以把警告当作错误对待是一个常见的做法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I recommend that you consider this module as long as the operations that need synchronization are less than a block of code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003923Z" creationid="Heromyth" creationdate="20170826T003923Z">
        <seg>所以如果需要同步的只是一些简单操作而不是一块代码的话，我建议你优先考虑这个模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If so, $(C cas()) assigns $(C newValue) to the variable and returns $(C true).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003723Z" creationid="Heromyth" creationdate="20170826T003723Z">
        <seg>这样的话 $(C cas()) 会将 $(C newValue) 赋给这个变量并返回 $(C true)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the majority of its threads are I/O bound, then a program can afford to start more threads than the number of cores without any degradation of performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T003009Z" creationid="Heromyth" creationdate="20170824T232138Z">
        <seg>如果大部分线程都是 I/O 密集型的，那么程序不需要担心由于线程数超过内核数而造成性能下降的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the operations on the $(C Student) objects were truly independent, it would be wasteful to ignore the other microprocessor cores, which might potentially be waiting idle on the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013027Z" creationid="Heromyth" creationdate="20170826T013027Z">
        <seg>如果 $(C Student) 对象相互独立，不去使用那些可能处在空闲状态的微处理器核心是非常浪费的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user eventually terminates the input that way, we see that the new-line characters have been read as parts of the string as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135535Z" creationid="Hipter" creationdate="20160712T014616Z">
        <seg>如果用户最后这样结束输入，我们看到换行符已作为字符串的一部分被读取：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no thread associated with that name, then $(C Tid.init) is returned.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135416Z" creationid="Heromyth" creationdate="20170825T135416Z">
        <seg>如果没有线程关联到这个名字，则返回 $(C Tid.init)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Illegal instructions are the ones that are outside the specifications of the language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005132Z" creationid="Heromyth" creationdate="20170820T005132Z">
        <seg>非法指令指的是超出语言规范的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine needing a thousand values; it is almost impossible to define a thousand variables from $(C value_1) to $(C value_1000).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T021233Z" creationid="大处着手小处着眼" creationdate="20160720T021233Z">
        <seg>想象一下，需要一千个值；定义从 $(C value_1) 到 $(C value_1000) 一千个变量，这几乎是不可能的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In D, it is sufficient to specify the objects in the same $(C synchronized) statement for the code to avoid such deadlocks:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002046Z" creationid="Heromyth" creationdate="20170826T002025Z">
        <seg>对于 D 语言，在同一个 $(C synchronized) 中指定这些对象即可有效避免死锁的情况：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In concurrency, it is normal for threads to depend on results of other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012141Z" creationid="Heromyth" creationdate="20170824T012141Z">
        <seg>而对于并发，线程间的相互依赖是很常见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it would be a bug if they did depend on results of other tasks that are running at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221043Z" creationid="Heromyth" creationdate="20170824T012132Z">
        <seg>事实上如果同时运行的任务依赖其他任务的结果就可能会引发程序错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, tasks that have been covered in the previous chapter are based on threads that are started automatically by $(C std.parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222226Z" creationid="Heromyth" creationdate="20170824T012537Z">
        <seg>实际上，上一章讲解的任务是基于线程的，只不过这些线程是由 $(C std.parallelism) 自动启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to copy class objects, the type must have a special function likely named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020430Z" creationid="Hipter" creationdate="20160707T020335Z">
        <seg>为了复制类对象，类型必须有一个类似于命名为 $(C dup()) 的特殊函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use the $(C sort()) function, one must import the $(C std.algorithm) module first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021425Z" creationid="大处着手小处着眼" creationdate="20160726T021425Z">
        <seg>为了使用 $(C sort()) 函数，必须先导入 $(C std.algorithm) 模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, $(C opAssign) cannot be overloaded for them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031807Z" creationid="Hipter" creationdate="20160706T031807Z">
        <seg>换句话说，$(C opAssign) 不能因为它们而被重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, a thread can execute a member function only if no other thread is executing a member function on the same object.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004519Z" creationid="Heromyth" creationdate="20170826T004519Z">
        <seg>换句话说，线程只能在没有其他线程调用这个类的实例的成员函数的情况下才能操作它。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, arrays map indexes to values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T084530Z" creationid="Hipter" creationdate="20160708T084530Z">
        <seg>换句话说，数组映射索引到值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, class variables may not be providing access to any object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124942Z" creationid="Heromyth" creationdate="20170819T124942Z">
        <seg>换句话说，类变量可以不提供对任何对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, instead of typing $(C value_1) one must type $(C values[0]) with arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023208Z" creationid="大处着手小处着眼" creationdate="20160724T023208Z">
        <seg>换句话说，对数组输入 $(C values[0]) 而不是键入 $(C value_1) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it can be used as the opposite of the $(C dayNames) array at the beginning of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030433Z" creationid="Hipter" creationdate="20160708T141319Z">
        <seg>换句话说，它能用作本章开始处 $(C dayNames) 数组的逆转。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it stores an array of ten integer values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T024436Z" creationid="大处着手小处着眼" creationdate="20160720T023707Z">
        <seg>换句话说，它是一个可存储十个整数值的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In parallelism, it wraps $(C yieldForce()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045226Z" creationid="Heromyth" creationdate="20170826T045226Z">
        <seg>而在并行中，它只封装了 $(C yieldForce())：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases $(C taskPool.reduce()) from the $(C std.parallelism) module can be used for taking advantage of all of the cores.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T082358Z" creationid="Heromyth" creationdate="20170826T082358Z">
        <seg>在这种情况下你就可以使用 $(C std.parallelism) 模块中的 $(C taskPool.reduce()) 来利用多核心的运算能力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases the template parameters of $(C receiveOnly()) must match the types of the tuple members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T015646Z" creationid="Heromyth" creationdate="20170824T233435Z">
        <seg>此时，$(C receiveOnly()) 的模版参数的类型要与每一个元组成员的类型对应：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, it may be faster to have each thread execute more than one iteration of the loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T141731Z" creationid="Heromyth" creationdate="20170826T020151Z">
        <seg>此时，让每个线程去执行循环的多个迭代反而会更快些。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the $(C .idup) property can be used to produce an immutable $(C string) variable from a mutable $(C char[]) variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T151939Z" creationid="Hipter" creationdate="20160713T030418Z">
        <seg>这种情况下，$(C .idup) property 能被用来从一个可变的 $(C char[]) 变量中生成一个不可变的 $(C string) 变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the initial values of the elements can be specified on the right-hand side of the assignment operator, within square brackets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083958Z" creationid="大处着手小处着眼" creationdate="20160725T083958Z">
        <seg>在这种情况下，元素的初始值可以在分配操作的右手侧方括号内指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case all of the elements of the array are initialized to that value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012049Z" creationid="大处着手小处着眼" creationdate="20160726T012049Z">
        <seg>在这种情况下，所有的数组元素都初始化为该值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case it $(I returns) the line that it has just read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063005Z" creationid="Hipter" creationdate="20160712T021418Z">
        <seg>在这种情况下它$(I 返回)刚刚读入的行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, the types of the members of the tuples would be different as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085826Z" creationid="Heromyth" creationdate="20170826T085826Z">
        <seg>此时，元组成员的类型也不一定相同：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of integers, the elements get sorted from the smallest value to the greatest value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021258Z" creationid="大处着手小处着眼" creationdate="20160726T021258Z">
        <seg>对于整数，元素按从小到大排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the simplest definition, strings are nothing but arrays of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091131Z" creationid="Hipter" creationdate="20160711T091131Z">
        <seg>在最简单的定义中，字符串只不过是字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the constructor must be defined as $(C pure) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133939Z" creationid="Heromyth" creationdate="20170819T133939Z">
        <seg>此时，构造函数必须同时定义为 $(C pure) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance is for acquiring $(I implementations) of other types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T122731Z" creationid="Heromyth" creationdate="20170819T122731Z">
        <seg>继承是用于获取其它类型的 $(I 实现)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of defining an additional member, the value of that member is calculated by a function named $(C area), the same as the concept that it represents:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044920Z" creationid="Heromyth" creationdate="20170906T044920Z">
        <seg>我们要定义一个名为 $(C area) 的函数来计算面积而不是定义成员变量来表示面积：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, $(C parallel()) reuses the internal buffer of the result range.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T021921Z" creationid="Heromyth" creationdate="20170826T021921Z">
        <seg>$(C parallel()) 将会使用这两个函数返回的范围中的缓冲区。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the comparison must be done by the $(C is) or the $(C !is) operator, accordingly:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130448Z" creationid="Heromyth" creationdate="20170819T130448Z">
        <seg>相反，必须相应地使用运算符 $(C is) 或 $(C !is)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the elements are accessed by specifying the $(I element number) within square brackets:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T045216Z" creationid="大处着手小处着眼" creationdate="20160724T022032Z">
        <seg>相反，通过指定方括号内的元素位置数就可以访问元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the program terminates with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024649Z" creationid="大处着手小处着眼" creationdate="20160726T024649Z">
        <seg>若有错误，程序会终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024113Z" creationid="Heromyth" creationdate="20170826T024113Z">
        <seg>它</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It accesses the element that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014519Z" creationid="大处着手小处着眼" creationdate="20160725T014519Z">
        <seg>它访问对应于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls a function with the elements of a range one-by-one and returns a range that consists of the results of calling that function with each element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073427Z" creationid="Heromyth" creationdate="20170826T073427Z">
        <seg>它会对范围中的每一个元素应用指定的函数，并将函数的返回值组合为范围返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can continue working on other things if a message does not arrive within that time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044525Z" creationid="Heromyth" creationdate="20170825T044525Z">
        <seg>如果消息超时它还会继续执行其他操作：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consumes more memory to gain speed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075055Z" creationid="Heromyth" creationdate="20170826T075055Z">
        <seg>它是通过消耗更多的内存来获得更快速度的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines an array that consists</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025506Z" creationid="大处着手小处着眼" creationdate="20160724T025431Z">
        <seg>它定义了一个可以存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It dispatches messages to message handling delegates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T020058Z" creationid="Heromyth" creationdate="20170824T235908Z">
        <seg>它会把这些消息分发给各个消息处理委托。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It identifies the robots by the robot ids that are sent as parts of the messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234512Z" creationid="Heromyth" creationdate="20170824T234449Z">
        <seg>它通过消息中的机器人 ID 来识别机器人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a lazy algorithm: It calls the function as needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073437Z" creationid="Heromyth" creationdate="20170826T073437Z">
        <seg>这是一个延迟求值的算法，只有在返回的结果被使用时它才会调用指定的函数进行运算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an even</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030417Z" creationid="大处着手小处着眼" creationdate="20160726T030417Z">
        <seg>如果值被 2 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is commonly called without the function parentheses:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232316Z" creationid="Heromyth" creationdate="20170824T232316Z">
        <seg>通常调用它的时候不需要带圆括号：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is easy to see an example of such a problem simply by trying to allocate an object in a class destructor:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002034Z" creationid="Heromyth" creationdate="20170820T002034Z">
        <seg>尝试在类的析构函数中分配一个对象，通过这种方式可以轻易地重现这种的问题：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not possible that they can ever have any other value after that point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235816Z" creationid="Heromyth" creationdate="20170825T235816Z">
        <seg>此处不可能会再有其他的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible that each thread may have just locked its respective $(C from) object, hoping next to lock its $(C to) object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001332Z" creationid="Heromyth" creationdate="20170826T001332Z">
        <seg>每个线程都会先锁住各自的 $(C from) 对象，然后再尝试去锁 $(C to) 对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the owner thread that $(I serializes) the printing process simply by receiving messages from its message box one by one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235730Z" creationid="Heromyth" creationdate="20170824T235730Z">
        <seg>所有者线程仅仅是将收件箱中的消息一个一个取出来并$(I 按顺序)输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is used by specifying the current and the desired values of the variable at the same time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003539Z" creationid="Heromyth" creationdate="20170826T003539Z">
        <seg>使用方法是同时指定当前值和期望值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is used differently because the $(STRING " %s") format string and the $(C &amp;) operator are not needed:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015633Z" creationid="Hipter" creationdate="20160712T015506Z">
        <seg>不同的是没有 $(STRING " %s") 格式字符串并且不需要 $(C &amp;) 运算符：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is very difficult to write correct concurrent programs if they are based on the traditional model of concurrency that involves lock-based data sharing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T221955Z" creationid="Heromyth" creationdate="20170824T012308Z">
        <seg>若使用传统的基于锁的数据共享实现的并发模型，则很难写出正确的并发程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may also mean that the thread may never get to the most recent messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134405Z" creationid="Heromyth" creationdate="20170825T134405Z">
        <seg>这也意味着线程永远只能拿到许久之前接收的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235325Z" creationid="Heromyth" creationdate="20170824T235325Z">
        <seg>它既可能是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might be greater if e.g. at least one of the 'é' characters is not encoded as a single code point but as the combination of an 'e' and a combining accute accent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152728Z" creationid="大处着手小处着眼" creationdate="20160715T013340Z">
        <seg>如果至少其中一个‘é’字符没有做为单个编码点编码，而是一个‘e’与一个组合重音符的组合，那么它就可能会更长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It prints the first letter of $(C id) to indicate which task it is working for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T023737Z" creationid="Heromyth" creationdate="20170826T023737Z">
        <seg>它将打印出 $(C id) 的第一个字符，这样我们就可以通过这个字符来判断程序正在等待哪一个任务执行完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It produces a symbol by combining its first argument, a dot, and its second argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T134502Z" creationid="Heromyth" creationdate="20170805T134502Z">
        <seg>它会生成一个符号，其组成部分包含了它的第一个参数、一个小数点和它的第二个参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns $(C true) if the object is the same and $(C false) otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014719Z" creationid="Hipter" creationdate="20160707T014719Z">
        <seg>如果是同一对象，返回 $(C true) ，否则为 $(C false) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a range that consists of the results of applying that function to the elements of the range:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073914Z" creationid="Heromyth" creationdate="20170826T073914Z">
        <seg>它会返回一个新的范围来储存应用函数后得到的结果：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It stores the elements in a buffer as they are produced by the range, and serves the elements from that buffer to its user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045722Z" creationid="Heromyth" creationdate="20170826T045722Z">
        <seg>它将范围中的元素储存在缓冲区中，需要时用户再从缓冲区中获取元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating over this slice and removing the element for each key by calling $(C .remove) would result in an empty associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T142255Z" creationid="Hipter" creationdate="20160711T005658Z">
        <seg>采用迭代此分片，并对每个键调用 $(C .remove) 函数来移除元素的方法，最后会得到一个空的关联数组：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating the loop while its value is less than $(C values.length) ensures that the loops are executed once per element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T075021Z" creationid="大处着手小处着眼" creationdate="20160725T075021Z">
        <seg>当它的值小于 $(C values.length) 时，迭代循环可以保证每个元素只执行了一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its $(C ~=) counterpart combines the two arrays and assigns the result back to the left-hand side array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T150131Z" creationid="大处着手小处着眼" creationdate="20160726T015640Z">
        <seg>$(C ~=) 将两边的数组连接起来，并把结果赋给左边那个数组：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its behavior can be described as $(I mutate the variable if it still has its currently known value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003529Z" creationid="Heromyth" creationdate="20170826T003529Z">
        <seg>它的操作的理念是：$(I 如果变量的值与已知当前值相同，则修改变量)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its first argument is a symbol (e.g. a type or a variable name) and its second argument is a string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T133822Z" creationid="Heromyth" creationdate="20170805T133822Z">
        <seg>它的第一个参数是符号（如类型或者变量名），第二个参数是字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its first parameter is the line that contains the data, and the rest of the parameters are used exacly like $(C readf()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T143027Z" creationid="Hipter" creationdate="20160712T033324Z">
        <seg>它的第一个参数是包含数据的输入行，而其余的参数就与 $(C readf()) 的一模一样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its return value is $(C true) if a message has been received within that time, $(C false) otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043357Z" creationid="Heromyth" creationdate="20170825T043357Z">
        <seg>如果在指定时间内接收到了消息，函数返回值为 $(C true) ；如果超时则返回 $(C false)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its return value is the return value of</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T033903Z" creationid="Heromyth" creationdate="20170826T033903Z">
        <seg>它的返回值即为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its three parameters specify the mailbox, the maximum number of messages that it can hold, and what should happen when the mailbox is full, in that order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134431Z" creationid="Heromyth" creationdate="20170825T134431Z">
        <seg>它的三个参数分别指代的是邮箱、最大保存消息数量和邮箱被填满之后需要进行的操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like $(C map()), it takes one or more functions as template parameters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075337Z" creationid="Heromyth" creationdate="20170826T075337Z">
        <seg>和 $(C map()) 一样，它也可以接收一个或多个函数作为模版实参。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005402Z" creationid="Heromyth" creationdate="20170820T005402Z">
        <seg>KEYWORDS=D 编程 语言 教程 书籍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book arrays fixed-length dynamic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025230Z" creationid="大处着手小处着眼" creationdate="20160726T024956Z">
        <seg>KEYWORDS=D 编程语言 教程 定长 动态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092726Z" creationid="Hipter" creationdate="20160709T092726Z">
        <seg>KEYWORDS=D 编程语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book concurrency thread</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T141223Z" creationid="Heromyth" creationdate="20170825T141223Z">
        <seg>KEYWORDS=d programming language tutorial book concurrency thread 编程 语言 教程 书籍 并发 线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book concurrency thread data sharing</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004949Z" creationid="Heromyth" creationdate="20170826T004949Z">
        <seg>KEYWORDS=d programming language tutorial book concurrency thread data sharing 编程 语言 教程 书籍 并发 线程 数据 共享
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book novice beginner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T045729Z" creationid="Heromyth" creationdate="20170801T100406Z">
        <seg>KEYWORDS=d programming language tutorial book novice beginner D 编程语言 教程 书籍 新手 初学者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book parallel programming</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091539Z" creationid="Heromyth" creationdate="20170826T091539Z">
        <seg>KEYWORDS=d programming language tutorial book parallel programming 编程 语言 教程 书籍 并行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T050130Z" creationid="Hipter" creationdate="20160707T045824Z">
        <seg>KEYWORDS=D 语言编程教程 scope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book string</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144252Z" creationid="大处着手小处着眼" creationdate="20160715T144252Z">
        <seg>KEYWORDS=D 语言教程 string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book user defined attributes UDA</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053942Z" creationid="Heromyth" creationdate="20170804T053942Z">
        <seg>KEYWORDS=d programming language tutorial book user defined attributes UDA D 编程语言 教程 书籍 自定义属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming lesson book tutorial class</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013649Z" creationid="Hipter" creationdate="20160707T020932Z">
        <seg>KEYWORDS=D 语言 编程 教程 书籍 教程 类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming lesson book tutorial property</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071257Z" creationid="Heromyth" creationdate="20170906T071257Z">
        <seg>KEYWORDS=d programming lesson book tutorial property 编程 课程 书籍 教程 特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial arrays solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T033049Z" creationid="大处着手小处着眼" creationdate="20160726T033032Z">
        <seg>KEYWORDS=D 语言编程教程 数组 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022406Z" creationid="Hipter" creationdate="20160711T022406Z">
        <seg>KEYWORDS=D语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial strings solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151258Z" creationid="大处着手小处着眼" creationdate="20160714T100248Z">
        <seg>KEYWORDS=D 语言教程 字符串 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's assume that $(C Student) has a member function that returns the average grade of the student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073839Z" creationid="Heromyth" creationdate="20170826T073839Z">
        <seg>我们假设 $(C Student) 有一个计算并返回学生平均分的成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's see this in a program that reads the number of the month from the user, and prints the number of days in that month:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051000Z" creationid="大处着手小处着眼" creationdate="20160725T084038Z">
        <seg>让我们来看一看这个程序，读取来自用户的月数，并输出当月的天数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's see this on a class that has various types of members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022751Z" creationid="Hipter" creationdate="20160706T022751Z">
        <seg>让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like $(C finally), the three different $(C scope) statements are about executing expressions when leaving scopes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025251Z" creationid="Hipter" creationdate="20160707T025035Z">
        <seg>像 $(C finally)，下面三个不同的 $(C scope) 语句就是关于离开作用域时应执行的表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAIN_TITLE=D.ershane Solutions
CLASS=solution
COZUM_BOLUMU = $(H4 $0)
LANG=en
LANGUAGE=english
SUB_AUTHOR=</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014830Z" creationid="Heromyth" creationdate="20170718T104957Z">
        <seg>MAIN_TITLE=D 语言答案
CLASS=答案
COZUM_BOLUMU = $(H4 $0)
LANG=zh-cn
LANGUAGE=chinese
SUB_AUTHOR=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAIN_TITLE=Programming in D
SUB_MAIN_TITLE_DERSE_OZEL=– Tutorial and Reference
SUB_AUTHOR=Ali Çehreli
LANG=en
LANGUAGE=english</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T055442Z" creationid="Heromyth" creationdate="20170718T105151Z">
        <seg>MAIN_TITLE=D 编程语言
SUB_MAIN_TITLE_DERSE_OZEL=——教程与参考
SUB_AUTHOR=Ali Çehreli
LANG=zh-cn
LANGUAGE=chinese</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Merely importing the $(C std.parallelism) module and replacing $(C students) with $(C parallel(students)) in the program above is sufficient to take advantage of all of the cores of the system:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013706Z" creationid="Heromyth" creationdate="20170826T013706Z">
        <seg>只需要导入 $(C std.parallelism) 模块并将上面代码中的 $(C students) 换为 $(C parallel(students)) 即可充分利用系统中全部核心的运算能力。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message passing normally involves more complicated communication in many kinds of programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234629Z" creationid="Heromyth" creationdate="20170824T234629Z">
        <seg>当然在许多程序中消息传递不止这么简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages may be composed of any type and any number of variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054103Z" creationid="Heromyth" creationdate="20170824T054103Z">
        <seg>任何类型任何长短的数据都可以被称为消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages that do not match the handlers that are specified earlier in the argument list always match a $(C Variant) handler:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043113Z" creationid="Heromyth" creationdate="20170825T043113Z">
        <seg>如果消息无法与参数列表前面指定的各个处理函数相匹配，那么它们将会与一个 $(C Variant) 类型的处理函数匹配：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More features will be introduced later in $(LINK2 /ders/d.en/slices.html, the Slices and Other Array Features chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014118Z" creationid="大处着手小处着眼" creationdate="20160720T022422Z">
        <seg>更多功能将在后面 $(LINK2 /ders/d.cn/slices.html, 分片和其他数组功能一章) 介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the programs that are produced by a compiler can usually run only on a specific platform; to run on a different kind of processor or on a different operating system, the program would have to be recompiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004923Z" creationid="Heromyth" creationdate="20170820T004923Z">
        <seg>另外，编译器往往是针对某一特定平台进行编译，程序需要重新编译以在不同的处理器或操作系统上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the features that we have seen for structs in the following chapters apply to classes as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123741Z" creationid="Heromyth" creationdate="20170819T123741Z">
        <seg>在下面的章节中我们已经看到结构的大部分特性也适用于类：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MyClass variable;   // does not reference an object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130525Z" creationid="Heromyth" creationdate="20170819T130525Z">
        <seg>MyClass variable;   // 没有引用对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, all of the algorithms use the same container object named $(C taskPool).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T142019Z" creationid="Heromyth" creationdate="20170826T090211Z">
        <seg>一般情况下，所有算法都会使用同一个名为 $(C taskPool) 的容器对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that I have chosen the name of the array variable as plural to avoid confusing it with a single-valued variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T030859Z" creationid="大处着手小处着眼" creationdate="20160720T030859Z">
        <seg>请注意，我选择了数组变量的名字为复数，以避免它与单值变量混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the constructor copies the $(C s) member explicitly by the $(C .dup) property of arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023408Z" creationid="Hipter" creationdate="20160706T023408Z">
        <seg>注意，构造函数通过数组的  $(C .dup) 属性显式复制 $(C s) 成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the return types of the functions need not be the same, as seen in the $(C quarterOf()) and $(C tenTimes()) functions below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085627Z" creationid="Heromyth" creationdate="20170826T085627Z">
        <seg>注意，这些函数的返回类型不一定相同，如下面示例中的 $(C quarterOf()) 和 $(C tenTimes()) 函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no need for the $(C Lock) class anymore either:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003448Z" creationid="Heromyth" creationdate="20170826T003448Z">
        <seg>请注意，现在不再需要 $(C Lock) 类：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is different from single threads: In single-threaded programs like the samples that we have been writing until this chapter, $(C try-catch) wraps the code that may throw.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T035145Z" creationid="Heromyth" creationdate="20170826T035145Z">
        <seg>这与单线程有着极大的不同：像本章上面的程序如果写成单线程的话，应该将 $(C try-catch) 包裹住可能会抛出异常的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observe that it starts ten threads that all access the same two variables $(C i) and $(C j).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235247Z" creationid="Heromyth" creationdate="20170825T235247Z">
        <seg>你看它启动了 10 个线程，这些线程都要去访问变量 $(C i) 和 $(C j)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Obviously, the race conditions would be much more complicated in the case of the ten threads of this example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235837Z" creationid="Heromyth" creationdate="20170825T235837Z">
        <seg>10 条线程的实际情况要比例子复杂得多。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, a program that did not use an array would have to have 20 variable definitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T081416Z" creationid="大处着手小处着眼" creationdate="20160725T081416Z">
        <seg>另一方面，这个程序若不使用数组那将必须定义 20 个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, having to compile the program every time it is changed is a complication and a potential source of human errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004905Z" creationid="Heromyth" creationdate="20170820T004905Z">
        <seg>另一方面，每次改变代码都必须重新编译，既复杂又易引起人为错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, if the variable's value is different from $(C currentValue) then $(C cas()) does not mutate the variable and returns $(C false).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003748Z" creationid="Heromyth" creationdate="20170826T003748Z">
        <seg>另一方面，如果 $(C cas()) 发现变量的值不再等于 $(C currentValue) ，那么它将直接返回 $(C false)，不再修改变量的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, some threads spend considerable amount of their time waiting for some event to occur like input from a user, data from a network connection, the completion of a $(C Thread.sleep) call, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232105Z" creationid="Heromyth" creationdate="20170824T232105Z">
        <seg>与之相对的是消耗大量时间等待事件、用户输入、来自互联网的数据或调用了 $(C Thread.sleep) 等情况的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it prepares certain number of elements in parallel, it waits until those elements are consumed by $(C popFront()) before producing the elements of the next wave.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T045757Z" creationid="Heromyth" creationdate="20170826T045757Z">
        <seg>每轮在缓冲区中载入一定数量的元素用于并行迭代。只有当上一轮缓冲的元素被 $(C popFront()) 消耗完后，它才会开始为下一轮迭代缓冲元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One solution is to have the worker catch the exception to be sent as a message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233821Z" creationid="Heromyth" creationdate="20170824T233821Z">
        <seg>一种解决方案是在工作线程中捕获潜在的由接收信息引发的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way of avoiding these race conditions is to mark the common code with the $(C synchronized) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235928Z" creationid="Heromyth" creationdate="20170825T235912Z">
        <seg>一种解决方案是使用关键字 $(C synchronized) 标记公共代码以消除竞态条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the programmer can determine that certain high-level operations are independent and that they can be executed in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012928Z" creationid="Heromyth" creationdate="20170826T012928Z">
        <seg>只有程序员才能判断哪些高级别的操作是互相独立、可以并行化的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the thread that holds the lock can be executed and the others wait until the lock becomes available again when the executing thread completes its $(C synchronized) block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000032Z" creationid="Heromyth" creationdate="20170826T000032Z">
        <seg>只有持有锁的那个线程才可以执行，其他线程都需要等待持有锁的线程执行完成并释放 $(C synchronized) 锁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other than in rare pathological cases, the time it takes to store or access an element is independent of the number of elements that are in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T100056Z" creationid="Hipter" creationdate="20160708T091750Z">
        <seg>除极个别情况外，一般存取单个元素所花费的时间不依赖于关联数组中元素的个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it is possible that more than one thread may have locked objects that other threads are waiting for, in which case the program may be $(I deadlocked).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001207Z" creationid="Heromyth" creationdate="20170826T001207Z">
        <seg>不然的话就可能出现几个线程分别拿到了不同的锁，而它们又在等待其他线程手中的锁的情况，即$(I 死锁)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PROBLEM_COK_COZUMSUZ_METIN=the solutions will be posted later...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105604Z" creationid="Heromyth" creationdate="20170718T105604Z">
        <seg>PROBLEM_COK_COZUMSUZ_METIN=答案将随后公布……</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partly because they are anonymous, it is not possible to access class objects directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131523Z" creationid="Heromyth" creationdate="20170819T131523Z">
        <seg>另一方面，类变量是用于访问类对象的一种语言特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing thread ids from thread to thread may be overly complicated in programs that use more than a couple of threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135231Z" creationid="Heromyth" creationdate="20170825T135231Z">
        <seg>一旦线程数增加，它将会大大增加程序的复杂度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Plain arrays can use only integers as indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085309Z" creationid="Hipter" creationdate="20160708T084606Z">
        <seg>简单数组只能使用整型做索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Problems like a mismatched parenthesis, a missing semicolon, a misspelled keyword, etc. all cause compilation errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005135Z" creationid="Heromyth" creationdate="20170820T005135Z">
        <seg>诸如圆括号未匹配、分号丢失、关键字拼错等的问题都会引起编译错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Produce the full name that contains the proper capitalization of the first and last names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143933Z" creationid="大处着手小处着眼" creationdate="20160715T143933Z">
        <seg>生成一个姓名首字母大写的全名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming languages are easier for humans to understand, closer to natural languages:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004159Z" creationid="Heromyth" creationdate="20170820T004120Z">
        <seg>编程语言更易于人类理解，更接近自然语言：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming languages do not have to deal with hardware constraints; their main purposes are ease of use and expressiveness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004126Z" creationid="Heromyth" creationdate="20170820T004047Z">
        <seg>编程语言不处理底层硬件约束，它们的主要目的是使用和表现上的简易舒适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programs can consist of multiple threads that are being actively executed at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014247Z" creationid="Heromyth" creationdate="20170826T014247Z">
        <seg>程序可由多个同时执行操作的线程组成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it has to move some of the elements of the array one or more positions to the left.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144512Z" creationid="Heromyth" creationdate="20170817T143944Z">
        <seg>由此，它不得不将原数组的某些元素向左移动一个或多个位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S      o;  // assume S is a struct type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022841Z" creationid="Hipter" creationdate="20160706T022841Z">
        <seg>S      o;  // 假设 S 是一个结构类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024838Z" creationid="大处着手小处着眼" creationdate="20160726T024838Z">
        <seg>SUBTITLE=数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Arrays Solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032902Z" creationid="大处着手小处着眼" creationdate="20160726T032902Z">
        <seg>SUBTITLE=数组习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092636Z" creationid="Hipter" creationdate="20160709T092636Z">
        <seg>SUBTITLE=关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays Solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T041125Z" creationid="Hipter" creationdate="20160711T022321Z">
        <seg>SUBTITLE=关联数组 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020705Z" creationid="Hipter" creationdate="20160707T020705Z">
        <seg>SUBTITLE=类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Compiler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005319Z" creationid="Heromyth" creationdate="20170820T005319Z">
        <seg>SUBTITLE=编译器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Data Sharing Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T004748Z" creationid="Heromyth" creationdate="20170826T004748Z">
        <seg>SUBTITLE=数据共享与并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Message Passing Concurrency</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T140855Z" creationid="Heromyth" creationdate="20170825T140855Z">
        <seg>SUBTITLE=基于消息传递的并发</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Parallelism</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T091418Z" creationid="Heromyth" creationdate="20170826T091418Z">
        <seg>SUBTITLE=并行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Programming in D</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T011119Z" creationid="Heromyth" creationdate="20170726T011119Z">
        <seg>SUBTITLE=D 语言编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Properties</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071142Z" creationid="Heromyth" creationdate="20170906T071142Z">
        <seg>SUBTITLE=特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144233Z" creationid="大处着手小处着眼" creationdate="20160715T144233Z">
        <seg>SUBTITLE=字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Strings Solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095608Z" creationid="大处着手小处着眼" creationdate="20160714T095608Z">
        <seg>SUBTITLE=字符串 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=User Defined Attributes (UDA)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053834Z" creationid="Heromyth" creationdate="20170804T053834Z">
        <seg>SUBTITLE=自定义属性（UDA）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short for "read line", $(C readln()) reads until the end of the line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015218Z" creationid="Hipter" creationdate="20160712T015218Z">
        <seg>它是“read line”的缩写，$(C readln()) 读取到行尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since $(C reduce()) is called with only a single initial value, every task must use that same initial value to initialize its own $(C result) (the parameter $(C 0) above).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083717Z" creationid="Heromyth" creationdate="20170826T083717Z">
        <seg>因为 $(C reduce()) 只有一个初始值，所以每个任务都会使用相同的初始值来初始化 $(C result)（就是之前代码中我们的参数 $(C 0)）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since $(C write) does not output a new-line character, in order to observe the parallel execution of the following program, $(C stdout.flush()) is called to send the contents of the buffer to $(C stdout) even before reaching the end of a line.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024025Z" creationid="Heromyth" creationdate="20170826T024025Z">
        <seg>因为 $(C write) 并不会输出换行符，而为了能够在下面的程序中观察并行执行的情况，我们使用 $(C stdout.flush()) 使缓冲区中的数据能在未到达行尾时就被发送至 $(C stdout)。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since it takes one second for each element, the whole range takes ten seconds to process in this program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T072945Z" creationid="Heromyth" creationdate="20170826T072945Z">
        <seg>因为处理一个元素耗时 1 秒，整个程序总共花费 10 秒。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple grades can be stored in a dynamic array, an associative array that maps from $(C string) to $(C int[]) would work here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T142319Z" creationid="Hipter" creationdate="20160711T014051Z">
        <seg>由于多个成绩可以用一个动态数组存储，从 $(C string) 到 $(C int[]) 映射的关联数组将能用在此处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since one thread executes the $(I synchronized) code at a time, each thread would now swap the values safely before another thread does the same.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000041Z" creationid="Heromyth" creationdate="20170826T000041Z">
        <seg>由于同一时间只有一个执行 $(I synchronized) 代码的线程，我们就可以安全的进行交换。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since that amount is an even number, it is natural to expect that the variables end up having values 1 and 2, their initial values:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235321Z" creationid="Heromyth" creationdate="20170825T235321Z">
        <seg>由于交换总次数一样，我们会很自然的认为交换后的值与初始值相同，即 1 和 2：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since that key is not in the container anymore, the second line would cause an exception to be thrown and the program to be terminated if that exception is not caught.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T033921Z" creationid="Hipter" creationdate="20160709T033921Z">
        <seg>由于键已不存在于容器中， 因而第二行将引发一个异常，如果异常没有被捕获，程序将终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the $(C from) objects correspond to A and B in the two threads respectively, the objects would be in locked state in separate threads, making it impossible for the other thread to ever lock its $(C to) object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001348Z" creationid="Heromyth" creationdate="20170826T001348Z">
        <seg>由于代表 A 和 B 的 $(C from) 对象已分别被两个线程锁住，它们将无法获取另一个线程的 $(C to) 对象（即刚刚被锁住的 B 和 A）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the operating system pauses and starts individual threads in unspecified ways, the behavior of a program that has race conditions is unpredictable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T143649Z" creationid="Heromyth" creationdate="20170825T143649Z">
        <seg>由于操作系统会无法预期地暂停和继续线程的执行，含有竞态条件的程序的行为是无法预期的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the worker has been started by $(C spawnLinked()), the owner is notified of the worker's termination by a $(C LinkTerminated) exception:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052425Z" creationid="Heromyth" creationdate="20170825T052425Z">
        <seg>由于工作线程是通过 $(C spawnLinked()) 启动的，它将通过向所有者线程抛出 $(C LinkTerminated) 异常以通知其工作线程已终止。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is no other variable for $(C variable1)'s original object, that object will be destroyed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031538Z" creationid="Hipter" creationdate="20160706T031538Z">
        <seg>由于 $(C variable1) 的原始对象没有别的变量，该对象将由垃圾回收器销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, the two code blocks would still be accessing the same variable concurrently:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T043111Z" creationid="Heromyth" creationdate="20170826T000518Z">
        <seg>因此，这两块代码还是会同时访问那个变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes regular member functions feel more natural and sometimes properties.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070842Z" creationid="Heromyth" creationdate="20170906T070842Z">
        <seg>有时常规成员函数更加自然，有时特性更加简洁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are defined with double quotes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005323Z" creationid="Hipter" creationdate="20160712T075946Z">
        <seg>字符串字面量用双引号定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are a combination of the two features that we have covered in the last three chapters: characters and arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091043Z" creationid="Hipter" creationdate="20160711T091043Z">
        <seg>字符串是在过去三章中介绍的两种功能的组合：字符和数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such threads are said to be $(I I/O bound) at those times.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232121Z" creationid="Heromyth" creationdate="20170824T232121Z">
        <seg>这种线程被称作 $(I I/O 密集型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tasks are represented by the type $(C std.parallelism.Task).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142118Z" creationid="Heromyth" creationdate="20170826T022050Z">
        <seg>任务的表示类型为 $(C std.parallelism.Task)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Telling the CPU what to do is called $(I coding), and the instructions that are used when doing so are called $(I machine code).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003607Z" creationid="Heromyth" creationdate="20170820T003607Z">
        <seg>告知 CPU 要做什么事情这在过程叫做 $(I 编码)，而何时该做何事的指令则叫做 $(I 机器码)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is the reason why the messages that are printed by $(C aSlowOperation()) are in mixed order in the output above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014336Z" creationid="Heromyth" creationdate="20170826T014336Z">
        <seg>这就是上面程序中 $(C aSlowOperation()) 输出的信息是乱序的原因。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That value can be compared against the expected number of data items so that the input can be validated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144527Z" creationid="Hipter" creationdate="20160712T074124Z">
        <seg>该值可与数据项的预期数相比较，以便确定输入的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T121050Z" creationid="Hipter" creationdate="20160711T120306Z">
        <seg>这个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C dmd) compiler switch to enable warnings as errors is $(C -w).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005309Z" creationid="Heromyth" creationdate="20170820T005309Z">
        <seg>编译器 $(C dmd) 将警告视作错误的编译选项是 $(C -w)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C icmp()) function of the $(C std.string) module can be used when strings need to be compared regardless of lowercase and uppercase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143727Z" creationid="大处着手小处着眼" creationdate="20160715T143727Z">
        <seg>无论小写大写，$(C std.string) 模块中的 $(C icmp()) 函数可用于字符串比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C king) variable does not have a $(C shape) member, the anonymous object does.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004408Z" creationid="Hipter" creationdate="20160707T004408Z">
        <seg>$(C king) 变量并没有 $(C shape) 成员，匿名对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C length) property of a slice returns the number of elements of that slice:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043411Z" creationid="Heromyth" creationdate="20170905T043411Z">
        <seg>分片的 $(C length) 特性返回了其包含元素的个数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C new) keyword constructs an anonymous $(I class object) and returns a $(I class variable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015858Z" creationid="Hipter" creationdate="20160707T015858Z">
        <seg>The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual concept that a class type represents in a program is provided by a class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131148Z" creationid="Heromyth" creationdate="20170819T131148Z">
        <seg>实际的概念是，在程序中，一个类类型由一个类对象表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual object is not copied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012852Z" creationid="Hipter" creationdate="20160706T012821Z">
        <seg>实际的对象没有被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The attributes are determined by $(C __traits(getAttributes)) at compile time and the code is compiled according to those attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043355Z" creationid="Heromyth" creationdate="20170804T043355Z">
        <seg>编译时可以通过 $(C __traits(getAttributes)) 来判定属性，而相应代码则会根据那些属性来编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The buffer size that produces the best performance would be different under different situations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073252Z" creationid="Heromyth" creationdate="20170826T073252Z">
        <seg>能使程序获得最大性能的缓冲区大小会随着使用情况的不同而有所不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The calculations that are performed sequentially are highlighted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084054Z" creationid="Heromyth" creationdate="20170826T084054Z">
        <seg>被高亮的部分为串行运算的输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call to $(C core.thread.thread_joinAll) above is to make a thread wait for all of its child threads to terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235121Z" creationid="Heromyth" creationdate="20170825T235121Z">
        <seg>所以，我们调用 $(C core.thread.thread_joinAll) 函数阻塞主线程来等待子线程执行完毕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters of the variables that are defined by these aliases cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T145527Z" creationid="Hipter" creationdate="20160712T081806Z">
        <seg>由这些别名定义的变量中的字符不可修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler does not allow accessing characters of an immutable array through a mutable slice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025135Z" creationid="Hipter" creationdate="20160713T025135Z">
        <seg>编译器不允许通过可变的切片访问不可变的字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concepts of $(I less) and $(I greater) are replaced with $(I before) and $(I after) in this hypothetical alphabet:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063636Z" creationid="大处着手小处着眼" creationdate="20160715T035221Z">
        <seg>在这个假设的字母表中，$(I 更少)和$(I 更多)的概念就被$(I 之前)和$(I 之后)代替：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value is specified as the second parameter of $(C .get()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042602Z" creationid="Hipter" creationdate="20160709T042602Z">
        <seg>默认值被指定为 $(C .get()) 的第2个参数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value of the number of threads is one less than the number of cores on the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T142500Z" creationid="Heromyth" creationdate="20170826T090327Z">
        <seg>默认的线程数量比系统内核数少 1。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of those variables were the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T015831Z" creationid="大处着手小处着眼" creationdate="20160719T100148Z">
        <seg>下面各项是这些变量的定义：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The delegate that matches the type of the particular message handles it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T020307Z" creationid="Heromyth" creationdate="20170824T235938Z">
        <seg>如果委托参数的类型与消息类型相同，则把消息交由对应的委托处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference is that it is the type of the key that is specified within the square brackets, not the length of the array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093513Z" creationid="Hipter" creationdate="20160708T095042Z">
        <seg>不同的是方框号中指定的是键的类型，而不是数组的长度：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The execution of each thread may involve many cycles of starting and suspending.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014307Z" creationid="Heromyth" creationdate="20170826T014307Z">
        <seg>每个线程的执行都可能包含多轮启动和挂起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that the $(C m) and $(C t) letters are printed in mixed order indicates that the operations are executed in parallel:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143510Z" creationid="Heromyth" creationdate="20170826T034325Z">
        <seg>字符 $(C m) 和字符 $(C t) 交替输出表明这些操作是并行执行的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The features of the $(C std.parallelism) module make it possible for programs to take advantage of all of the cores in order to run faster.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124740Z" creationid="Heromyth" creationdate="20170826T012554Z">
        <seg>灵活使用模块 $(C std.parallelism) 中的功能来尽可能地利用所有内核的运算能力，使程序能以更快的速度运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two are with the $(C while) loops: Both of the loop conditions use the $(C &lt;=) operator instead of the $(C &lt;) operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084426Z" creationid="大处着手小处着眼" creationdate="20160726T031012Z">
        <seg>前两个与 $(C while) 循环有关： 循环条件都使用 $(C &lt;=) 运算符而不使用 $(C &lt;) 运算符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following $(C static assert) checks both pass because $(C Person.name) has $(C Colored(Color.blue)) attribute:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104835Z" creationid="Heromyth" creationdate="20170810T104835Z">
        <seg>下面的两个 $(C static assert) 都会顺利通过，因为 $(C Person.name) 拥有 $(C Colored(Color.blue)) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following $(C static assert) passes because $(C Person.name) has $(C Encrypted) attribute:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104459Z" creationid="Heromyth" creationdate="20170810T104459Z">
        <seg>下面的 $(C static assert) 会顺利通过，因为 $(C Person.name) 拥有 $(C Encrypted) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code demonstrates this for the $(C OwnerTerminated) exception:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052534Z" creationid="Heromyth" creationdate="20170825T052534Z">
        <seg>下面的代码演示了如何传递 $(C OwnerTerminated) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following equivalents of the $(C incrementer()) and $(C decrementer()) functions that use $(C atomicOp) are correct as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003418Z" creationid="Heromyth" creationdate="20170826T003138Z">
        <seg>下面是$(C incrementer()) 和 $(C decrementer()) 函数使用 $(C atomicOp) 之后的等效情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example starts a task that executes a lambda:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T034723Z" creationid="Heromyth" creationdate="20170826T034723Z">
        <seg>下面这个例子就是让任务执行了一个 lambda 函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following function considers the $(C Encrypted) and $(C Colored) attributes of each member when producing the output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103912Z" creationid="Heromyth" creationdate="20170814T103912Z">
        <seg>下面这个函数在生成输出内容时会使用到每个成员的 $(C Encrypted) 和 $(C Colored) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following message consists of three parts:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233343Z" creationid="Heromyth" creationdate="20170824T233343Z">
        <seg>下面这个消息就是由三个部分组成：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods would empty the array in a single step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120214Z" creationid="Hipter" creationdate="20160711T012406Z">
        <seg>而下面的方法将用一步清空数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program also defines a special type named $(C Exit) used for communicating to the thread that it is time for it to exit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000525Z" creationid="Heromyth" creationdate="20170825T000525Z">
        <seg>程序还定义了一个 $(C Exit) 类型来通知线程退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program defines an empty class named $(C Lock) to use its objects as locks:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000939Z" creationid="Heromyth" creationdate="20170826T000939Z">
        <seg>下面这个程序定义了一个空的 $(C Lock) 类作为锁：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program sends the reason of the failure as a $(C CalculationFailure) message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045116Z" creationid="Heromyth" creationdate="20170825T045116Z">
        <seg>下面这个程序就把出错的原因封装在 $(C CalculationFailure) 消息中传递回去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program uses $(C map()) to call the $(C averageGrade()) member function on each element:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073940Z" creationid="Heromyth" creationdate="20170826T073940Z">
        <seg>下面这个程序使用 $(C map()) 来调用每一个元素的成员函数 $(C averageGrade())：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following worker handles messages by lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000458Z" creationid="Heromyth" creationdate="20170825T000458Z">
        <seg>下面这个工作线程使用 lambda 函数处理消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function parameters that are</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024737Z" creationid="Heromyth" creationdate="20170826T024737Z">
        <seg>在此处被指定的函数实参</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grades can be appended to the dynamic arrays that are stored in the associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T014729Z" creationid="Hipter" creationdate="20160711T014729Z">
        <seg>成绩能附加到存储在关联数组中的动态数组上：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial value of the elements depends on the type of the elements: 0 for $(C int), $(C double.nan) for $(C double), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082740Z" creationid="大处着手小处着眼" creationdate="20160725T082636Z">
        <seg>元素的初始值取决于元素类型：$(C int) 的为 0，$(C double) 的为 $(C double.nan) 等等。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intermediate owner thread below simply exits after sending two messages to its worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052047Z" creationid="Heromyth" creationdate="20170825T052047Z">
        <seg>下方程序中处在中间层的线程所有者在发送两条消息后就立即退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lengths of those arrays cannot be changed during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033144Z" creationid="大处着手小处着眼" creationdate="20160725T033144Z">
        <seg>在程序的执行过程中数组的长度不可修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference between a thread that is started with $(C spawn()) and a thread that is started with $(LINK2 /ders/d.en/parallelism.html, $(C task())) is the fact that $(C spawn()) makes it possible for threads to send messages to each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054618Z" creationid="Heromyth" creationdate="20170824T054618Z">
        <seg>使用 $(C spawn()) 启动的线程和使用 $(LINK2 /ders/d.en/parallelism.html, $(C task())) 启动的线程之间最大的差异在于，$(C spawn()) 允许线程间消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference between the two is that their function parameters are reversed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T075302Z" creationid="Heromyth" creationdate="20170826T075302Z">
        <seg>两者的不同点在于它们的形参顺序正好相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The member variables can only be modified by the $(C Rectangle) type itself to ensure the consistency of its objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T071120Z" creationid="Heromyth" creationdate="20170906T071120Z">
        <seg>只有 $(C Rectangle) 的成员函数能修改成员变量可以保证对象的一致性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The movement of each robot is handled by a separate thread that takes three pieces of information when started:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234136Z" creationid="Heromyth" creationdate="20170824T234136Z">
        <seg>每个机器人的移动都是由一个独立的线程控制的。线程在启动时需要传入三个参数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of elements of an array is called the $(I length) of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143218Z" creationid="大处着手小处着眼" creationdate="20160723T142830Z">
        <seg>数组元素的个数称为数组的 $(I length)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of messages in a mailbox may increase or decrease depending on how long it takes for the thread to receive and respond to each message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134343Z" creationid="Heromyth" creationdate="20170825T134343Z">
        <seg>邮箱中的消息个数会随着程序接收和处理消息的速度而有所变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is that it executes the function calls semi-eagerly and stores the results in a buffer to be served from as needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074143Z" creationid="Heromyth" creationdate="20170826T074128Z">
        <seg>唯一不同的是 $(C taskPool.map()) 是以半延迟取值的方式调用函数操作元素，并将结果储存在缓冲区中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is that the number of values associated with the variable is specified in square brackets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T043657Z" creationid="大处着手小处着眼" creationdate="20160720T022710Z">
        <seg>唯一的区别是，与变量相关联的值的个数在方括号中指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operating system decides when and under what condition to start and suspend each thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014324Z" creationid="Heromyth" creationdate="20170826T014324Z">
        <seg>操作系统将会决定在合适何种情况启动或挂起线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operating system starts and executes each thread on a core and then suspends it to execute other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014258Z" creationid="Heromyth" creationdate="20170826T014258Z">
        <seg>操作系统可在一个核心上启动和执行线程，在需要时将其挂起来让出核心运算资源去执行另一个线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other differences outlined below are mostly due to this fact.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124126Z" creationid="Heromyth" creationdate="20170819T124126Z">
        <seg>下面的其它不同大部分与此有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the program shows that the two threads, one that runs $(C main()) and the other that has been started by $(C spawn()), execute independently at the same time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054941Z" creationid="Heromyth" creationdate="20170824T054941Z">
        <seg>这个程序的输出表明有两个线程：一个用于运行 $(C main())，另一个则由 $(C spawn()) 启动。它们同时相互独立地执行：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The overall performance of the system can be reduced if there are more threads that are busily working than the number of cores in the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T002913Z" creationid="Heromyth" creationdate="20170824T232021Z">
        <seg>如果处于忙碌中的工作线程的数量超过系统内核的数量，那么系统的整体性能有可能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The owner can use the exception object or simply rethrow it:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051851Z" creationid="Heromyth" creationdate="20170825T051851Z">
        <seg>所有者既可以处理异常对象也可以重新抛出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The owner simply prints every movement:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234549Z" creationid="Heromyth" creationdate="20170824T234549Z">
        <seg>所有者会简单地将其运动情况输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program above would require a single change: replacing 5 with 20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T081214Z" creationid="大处着手小处着眼" creationdate="20160725T081214Z">
        <seg>修改一下上面的程序：用 20 替换 5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program calls two functions with the address of the same variable, one function incrementing and the other function decrementing it equal number of times:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T042537Z" creationid="Heromyth" creationdate="20170826T000410Z">
        <seg>程序会将同一个变量的地址传递给这两个函数：一个函数将其加 1，一个函数将其减 1，加减次数相同：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program can safely continue after the $(C foreach) loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014634Z" creationid="Heromyth" creationdate="20170826T014634Z">
        <seg>在 $(C foreach) 循环完成后，程序可以安全地继续执行下面的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program is free to start other threads to be able to work on multiple tasks at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012518Z" creationid="Heromyth" creationdate="20170824T012518Z">
        <seg>程序也可以自由地创建线程以实现在同一时间执行多个任务的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program is written to read five numbers from the input and to place the squares of those numbers into an array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024424Z" creationid="大处着手小处着眼" creationdate="20160726T024424Z">
        <seg>程序要求从输入流中读取五个数字，并把这些数字放入一个数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program then attempts to print the squares to the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024527Z" creationid="大处着手小处着眼" creationdate="20160726T024527Z">
        <seg>然后程序会输出这些平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program would take less time if other elements could be produced while the front element is in use:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073121Z" creationid="Heromyth" creationdate="20170826T073121Z">
        <seg>如果能在上一个元素被使用时就开始计算下一个元素，那程序消耗的时间就会大大减小。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program would work correctly with the following change:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235958Z" creationid="Heromyth" creationdate="20170825T235921Z">
        <seg>经过下面的修改之后程序能正确执行：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The programming model that supports threads that depend on other threads is called $(I concurrency).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T134030Z" creationid="Heromyth" creationdate="20170826T014430Z">
        <seg>支持线程依赖的编程模型叫做$(I 并发（concurrency）)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The results of individual functions correspond to the elements of the tuple in the order that the functions are specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085104Z" creationid="Heromyth" creationdate="20170826T085104Z">
        <seg>传入函数的顺序将决定 tuple 中与之对应的结果的顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same operators can be used with strings as well, but with a different meaning: strings are ordered $(I lexicographically).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063719Z" creationid="大处着手小处着眼" creationdate="20160715T034841Z">
        <seg>同样的操作也能用于字符串，但含义不同：字符串按$(I 字典顺序)排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second line is the definition of a variable which stores ten consecutive values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T023429Z" creationid="大处着手小处着眼" creationdate="20160720T023429Z">
        <seg>第二行定义了一个存储连续十个值的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sender may have been busy temporarily or may have terminated with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043234Z" creationid="Heromyth" creationdate="20170825T043234Z">
        <seg>消息的发送者可能正在忙碌或因异常终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The size of this buffer is determined by the second parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074139Z" creationid="Heromyth" creationdate="20170826T074139Z">
        <seg>缓冲区的大小由第二个形参决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The solution is to reset $(C i) to 0 before the second $(C while) loop, for example with the statement $(C i = 0;)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032827Z" creationid="大处着手小处着眼" creationdate="20160726T032827Z">
        <seg>解决办法就是在第二个 $(C while) 循环前重设 $(C i) 为 0，比如使用语句 $(C i = 0;)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The state of the variables $(C i) and $(C j) would always be either "1 and 2" or "2 and 1" at the end of processing the synchronized block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T000107Z" creationid="Heromyth" creationdate="20170826T000107Z">
        <seg>在同步块执行后 $(C i) 与 $(C j) 只会有种情况：要么是“1 and 2”，要么是“2 and 1”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The template parameter must be a $(I binary operator) like $(STRING "+"), $(STRING "+="), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003049Z" creationid="Heromyth" creationdate="20170826T003049Z">
        <seg>它的模版参数必须是一个$(I 二元运算符)，如 $(STRING "+")、$(STRING "+=") 等。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third parameter is the work unit size as in $(C parallel()); the difference being its default value, which is $(C size_t.max):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074645Z" creationid="Heromyth" creationdate="20170826T074645Z">
        <seg>第三个参数为工作单元大小，与 $(C parallel()) 中对应的参数作用相同但默认值不同；此处它的默认值为 $(C size_t.max)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thread may be paused at any point between these steps to be continued after an unpredictable time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054031Z" creationid="Heromyth" creationdate="20170824T054031Z">
        <seg>线程可能会暂停在这三步中的任何一步上，停顿一段时间后才会继续。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The threads continue sending messages back and forth until the owner sends a negative $(C int).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T014838Z" creationid="Heromyth" creationdate="20170824T233003Z">
        <seg>工作线程会不停地返回消息，一直到所有者线程发送一个 $(C int) 型的负数为止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The threads in the following program receive the addresses as two variables and swap their values a large number of times:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235211Z" creationid="Heromyth" creationdate="20170825T235211Z">
        <seg>这些线程将会收到两个变量的地址，并将它们的值对调。对调过程将执行多次：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T132015Z" creationid="Hipter" creationdate="20160706T021711Z">
        <seg>这两个变量可访问同一个对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two worker threads in the following program print four numbers each.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T002637Z" creationid="Heromyth" creationdate="20170824T055246Z">
        <seg>下面程序中的两个工作线程分别输出四个数字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the member is encrypted if it has that attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042355Z" creationid="Heromyth" creationdate="20170815T042355Z">
        <seg>如果该成员拥有此属性，则它的值会被加密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that is used on the right-hand side of the assignment becomes the only parameter of this function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053855Z" creationid="Heromyth" creationdate="20170906T053855Z">
        <seg>等号右侧的值将作为函数唯一的参数传入函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of the type that associative arrays $(I map from) are called $(I keys), rather than indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023157Z" creationid="Hipter" creationdate="20160708T090042Z">
        <seg>关联数组用于$(I 映射)的类型的值叫$(I 键)，而不是索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that we have numbered as 1, 2, 3, 4, and 5 before are numbered as 0, 1, 2, 3, and 4 in the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T024332Z" creationid="大处着手小处着眼" creationdate="20160724T024332Z">
        <seg>以前被我们编号为 1、2、3、4 和 5 的值在数组中编号为 0、1、2、3 和 4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The work unit size determines the number of elements that each thread should execute at each of its iterations:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T142012Z" creationid="Heromyth" creationdate="20170826T020333Z">
        <seg>工作单元大小决定了每个线程在每次迭代时应该执行的元素个数。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker in the following program sends messages back to back but the owner spends some time for each message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134814Z" creationid="Heromyth" creationdate="20170825T134814Z">
        <seg>下面这个工作线程会不停地向主线程发送消息，但主线程处理消息的速度就没有工作线程这么快了，每条消息主线程都会花费一点时间来处理：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker thread above can be tested by the following program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000304Z" creationid="Heromyth" creationdate="20170825T000304Z">
        <seg>上面的工作线程可以用下面程序来测试：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their curly brackets are highlighted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000641Z" creationid="Heromyth" creationdate="20170825T000641Z">
        <seg>它们的花括号已被高亮：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four choices for the last parameter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134443Z" creationid="Heromyth" creationdate="20170825T134443Z">
        <seg>最后一个参数有四个选项：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There would be a compilation error without that free-standing function:
))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074534Z" creationid="Heromyth" creationdate="20170826T074534Z">
        <seg>如果不使用独立的函数的话，程序将不能通过编译：
))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These algorithms should be used only when the operations that are to be executed $(I in parallel) are truly independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124259Z" creationid="Heromyth" creationdate="20170826T012621Z">
        <seg>只有当元素操作之间没有相互依赖时，它们才能被 $(I 并行) 执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These final calculations are executed sequentially, not in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083925Z" creationid="Heromyth" creationdate="20170826T083925Z">
        <seg>这个最终的计算是顺序执行的，而非并行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These languages have traditionally been used with an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004705Z" creationid="Heromyth" creationdate="20170820T004705Z">
        <seg>因此，这些语言传统上就需使用解释器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These limits can be set for each user, for the whole system, or for something else.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T231902Z" creationid="Heromyth" creationdate="20170824T231902Z">
        <seg>这种限制可能是对用户的，也可能是对整个操作系统的，当然也可能是对其他某些级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These machine code instructions are determined under hardware constraints during the design stage of the architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003643Z" creationid="Heromyth" creationdate="20170820T003643Z">
        <seg>而这些机器码指令取决于底层架构设计阶段时的硬件约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These messages are handled before the other messages that are already in the mailbox:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135141Z" creationid="Heromyth" creationdate="20170825T135141Z">
        <seg>这些高优先级消息会比其他邮箱中的消息先被处理：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These threads continuously send messages to each other until instructed to terminate by an $(C Exit) message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T135519Z" creationid="Heromyth" creationdate="20170825T135519Z">
        <seg>线程会不停地互相发送信息，只有在收到 $(C Exit) 消息后它们才会终止：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three functions are explained further in the comments of the following program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T022421Z" creationid="Heromyth" creationdate="20170826T022421Z">
        <seg>在下方程序的注释中有对这三个函数详细的解释。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are defined by the $(C @property) attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044409Z" creationid="Heromyth" creationdate="20170906T044409Z">
        <seg>所需的额外工作就是在函数的前面加一个 $(C @property)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are instead stored in an output buffer until a line of output is completed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024011Z" creationid="Heromyth" creationdate="20170826T024011Z">
        <seg>它们将会被储存在输出缓冲区中，一直到整行输出完成为止都会显示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are very fast data structures that work like mini databases and are used in many programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233259Z" creationid="Hipter" creationdate="20160708T015014Z">
        <seg>它们是高速的数据结构，如迷你数据库一样地运作，在很多程序里都用到了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can execute different parts of different programs at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T124715Z" creationid="Heromyth" creationdate="20170826T012542Z">
        <seg>它们可同时执行不同程序的不同部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They grow automatically as key-value pairs are added.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T143053Z">
        <seg>它们随着键值对的添加而自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They map the values of one type to the values of another type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085824Z" creationid="Hipter" creationdate="20160708T085824Z">
        <seg>它们映射一种类型的值到另一种类型的值上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They take the starting number as the thread function parameter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055311Z" creationid="Heromyth" creationdate="20170824T055311Z">
        <seg>线程函数的参数为初始数字：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the owner to catch such exceptions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044642Z" creationid="Heromyth" creationdate="20170825T044642Z">
        <seg>它使得所有者线程可以捕获工作线程的异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This array is used to hold the number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025543Z" creationid="大处着手小处着眼" creationdate="20160724T025543Z">
        <seg>这个数组用于存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020610Z" creationid="Hipter" creationdate="20160707T020610Z">
        <seg>该行为不能被修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be demonstrated by printing the entire table:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T145930Z" creationid="Hipter" creationdate="20160708T145930Z">
        <seg>这可以通过打印整个表来验证：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This causes an $(C OwnerTerminated) exception to be thrown at the worker thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052101Z" creationid="Heromyth" creationdate="20170825T052101Z">
        <seg>这会导致工作线程抛出 $(C OwnerTerminated) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This cost may sometimes be significant especially when the operations of the loop are completed in a very short time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T141542Z" creationid="Heromyth" creationdate="20170826T015851Z">
        <seg>但在某些情况下这种开销会显得极其昂贵，尤其是在每次循环的操作耗时都非常短的时候。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction has an important consequence when  $(LINK2 /ders/d.en/function_parameters.html, passing associative arrays to functions).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144154Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>当 $(LINK2 /ders/d.cn/function_parameters.html, 传关联数组给函数) 时，这种区分具有重要意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction may be undesirable in certain situations where seemingly $(I equivalent) task objects would actually have different types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143531Z" creationid="Heromyth" creationdate="20170826T034427Z">
        <seg>两个看起来 $(I 相同) 的任务对象实际上不是同一个类型，在某些特定的情况下这种差别可能是我们不想看到的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fact can be observed by printing both the values and the addresses of the variables:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T042057Z" creationid="Heromyth" creationdate="20170825T145046Z">
        <seg>从这些变量的值和地址输出可以看出来：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fact is reflected in the $(C .length) property of strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T012504Z" creationid="大处着手小处着眼" creationdate="20160714T012504Z">
        <seg>这个事实反映在字符串的 $(C .length) property 上：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function must create and return a new class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022554Z" creationid="Hipter" creationdate="20160706T022554Z">
        <seg>该函数必须创建并返回一个新的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an important difference that affects the way attributes are used at compile time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T055247Z" creationid="Heromyth" creationdate="20170803T055247Z">
        <seg>它们有着明显的差异，它会对编译时属性的使用方式产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because garbage collectors are not required to guarantee that the object and its members are finalized in any specific order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001705Z" creationid="Heromyth" creationdate="20170820T001705Z">
        <seg>这是因为垃圾回收器没有被要求保证该对象及其成员按任何特定顺序终结。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because garbage collectors are not required to guarantee that they can allocate new objects during a garbage collection cycle.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001831Z" creationid="Heromyth" creationdate="20170820T001831Z">
        <seg>这是因为垃圾回收器没有被要求保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because later code may depend on previous variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045157Z" creationid="Hipter" creationdate="20160707T045157Z">
        <seg>这是因为后边的代码依赖于前边的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not possible nor necessary when a single array stores all the values under a single name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T022048Z" creationid="大处着手小处着眼" creationdate="20160724T021904Z">
        <seg>让一个数组在一个名字下存储所有的值，那是不可能也没必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that the program has a way of determining whether the input consisted of a complete line or whether the end of input has been reached:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T020302Z" creationid="Hipter" creationdate="20160712T020302Z">
        <seg>这就让程序有办法确定输入是否包含一条完整语句或者输入是否已结束： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the owner thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T015230Z" creationid="Heromyth" creationdate="20170824T233119Z">
        <seg>下面是所有者线程：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it possible for the main thread to catch exceptions that are thrown by a task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T144601Z" creationid="Heromyth" creationdate="20170826T034947Z">
        <seg>这样便可以在主线程里捕获任务中抛出的各种异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be seen as a limitation for some applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085053Z" creationid="Hipter" creationdate="20160709T085053Z">
        <seg>对某些程序来说可能是个限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all of the non-static member functions of that type are synchronized on a given object of that class:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001131Z" creationid="Heromyth" creationdate="20170826T001131Z">
        <seg>即表示同一时间只能有一个线程调用类的示例对象的非静态成员函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ordering takes each character's Unicode code to be its place in a hypothetical grand Unicode alphabet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T035023Z" creationid="大处着手小处着眼" creationdate="20160715T035023Z">
        <seg>这种排序需要在一个假设的大字母表中让每个字符的 Unicode 编码找到它的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produced program is responsible for the execution of the instructions that were written by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004745Z" creationid="Heromyth" creationdate="20170820T004745Z">
        <seg>而后，这个被生成的程序负责执行程序员写就的指令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This range simply produces integers up to the specified limit:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T072622Z" creationid="Heromyth" creationdate="20170826T072622Z">
        <seg>这个范围的作用就是提供一个不高于指定上限的整数。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This result will be used later in main.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024538Z" creationid="Heromyth" creationdate="20170826T024144Z">
        <seg>稍后会在 main 函数中使用这个结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This situation is called a $(I deadlock).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001400Z" creationid="Heromyth" creationdate="20170826T001400Z">
        <seg>这个现象就是$(I 死锁)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This undeterministic order of thread execution may not matter if the operations of the $(C Student) objects are truly independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014344Z" creationid="Heromyth" creationdate="20170826T014344Z">
        <seg>如果对 $(C Student) 对象的操作是相互独立的，那以一种不确定的顺序执行线程也不会有什么副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variation can confuse new programmers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T104312Z" creationid="大处着手小处着眼" creationdate="20160724T024418Z">
        <seg>这种变化可能会让编程新手感到困惑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thread.sleep(500.msecs);  /* half a second */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T024654Z" creationid="Heromyth" creationdate="20170826T024654Z">
        <seg>Thread.sleep(500.msecs);  /* 半秒 */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid dealing with this and many other Unicode issues, consider using a Unicode-aware text manipulation library in your programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152807Z" creationid="大处着手小处着眼" creationdate="20160715T014621Z">
        <seg>为避免处理这种以及许多其它的 Unicode 问题，在你的程序里就要考虑使用一个支持 Unicode 的文本处理库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be compatible with arrays, this function may be named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022458Z" creationid="Hipter" creationdate="20160706T022458Z">
        <seg>为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To change their lengths, the source code must be modified and the program must be recompiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033354Z" creationid="大处着手小处着眼" creationdate="20160725T033229Z">
        <seg>要修改长度，就必须修改源代码，而且程序必须重新编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To demonstrate how parallel algorithms are faster, let's again slow this function down with $(C Thread.sleep()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073849Z" creationid="Heromyth" creationdate="20170826T073849Z">
        <seg>为了能够突出并行算法的速度，我们还是使用 $(C Thread.sleep()) 让整个过程消耗更多的时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable this functionality, we can assume that the rectangle is $(I flexible) so that to maintain the invariant of "width * height == area", the sides of the rectangle can be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T053646Z" creationid="Heromyth" creationdate="20170906T053646Z">
        <seg>为了能够提供这样的功能，我们假设矩形的边长是$(I 可变的)。如此一来，为保持恒等式“长 × 宽 == 面积”成立，可以更改该矩形的各条边。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To identify those separate variables, they are renamed as $(C tempA) and $(C tempB) below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235558Z" creationid="Heromyth" creationdate="20170825T235558Z">
        <seg>为了区分这两个 $(C temp)，我们将其分别称为 $(C tempA) 和 $(C tempB)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent that, the owner may limit the size of its mailbox before starting the worker:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T024437Z" creationid="Heromyth" creationdate="20170825T134940Z">
        <seg>为了防止出现这种情况，所有者线程会在启动工作线程之前限制其邮箱的大小：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reduce this complexity, it is possible to assign names to threads, which are globally accessible from any thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T024819Z" creationid="Heromyth" creationdate="20170825T135258Z">
        <seg>为了降低复杂度，可以为线程分配一个命名——所有线程都可以通过名字访问该线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat the value &lt;span style="white-space: nowrap"&gt;-1&lt;/span&gt; specially to determine the end of the numbers; do not process that value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051620Z" creationid="大处着手小处着眼" creationdate="20160726T022945Z">
        <seg>并专门用值 &lt;span style="white-space: nowrap"&gt;-1&lt;/span&gt; 来确定数字的结束；不处理该值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, $(C addend) is accessible only in the $(C try) block, where it is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022824Z" creationid="Hipter" creationdate="20160707T022824Z">
        <seg>不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structs, class objects cannot be constructed by the $(C {&amp;nbsp;}) syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032515Z" creationid="Hipter" creationdate="20160706T032515Z">
        <seg>不像结构，类对象不能由 $(C {&amp;nbsp;}) 语法构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User defined attributes is purely a compile-time feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T041606Z" creationid="Heromyth" creationdate="20170720T041606Z">
        <seg>自定义属性完全是一项编译时功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an array in a way that would require allocating a new memory block for the elements is undefined behavior as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002426Z" creationid="Heromyth" creationdate="20170820T002426Z">
        <seg>用这种方式使用一个数组，那将需要为未定义行为的元素分配一个新的内存块：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using such a specific type is more expressive than sending the arbitrary value of -1 like it was done in the previous example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000550Z" creationid="Heromyth" creationdate="20170825T000550Z">
        <seg>相对于使用像 -1 这样的任意值，用一个特定的类型来传递特定的消息会让程序更易读。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables which only store a single value are called scalar variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044240Z" creationid="大处着手小处着眼" creationdate="20160720T030929Z">
        <seg>只存储一个值的变量称为标量变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can contrast the two definitions as follows:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022850Z" creationid="大处着手小处着眼" creationdate="20160720T022850Z">
        <seg>我们可以对比两种定义如下：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can see this in the output above by the fact that $(C worker()) continues executing even after $(C main()) exits after printing "main is done."
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055208Z" creationid="Heromyth" creationdate="20170824T055208Z">
        <seg>从上面的输出中我们可以看到，在函数 $(C main()) 输出 “main is done.” 并退出之后，$(C worker()) 仍然在继续执行。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have already seen this above when assigning to an element of an array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083358Z" creationid="大处着手小处着眼" creationdate="20160725T083358Z">
        <seg>这在上面给数组的元素赋值时我们已经看到：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have seen the $(C Tuple) type in the $(LINK2 /ders/d.en/tuples.html, Tuples chapter) before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T085050Z" creationid="Heromyth" creationdate="20170826T085050Z">
        <seg>我们之前已经在 $(LINK2 /ders/d.cn/tuples.html, Tuples) 一章中了解过 $(C Tuple)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011230Z" creationid="Hipter" creationdate="20160711T011230Z">
        <seg>在下一章我们将</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover message passing in this chapter and data sharing in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T222401Z" creationid="Heromyth" creationdate="20170824T012330Z">
        <seg>本章主要讲解消息传递，而数据共享则被放置到下一章。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover the $(C pure) keyword in $(LINK2 /ders/d.en/functions_more.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013623Z" creationid="Heromyth" creationdate="20170819T134146Z">
        <seg>我们会在$(LINK2 /ders/d.cn/functions_more.html, 后面章节)对关键字 $(C pure) 进行讲解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover these concepts in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030254Z" creationid="Hipter" creationdate="20160708T144231Z">
        <seg>在稍后的章节中我们将涵盖这些概念。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see Phobos ranges in a later chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T124954Z" creationid="大处着手小处着眼" creationdate="20160714T094241Z">
        <seg>在稍后的一章中我们将看到 Phobos 的 range。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see an example of this difference below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T055422Z" creationid="Heromyth" creationdate="20170803T055422Z">
        <seg>下面来看一个与该差异有关的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see exceptions in $(LINK2 /ders/d.en/exceptions.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034341Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>在 $(LINK2 /ders/d.cn/exceptions.html, 稍后的一章) 中我们将看到异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see in $(LINK2 /ders/d.en/inheritance.html, the next chapter) how the definition of $(C toString) can be changed by the $(C override) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013604Z" creationid="Hipter" creationdate="20160707T013604Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see only two of its functions in this chapter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002932Z" creationid="Heromyth" creationdate="20170826T002932Z">
        <seg>本章我们只会接触到其中两种：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233855Z" creationid="Heromyth" creationdate="20170824T233855Z">
        <seg>随后就会看到这个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this concept later in $(LINK2 /ders/d.en/inheritance.html, the Inheritance chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T011019Z" creationid="Hipter" creationdate="20160707T005801Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this in a later chapter.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013507Z" creationid="大处着手小处着眼" creationdate="20160726T013507Z">
        <seg>我们将在后面的章节中看到这一点。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see user-defined types in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141854Z" creationid="Hipter" creationdate="20160708T141751Z">
        <seg>在稍后的章节中我们将看到用户定义类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use the $(C dayNumbers) associative array in the examples below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141603Z" creationid="Hipter" creationdate="20160708T141603Z">
        <seg>在下面的例子中我们将使用 $(C dayNumbers) 关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a message arrives, it is compared to the message type of each delegate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170827T020143Z" creationid="Heromyth" creationdate="20170824T235924Z">
        <seg>当接收到消息时，它会将消息类型与每个委托的类型进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a worker that has been started by $(C spawnLinked()) terminates, a $(C LinkTerminated) exception is thrown at the owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052327Z" creationid="Heromyth" creationdate="20170825T052327Z">
        <seg>当由 $(C spawnLinked()) 创建的线程终止时，拥有者线程将会抛出 $(C LinkTerminated) 异常。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When accessing elements, the $(C []) characters are written after the name of the array and specify the number of the element that is being accessed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025224Z" creationid="大处着手小处着眼" creationdate="20160724T025224Z">
        <seg>访问元素时，$(C []) 写在数组名称之后，并指定要访问的元素位置数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When both of the width and the height of the rectangle are scaled by the square root of the ratio, then the area would equal the desired value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T070655Z" creationid="Heromyth" creationdate="20170906T070655Z">
        <seg>如果长和宽都是面积的平方根，那它们的乘积就一定是我们指定的面积。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining arrays, the $(C []) characters are written after the type of the elements and specify the number of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025046Z" creationid="大处着手小处着眼" creationdate="20160724T025046Z">
        <seg>当我们定义数组时，$(C []) 写在元素类型之后，并指定元素个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When no initial value is specified, the first element of the range is used instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T151455Z" creationid="Heromyth" creationdate="20170826T075410Z">
        <seg>如果没有指定初始值，它会把范围的第一个元素作为初始值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading strings from the input, the control character that corresponds to the Enter key that is pressed at the end of the input becomes a part of the string as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144811Z" creationid="Hipter" creationdate="20160711T092900Z">
        <seg>当从输入中读取字符串，输入结束时按的 Enter 键对应的控制字符将变成字符串的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that exact syntax is desired, properties should be preferred, which will be explained in $(LINK2 /ders/d.en/property.html, a later chapter).)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004716Z" creationid="Hipter" creationdate="20160707T004716Z">
        <seg>若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that is the case, the microprocessor would execute operations like the increments above in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T012903Z" creationid="Heromyth" creationdate="20170826T012903Z">
        <seg>当出现这种情况时，微处理器会并行处理上面那样的自增操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the length can change during the execution of the program, that array is a $(I dynamic array).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T085342Z" creationid="大处着手小处着眼" creationdate="20160725T032258Z">
        <seg>当长度可以在程序的执行过程中进行修改时，该数组就是一个$(I 动态数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whether $(C i) or $(C j) is modified at each step is indicated by highlighting that variable:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T235652Z" creationid="Heromyth" creationdate="20170825T235652Z">
        <seg>按照从上到下的顺序，操作 1 第一个执行，操作 6 最后一个执行。高亮的步骤修改了 $(C i) 和 $(C j)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also think of it as defining ten variables of the same type, or as defining an array, for short.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T024941Z" creationid="大处着手小处着眼" creationdate="20160720T024926Z">
        <seg>你也可以把它定义为同类型的十个变量，或作为数组定义的简称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply this guideline blindly unless there are compilation errors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051126Z" creationid="Hipter" creationdate="20160707T012523Z">
        <seg>若没有编译错误，您可以闭着眼睛按教程来：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can determine whether a number is odd or even using the $(C %) (remainder) operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051702Z" creationid="大处着手小处着眼" creationdate="20160726T023927Z">
        <seg>使用 $(C %)（求余数）运算符来确定数字是奇数还是偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see the functions of this module at $(LINK2 http://dlang.org/phobos/std_string.html, its online documentation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153950Z" creationid="大处着手小处着眼" creationdate="20160715T143802Z">
        <seg>在 $(LINK2 http://dlang.org/phobos/std_string.html, 它的在线文档) 中你可以看到这个模块的各个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find especially the Phobos ranges confusing at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T105630Z" creationid="大处着手小处着眼" creationdate="20160714T094151Z">
        <seg>此刻你可能会发现 Phobos 的 range 尤其让人迷惑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have to define variables of that exact type:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T105723Z" creationid="大处着手小处着眼" creationdate="20160715T144129Z">
        <seg>您可能就需要定义该类型的变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will notice that the program will not print the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031442Z" creationid="大处着手小处着眼" creationdate="20160726T031442Z">
        <seg>你将注意到程序不会输出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= 360;               // array is now equal to [7, 360]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013941Z" creationid="大处着手小处着眼" creationdate="20160726T013941Z">
        <seg>array ~= 360;               // 数组现在等于 [7, 360]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= 7;                 // array is now equal to [7]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013932Z" creationid="大处着手小处着眼" creationdate="20160726T013932Z">
        <seg>array ~= 7;                 // 数组现在等于 [7]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= [ 30, 40 ];        // array is now equal to [7, 360, 30, 40]
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013952Z" creationid="大处着手小处着眼" creationdate="20160726T013952Z">
        <seg>array ~= [ 30, 40 ];        // 数组现在等于 [7, 360, 30, 40]
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array.length = 5;       // now has 5 elements
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072325Z" creationid="大处着手小处着眼" creationdate="20160725T072325Z">
        <seg>array.length = 5;       // 现在有 5 个元素
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>atomicOp!"+="(*value, 1);    // atomic
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T003057Z" creationid="Heromyth" creationdate="20170826T003057Z">
        <seg>atomicOp!"+="(*value, 1);    // 原子的
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto arr = [ 1 ];    // ← WRONG: Allocates indirectly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002459Z" creationid="Heromyth" creationdate="20170820T002459Z">
        <seg>auto arr = [ 1 ];    // ← 错误：在类的析构函数里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto c = new C();    // ← WRONG: Allocates explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002104Z" creationid="Heromyth" creationdate="20170820T002104Z">
        <seg>auto c = new C();    // ← 错误：在类的析构函数里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto floating = message[2];    // of type double
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233539Z" creationid="Heromyth" creationdate="20170824T233539Z">
        <seg>auto floating = message[2];    // double 类型
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto integer  = message[1];    // of type int</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233528Z" creationid="Heromyth" creationdate="20170824T233528Z">
        <seg>auto integer  = message[1];    // int 类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto m = receiveOnly!int(); // ← An exception is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052125Z" creationid="Heromyth" creationdate="20170825T052125Z">
        <seg>auto m = receiveOnly!int(); // ← 如果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto message = receiveOnly!double();    $(CODE_NOTE Expecting $(HILITE double))
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233709Z" creationid="Heromyth" creationdate="20170824T233709Z">
        <seg>auto message = receiveOnly!double();    $(CODE_NOTE 期望 $(HILITE double))
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto sender   = message[0];    // of type Tid</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233520Z" creationid="Heromyth" creationdate="20170824T233520Z">
        <seg>auto sender   = message[0];    // Tid 类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>break;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070307T072716Z" creationid="ZXP" creationdate="20070307T072716Z">
        <seg>break;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculator.send("hello");  // ← incorrect input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045011Z" creationid="Heromyth" creationdate="20170825T045011Z">
        <seg>calculator.send("hello");  // ← 错误的输入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dayNumbers.clear;    // The associative array becomes empty
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132349Z" creationid="Hipter" creationdate="20160709T034649Z">
        <seg>dayNumbers.clear;    // 清空关联数组
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double[5] values;     // elements are all double.nan
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082939Z" creationid="大处着手小处着眼" creationdate="20160725T082929Z">
        <seg>double[5] values;     // 元素都是 double.nan
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements →  | 31 | 28 | 31 | 30 | 31 | 30 | 31 | 31 | 30 | 31 | 30 | 31 |
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024159Z" creationid="大处着手小处着眼" creationdate="20160725T024159Z">
        <seg>元素 →  | 31 | 28 | 31 | 30 | 31 | 30 | 31 | 31 | 30 | 31 | 30 | 31 |
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>grades["emre"] = 85;   // ← Overwrites the previous grade!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092525Z" creationid="Hipter" creationdate="20160709T092525Z">
        <seg>grades["emre"] = 85;   // ← 覆盖前一个成绩！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>indexes →     0    1    2    3    4    5    6    7    8    9   10   11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024151Z" creationid="大处着手小处着眼" creationdate="20160725T024151Z">
        <seg>索引 →     0    1    2    3    4    5    6    7    8    9   10   11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[10] allOnes = 1;    // All of the elements are set to 1
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012107Z" creationid="大处着手小处着眼" creationdate="20160726T012107Z">
        <seg>int[10] allOnes = 1;    // 所有的元素都设置为 1
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[] array;                // empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013851Z" creationid="大处着手小处着眼" creationdate="20160726T013851Z">
        <seg>int[] array;                // 空数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[] array;            // initially empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072313Z" creationid="大处着手小处着眼" creationdate="20160725T072313Z">
        <seg>int[] array;            // 初始时为空</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number = int.init;    // 0 for int
---
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133427Z" creationid="Hipter" creationdate="20160709T084837Z">
        <seg>number = int.init;    // int 值：0 
---
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ownerTid.send("hello");    $(CODE_NOTE Sending $(HILITE string))
}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233731Z" creationid="Heromyth" creationdate="20170824T233731Z">
        <seg>ownerTid.send("hello");    $(CODE_NOTE 发送 $(HILITE string))
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ownerTid.send(20);
}  // ← Terminates after sending two messages
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052401Z" creationid="Heromyth" creationdate="20170825T052401Z">
        <seg>ownerTid.send(20);
}  // ← 发送两条消息后立刻终止
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ownerTid.send(42);    // ← Produces messages continuously</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T134901Z" creationid="Heromyth" creationdate="20170825T134901Z">
        <seg>ownerTid.send(42);    // ← 持续产生消息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m1.005s    $(SHELL_NOTE now only 1 second)
user    0m0.004s
sys     0m0.004s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T014205Z" creationid="Heromyth" creationdate="20170826T014205Z">
        <seg>real    0m1.005s    $(SHELL_NOTE 现在只需 1 秒)
user    0m0.004s
sys     0m0.004s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m10.006s    $(SHELL_NOTE 10 seconds total)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074045Z" creationid="Heromyth" creationdate="20170826T074045Z">
        <seg>real    0m10.006s    $(SHELL_NOTE 共 10 秒)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m10.007s    $(SHELL_NOTE 10 seconds total)
user    0m0.004s
sys     0m0.000s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T072954Z" creationid="Heromyth" creationdate="20170826T072954Z">
        <seg>real    0m10.007s    $(SHELL_NOTE 共 10 秒)
user    0m0.004s
sys     0m0.000s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m3.005s    $(SHELL_NOTE 3 seconds total)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074946Z" creationid="Heromyth" creationdate="20170826T074946Z">
        <seg>real    0m3.005s    $(SHELL_NOTE 共 3 秒)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m4.003s    $(SHELL_NOTE 4 seconds total)
user    0m0.000s
sys     0m0.000s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T083559Z" creationid="Heromyth" creationdate="20170826T083559Z">
        <seg>real    0m4.003s    $(SHELL_NOTE 共 4 秒)
user    0m0.000s
sys     0m0.000s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m4.005s    $(SHELL_NOTE 4 seconds total)
user    0m0.004s
sys     0m0.000s
)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T013339Z" creationid="Heromyth" creationdate="20170826T013339Z">
        <seg>real    0m4.005s    $(SHELL_NOTE 共 4 秒)
user    0m0.004s
sys     0m0.000s
)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m4.007s    $(SHELL_NOTE 4 seconds total)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T074621Z" creationid="Heromyth" creationdate="20170826T074621Z">
        <seg>real    0m4.007s    $(SHELL_NOTE 共 4 秒)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m5.006s    $(SHELL_NOTE parallel reduce is slower in this example)
user    0m0.004s
sys     0m0.000s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T084902Z" creationid="Heromyth" creationdate="20170826T084902Z">
        <seg>real    0m5.006s    $(SHELL_NOTE 在本例中并行 reduce 更慢一点)
user    0m0.004s
sys     0m0.000s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>real    0m6.007s    $(SHELL_NOTE now 6 seconds)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T073231Z" creationid="Heromyth" creationdate="20170826T073231Z">
        <seg>real    0m6.007s    $(SHELL_NOTE 现在耗时 6 秒)
user    0m0.000s
sys     0m0.004s)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070307T073114Z" creationid="ZXP" creationdate="20070307T073114Z">
        <seg>return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>slice$(HILITE .length = 5);    // The slice now has 5 elements</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170905T043553Z" creationid="Heromyth" creationdate="20170905T043553Z">
        <seg>slice$(HILITE .length = 5);    // slice现在有 5 个元素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>spawn(&amp;worker, &amp;i);         // ← compiles</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T233836Z" creationid="Heromyth" creationdate="20170825T233836Z">
        <seg>spawn(&amp;worker, &amp;i);         // ← 编译正常</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← now compiles
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T160846Z" creationid="Hipter" creationdate="20160713T160846Z">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← 现在可以编译
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string s = "résumé"c;   // same as "résumé"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T031247Z" creationid="大处着手小处着眼" creationdate="20160715T031247Z">
        <seg>string s = "résumé"c;   // 与“résumé”一样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>synchronized (from) {           $(CODE_NOTE_WRONG INCORRECT)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T001250Z" creationid="Heromyth" creationdate="20170826T001250Z">
        <seg>synchronized (from) {           $(CODE_NOTE_WRONG 错误)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>synchronized (from, to) {       $(CODE_NOTE correct)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T002122Z" creationid="Heromyth" creationdate="20170826T002122Z">
        <seg>synchronized (from, to) {       $(CODE_NOTE 正确)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>task($(HILITE &amp;)bar, 2) ];    $(CODE_NOTE compiles)
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143842Z" creationid="Heromyth" creationdate="20170826T143842Z">
        <seg>task($(HILITE &amp;)bar, 2) ];    $(CODE_NOTE 编译通过)
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>variable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Tradoser" changedate="20070103T042255Z" creationid="Tradoser" creationdate="20070103T042255Z">
        <seg>变数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>worker.send(-1);        // ← to terminate the worker
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000336Z" creationid="Heromyth" creationdate="20170825T000336Z">
        <seg>worker.send(-1);        // ← 终止工作线程
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>worker.send(2);
}  // ← Terminates after sending two messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052113Z" creationid="Heromyth" creationdate="20170825T052113Z">
        <seg>worker.send(2);
}  // ← 发送两条消息后立刻终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNames[1]);   // prints "Tuesday"
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090929Z" creationid="Hipter" creationdate="20160708T084244Z">
        <seg>writeln(dayNames[1]);   // 打印 “Tuesday”
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // prints 1
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032006Z" creationid="Hipter" creationdate="20160709T032006Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // 打印 1
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← run-time ERROR
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032204Z" creationid="Hipter" creationdate="20160709T032204Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← 运行时错误
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(result.length);     // prints 20</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015707Z" creationid="大处着手小处着眼" creationdate="20160726T015658Z">
        <seg>writeln(result.length);     // 输出 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(result.length);     // prints 30
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015711Z" creationid="大处着手小处着眼" creationdate="20160726T015711Z">
        <seg>writeln(result.length);     // 输出 30
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln;      // Same as the previous line
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170906T044508Z" creationid="Heromyth" creationdate="20170906T044508Z">
        <seg>writeln;      // 与上一行相同
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yieldForce() waits for the task to complete its</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170826T143256Z" creationid="Heromyth" creationdate="20170826T033816Z">
        <seg>yieldForce() 会等待该任务完成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{} static, static this, static ~this))
$(LI $(LINK2 /ders/d.en/parameter_flexibility.html, Variable Number of Parameters) $(INDEX_KEYWORDS T[]... __MODULE__ __FILE__ __LINE__ __FUNCTION__ (and more)))
$(LI $(LINK2 /ders/d.en/function_overloading.html, Function Overloading))
$(LI $(LINK2 /ders/d.en/member_functions.html, Member Functions) $(INDEX_KEYWORDS toString))
$(LI $(LINK2 /ders/d.en/const_member_functions.html, const ref Parameters and const Member Functions) $(INDEX_KEYWORDS const ref, in ref, inout))
$(LI $(LINK2 /ders/d.en/special_functions.html, Constructor and Other Special Functions) $(INDEX_KEYWORDS this ~this this(this) opAssign @disable))
$(LI $(LINK2 /ders/d.en/operator_overloading.html, Operator Overloading) $(INDEX_KEYWORDS opUnary opBinary opEquals opCmp opIndex (and more)))
$(LI $(LINK2 /ders/d.en/class.html, Classes) $(INDEX_KEYWORDS class new))
$(LI $(LINK2 /ders/d.en/inheritance.html, Inheritance) $(INDEX_KEYWORDS : super override abstract))
$(LI $(LINK2 /ders/d.en/object.html, Object) $(INDEX_KEYWORDS toString opEquals opCmp toHash typeid TypeInfo))
$(LI $(LINK2 /ders/d.en/interface.html, Interfaces) $(INDEX_KEYWORDS interface static final))
$(LI $(LINK2 /ders/d.en/destroy.html, destroy and scoped) $(INDEX_KEYWORDS destroy scoped))
$(LI $(LINK2 /ders/d.en/modules.html, Modules and Libraries) $(INDEX_KEYWORDS import, module, static this, static ~this))
$(LI $(LINK2 /ders/d.en/encapsulation.html, Encapsulation and Protection Attributes) $(INDEX_KEYWORDS private protected public package))
$(LI $(LINK2 /ders/d.en/ufcs.html, Universal Function Call Syntax (UFCS)))
$(LI $(LINK2 /ders/d.en/property.html, Properties) $(INDEX_KEYWORDS @property))
$(LI $(LINK2 /ders/d.en/invariant.html, Contract Programming for Structs and Classes) $(INDEX_KEYWORDS invariant))
$(LI $(LINK2 /ders/d.en/templates.html, Templates))
$(LI $(LINK2 /ders/d.en/pragma.html, Pragmas))
$(LI $(LINK2 /ders/d.en/alias.html, alias and with) $(INDEX_KEYWORDS alias with))
$(LI $(LINK2 /ders/d.en/alias_this.html, alias this) $(INDEX_KEYWORDS alias this))
$(LI $(LINK2 /ders/d.en/pointers.html, Pointers) $(INDEX_KEYWORDS * &amp;))
$(LI $(LINK2 /ders/d.en/bit_operations.html, Bit Operations) $(INDEX_KEYWORDS ~ &amp; | ^ &gt;&gt; &gt;&gt;&gt; &lt;&lt;))
$(LI $(LINK2 /ders/d.en/cond_comp.html, Conditional Compilation) $(INDEX_KEYWORDS debug, version, static if, static assert, __traits))
$(LI $(LINK2 /ders/d.en/is_expr.html, is Expression) $(INDEX_KEYWORDS is()))
$(LI $(LINK2 /ders/d.en/lambda.html, Function Pointers, Delegates, and Lambdas) $(INDEX_KEYWORDS function delegate =&gt; toString))
$(LI $(LINK2 /ders/d.en/foreach_opapply.html, foreach with Structs and Classes) $(INDEX_KEYWORDS opApply empty popFront front (and more)))
$(LI $(LINK2 /ders/d.en/nested.html, Nested Functions, Structs, and Classes) $(INDEX_KEYWORDS static))
$(LI $(LINK2 /ders/d.en/union.html, Unions) $(INDEX_KEYWORDS union))
$(LI $(LINK2 /ders/d.en/goto.html, Labels and goto) $(INDEX_KEYWORDS goto))
$(LI $(LINK2 /ders/d.en/tuples.html, Tuples) $(INDEX_KEYWORDS tuple Tuple AliasSeq .tupleof foreach))
$(LI $(LINK2 /ders/d.en/templates_more.html, More Templates) $(INDEX_KEYWORDS template opDollar opIndex opSlice))
$(LI $(LINK2 /ders/d.en/functions_more.html, More Functions) $(INDEX_KEYWORDS inout pure nothrow @nogc @safe @trusted @system CTFE __ctfe))
$(LI $(LINK2 /ders/d.en/mixin.html, Mixins) $(INDEX_KEYWORDS mixin))
$(LI $(LINK2 /ders/d.en/ranges.html, Ranges) $(INDEX_KEYWORDS InputRange ForwardRange BidirectionalRange RandomAccessRange OutputRange))
$(LI $(LINK2 /ders/d.en/ranges_more.html, More Ranges) $(INDEX_KEYWORDS isInputRange ElementType hasLength inputRangeObject (and more)))
$(LI $(LINK2 /ders/d.en/parallelism.html, Parallelism) $(INDEX_KEYWORDS parallel task asyncBuf map amap reduce))
$(LI $(LINK2 /ders/d.en/concurrency.html, Message Passing Concurrency) $(INDEX_KEYWORDS spawn thisTid ownerTid send receive (and more)))
$(LI $(LINK2 /ders/d.en/concurrency_shared.html, Data Sharing Concurrency) $(INDEX_KEYWORDS synchronized, shared, shared static this, shared static ~this))
$(LI $(LINK2 /ders/d.en/fibers.html, Fibers) $(INDEX_KEYWORDS call yield))
$(LI $(LINK2 /ders/d.en/memory.html, Memory Management) $(INDEX_KEYWORDS calloc realloc emplace destroy .alignof))
$(LI $(LINK2 /ders/d.en/uda.html, User Defined Attributes (UDA)) $(INDEX_KEYWORDS @))
$(LI $(LINK2 /ders/d.en/operator_precedence.html, Operator Precedence))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T045619Z" creationid="Heromyth" creationdate="20170802T045619Z">
        <seg>{} static, static this, static ~this))
$(LI $(LINK2 /ders/d.cn/parameter_flexibility.html, 不定个数参数) $(INDEX_KEYWORDS T[]... __MODULE__ __FILE__ __LINE__ __FUNCTION__（等）))
$(LI $(LINK2 /ders/d.cn/function_overloading.html, 函数重载))
$(LI $(LINK2 /ders/d.cn/member_functions.html, 成员函数) $(INDEX_KEYWORDS toString))
$(LI $(LINK2 /ders/d.cn/const_member_functions.html, const ref 参数和 const 函数函数) $(INDEX_KEYWORDS const ref, in ref, inout))
$(LI $(LINK2 /ders/d.cn/special_functions.html, 构造函数和其他特殊函数) $(INDEX_KEYWORDS this ~this this(this) opAssign @disable))
$(LI $(LINK2 /ders/d.cn/operator_overloading.html, 运算符重载) $(INDEX_KEYWORDS opUnary opBinary opEquals opCmp opIndex（等）))
$(LI $(LINK2 /ders/d.cn/class.html, 类) $(INDEX_KEYWORDS class new))
$(LI $(LINK2 /ders/d.cn/inheritance.html, 继承) $(INDEX_KEYWORDS : super override abstract))
$(LI $(LINK2 /ders/d.cn/object.html, Object) $(INDEX_KEYWORDS toString opEquals opCmp toHash typeid TypeInfo))
$(LI $(LINK2 /ders/d.cn/interface.html, 接口) $(INDEX_KEYWORDS interface static final))
$(LI $(LINK2 /ders/d.cn/destroy.html, destroy 和 scoped) $(INDEX_KEYWORDS destroy scoped))
$(LI $(LINK2 /ders/d.cn/modules.html, 模块和库) $(INDEX_KEYWORDS import, module, static this, static ~this))
$(LI $(LINK2 /ders/d.cn/encapsulation.html, 封装和保护属性) $(INDEX_KEYWORDS private protected public package))
$(LI $(LINK2 /ders/d.cn/ufcs.html, 统一调用语法（UFCS）))
$(LI $(LINK2 /ders/d.cn/property.html, 特性) $(INDEX_KEYWORDS @property))
$(LI $(LINK2 /ders/d.cn/invariant.html, 结构和类的契约编程) $(INDEX_KEYWORDS invariant))
$(LI $(LINK2 /ders/d.cn/templates.html, 模板))
$(LI $(LINK2 /ders/d.cn/pragma.html, 编译指令))
$(LI $(LINK2 /ders/d.cn/alias.html, alias 和 with) $(INDEX_KEYWORDS alias with))
$(LI $(LINK2 /ders/d.cn/alias_this.html, alias this) $(INDEX_KEYWORDS alias this))
$(LI $(LINK2 /ders/d.cn/pointers.html, 指针) $(INDEX_KEYWORDS * &amp;))
$(LI $(LINK2 /ders/d.cn/bit_operations.html, 位运算) $(INDEX_KEYWORDS ~ &amp; | ^ &gt;&gt; &gt;&gt;&gt; &lt;&lt;))
$(LI $(LINK2 /ders/d.cn/cond_comp.html, 条件编译) $(INDEX_KEYWORDS debug, version, static if, static assert, __traits))
$(LI $(LINK2 /ders/d.cn/is_expr.html, is 表达式) $(INDEX_KEYWORDS is()))
$(LI $(LINK2 /ders/d.cn/lambda.html, 函数指针、委托和λ) $(INDEX_KEYWORDS function delegate =&gt; toString))
$(LI $(LINK2 /ders/d.cn/foreach_opapply.html, 将foreach用于结构和类) $(INDEX_KEYWORDS opApply empty popFront front（等）))
$(LI $(LINK2 /ders/d.cn/nested.html, 嵌套函数、结构和类) $(INDEX_KEYWORDS static))
$(LI $(LINK2 /ders/d.cn/union.html, 联合) $(INDEX_KEYWORDS union))
$(LI $(LINK2 /ders/d.cn/goto.html, 标签和 goto) $(INDEX_KEYWORDS goto))
$(LI $(LINK2 /ders/d.cn/tuples.html, 元组) $(INDEX_KEYWORDS tuple Tuple AliasSeq .tupleof foreach))
$(LI $(LINK2 /ders/d.cn/templates_more.html, 模板的更多内容) $(INDEX_KEYWORDS template opDollar opIndex opSlice))
$(LI $(LINK2 /ders/d.cn/functions_more.html, 函数的更多内容) $(INDEX_KEYWORDS inout pure nothrow @nogc @safe @trusted @system CTFE __ctfe))
$(LI $(LINK2 /ders/d.cn/mixin.html, 混入) $(INDEX_KEYWORDS mixin))
$(LI $(LINK2 /ders/d.cn/ranges.html, 范围) $(INDEX_KEYWORDS InputRange ForwardRange BidirectionalRange RandomAccessRange OutputRange))
$(LI $(LINK2 /ders/d.cn/ranges_more.html, 范围的更多内容) $(INDEX_KEYWORDS isInputRange ElementType hasLength inputRangeObject（等）))
$(LI $(LINK2 /ders/d.cn/parallelism.html, 并行性) $(INDEX_KEYWORDS parallel task asyncBuf map amap reduce))
$(LI $(LINK2 /ders/d.cn/concurrency.html, 消息传递并发) $(INDEX_KEYWORDS spawn thisTid ownerTid send receive (and more)))
$(LI $(LINK2 /ders/d.cn/concurrency_shared.html, 数据共享并发) $(INDEX_KEYWORDS synchronized, shared, shared static this, shared static ~this))
$(LI $(LINK2 /ders/d.cn/fibers.html, 纤程) $(INDEX_KEYWORDS call yield))
$(LI $(LINK2 /ders/d.cn/memory.html, 内存管理) $(INDEX_KEYWORDS calloc realloc emplace destroy .alignof))
$(LI $(LINK2 /ders/d.cn/uda.html, 自定义属性（UDA）) $(INDEX_KEYWORDS @))
$(LI $(LINK2 /ders/d.cn/operator_precedence.html, 运算符优先级))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104106Z" creationid="Hipter" creationdate="20160707T104106Z">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：
)</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
