<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-4.1.2" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>$ .dup capacity))
$(LI $(LINK2 /ders/d.en/strings.html, Strings) $(INDEX_KEYWORDS char[] wchar[] dchar[] string wstring dstring))
$(LI $(LINK2 /ders/d.en/stream_redirect.html, Redirecting Standard Input and Output Streams))
$(LI $(LINK2 /ders/d.en/files.html, Files) $(INDEX_KEYWORDS File))
$(LI $(LINK2 /ders/d.en/auto_and_typeof.html, auto and typeof) $(INDEX_KEYWORDS auto typeof))
$(LI $(LINK2 /ders/d.en/name_space.html, Name Scope))
$(LI $(LINK2 /ders/d.en/for.html, for Loop) $(INDEX_KEYWORDS for))
$(LI $(LINK2 /ders/d.en/ternary.html, Ternary Operator ?:) $(INDEX_KEYWORDS ?:))
$(LI $(LINK2 /ders/d.en/literals.html, Literals))
$(LI $(LINK2 /ders/d.en/formatted_output.html, Formatted Output) $(INDEX_KEYWORDS writef writefln))
$(LI $(LINK2 /ders/d.en/formatted_input.html, Formatted Input))
$(LI $(LINK2 /ders/d.en/do_while.html, do-while Loop) $(INDEX_KEYWORDS do while))
$(LI $(LINK2 /ders/d.en/aa.html, Associative Arrays) $(INDEX_KEYWORDS .keys .values .byKey .byValue .byKeyValue .get .remove in))
$(LI $(LINK2 /ders/d.en/foreach.html, foreach Loop) $(INDEX_KEYWORDS foreach .byKey .byValue .byKeyValue))
$(LI $(LINK2 /ders/d.en/switch_case.html, switch and case) $(INDEX_KEYWORDS switch, case, default, final switch))
$(LI $(LINK2 /ders/d.en/enum.html, enum) $(INDEX_KEYWORDS enum .min .max))
$(LI $(LINK2 /ders/d.en/functions.html, Functions) $(INDEX_KEYWORDS return void))
$(LI $(LINK2 /ders/d.en/const_and_immutable.html, Immutability) $(INDEX_KEYWORDS enum const immutable .dup .idup))
$(LI $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types) $(INDEX_KEYWORDS &amp;))
$(LI $(LINK2 /ders/d.en/function_parameters.html, Function Parameters) $(INDEX_KEYWORDS in out ref inout lazy scope shared))
$(LI $(LINK2 /ders/d.en/lvalue_rvalue.html, Lvalues and Rvalues) $(INDEX_KEYWORDS auto ref))
$(LI $(LINK2 /ders/d.en/lazy_operators.html, Lazy Operators))
$(LI $(LINK2 /ders/d.en/main.html, Program Environment) $(INDEX_KEYWORDS main stderr))
$(LI $(LINK2 /ders/d.en/exceptions.html, Exceptions) $(INDEX_KEYWORDS throw try catch finally))
$(LI $(LINK2 /ders/d.en/scope.html, scope) $(INDEX_KEYWORDS scope(exit) scope(success) scope(failure)))
$(LI $(LINK2 /ders/d.en/assert.html, assert and enforce) $(INDEX_KEYWORDS assert enforce))
$(LI $(LINK2 /ders/d.en/unit_testing.html, Unit Testing) $(INDEX_KEYWORDS unittest))
$(LI $(LINK2 /ders/d.en/contracts.html, Contract Programming) $(INDEX_KEYWORDS in out body))
$(LI $(LINK2 /ders/d.en/lifetimes.html, Lifetimes and Fundamental Operations))
$(LI $(LINK2 /ders/d.en/null_is.html, The null Value and the is Operator) $(INDEX_KEYWORDS null is !is))
$(LI $(LINK2 /ders/d.en/cast.html, Type Conversions) $(INDEX_KEYWORDS to assumeUnique cast))
$(LI $(LINK2 /ders/d.en/struct.html, Structs) $(INDEX_KEYWORDS struct .</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T025319Z" creationid="Heromyth" creationdate="20170802T025319Z">
        <seg>$ .dup capacity))
$(LI $(LINK2 /ders/d.cn/strings.html, 字符串) $(INDEX_KEYWORDS char[] wchar[] dchar[] string wstring dstring))
$(LI $(LINK2 /ders/d.cn/stream_redirect.html, 重定向标准输入输出流))
$(LI $(LINK2 /ders/d.cn/files.html, 文件) $(INDEX_KEYWORDS File))
$(LI $(LINK2 /ders/d.cn/auto_and_typeof.html, auto 和 typeof) $(INDEX_KEYWORDS auto typeof))
$(LI $(LINK2 /ders/d.cn/name_space.html, 名字作用域))
$(LI $(LINK2 /ders/d.cn/for.html, for 循环) $(INDEX_KEYWORDS for))
$(LI $(LINK2 /ders/d.cn/ternary.html, 三元运算符 ?:) $(INDEX_KEYWORDS ?:))
$(LI $(LINK2 /ders/d.cn/literals.html, 文字量))
$(LI $(LINK2 /ders/d.cn/formatted_output.html, 格式化输出) $(INDEX_KEYWORDS writef writefln))
$(LI $(LINK2 /ders/d.cn/formatted_input.html, 格式化输入))
$(LI $(LINK2 /ders/d.cn/do_while.html, do-while 循环) $(INDEX_KEYWORDS do while))
$(LI $(LINK2 /ders/d.cn/aa.html, 关联数组) $(INDEX_KEYWORDS .keys .values .byKey .byValue .byKeyValue .get .remove in))
$(LI $(LINK2 /ders/d.cn/foreach.html, foreach 循环) $(INDEX_KEYWORDS foreach .byKey .byValue .byKeyValue))
$(LI $(LINK2 /ders/d.cn/switch_case.html, switch 和 case) $(INDEX_KEYWORDS switch, case, default, final switch))
$(LI $(LINK2 /ders/d.cn/enum.html, enum) $(INDEX_KEYWORDS enum .min .max))
$(LI $(LINK2 /ders/d.cn/functions.html, 函数) $(INDEX_KEYWORDS return void))
$(LI $(LINK2 /ders/d.cn/const_and_immutable.html, 不变量) $(INDEX_KEYWORDS enum const immutable .dup .idup))
$(LI $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型与引用类型) $(INDEX_KEYWORDS &amp;))
$(LI $(LINK2 /ders/d.cn/function_parameters.html, 函数参数) $(INDEX_KEYWORDS in out ref inout lazy scope shared))
$(LI $(LINK2 /ders/d.cn/lvalue_rvalue.html, 左值与右值) $(INDEX_KEYWORDS auto ref))
$(LI $(LINK2 /ders/d.cn/lazy_operators.html, 惰性运算符))
$(LI $(LINK2 /ders/d.cn/main.html, 程序环境) $(INDEX_KEYWORDS main stderr))
$(LI $(LINK2 /ders/d.cn/exceptions.html, 异常) $(INDEX_KEYWORDS throw try catch finally))
$(LI $(LINK2 /ders/d.cn/scope.html, scope) $(INDEX_KEYWORDS scope(exit) scope(success) scope(failure)))
$(LI $(LINK2 /ders/d.cn/assert.html, assert 与 enforce) $(INDEX_KEYWORDS assert enforce))
$(LI $(LINK2 /ders/d.cn/unit_testing.html, 单元测试) $(INDEX_KEYWORDS unittest))
$(LI $(LINK2 /ders/d.cn/contracts.html, 契约编程) $(INDEX_KEYWORDS in out body))
$(LI $(LINK2 /ders/d.cn/lifetimes.html, 生命周期与函数式运算))
$(LI $(LINK2 /ders/d.cn/null_is.html, null 值与 is 运算符) $(INDEX_KEYWORDS null is !is))
$(LI $(LINK2 /ders/d.cn/cast.html, 类型转换) $(INDEX_KEYWORDS to assumeUnique cast))
$(LI $(LINK2 /ders/d.cn/struct.html, 结构) $(INDEX_KEYWORDS struct .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C !is) is the opposite of $(C is).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014827Z" creationid="Hipter" creationdate="20160707T014827Z">
        <seg>$(C !is) 与 $(C is) 相反。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .get()) is useful in such cases: it returns the value associated with the specified key if that key exists, otherwise it returns the default value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042443Z" creationid="Hipter" creationdate="20160709T042443Z">
        <seg>$(C .get()) 在这样的样例中是有用的：如果指定键存在则返回相应值，否则返回默认值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .idup) is used for producing immutable strings from existing strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152146Z" creationid="Hipter" creationdate="20160713T033023Z">
        <seg>$(C .idup) 可用来从存在的字符串中生成不可变的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C .length) returns the number of elements of the array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071943Z" creationid="大处着手小处着眼" creationdate="20160725T071943Z">
        <seg>$(C .length) 返回数组元素的个数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C readf()) continues to wait for more characters to add to the string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T072239Z" creationid="Hipter" creationdate="20160712T004229Z">
        <seg>$(C readf()) 继续等待新输入的字符以添加到字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C receive()) on the other hand can wait for more than one type of message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235851Z" creationid="Heromyth" creationdate="20170824T235851Z">
        <seg>而 $(C receive()) 可以接收多种类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C receiveTimeout()) prevents blocking the receiving thread indefinitely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043248Z" creationid="Heromyth" creationdate="20170825T043248Z">
        <seg>$(C receiveTimeout()) 可以防止出现无限等待消息这样的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C variable1) and $(C variable2) above merely provide access to that anonymous object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011741Z" creationid="Hipter" creationdate="20160706T011741Z">
        <seg>上面的 $(C variable1) 和 $(C variable2) 只提供对那个匿名对象的访问：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(C ~) concatenates two strings and $(C ~=) appends to an existing string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153448Z" creationid="大处着手小处着眼" creationdate="20160715T033130Z">
        <seg>$(C ~) 可以连接两个字符串，$(C ~=) 则能够把字符串附加到一个已存在的字符串上：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025535Z" creationid="大处着手小处着眼" creationdate="20160726T025535Z">
        <seg>$(COZUM_BOLUMU 数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T101504Z" creationid="Hipter" creationdate="20160709T095142Z">
        <seg>$(COZUM_BOLUMU 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(COZUM_BOLUMU Strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ADR" changedate="20160714T092548Z" creationid="ADR" creationdate="20160714T092548Z">
        <seg>$(COZUM_BOLUMU 字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX array) Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T051835Z" creationid="Heromyth" creationdate="20170817T051835Z">
        <seg>$(DERS_BOLUMU $(IX array) 数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX associative array) $(IX AA) Associative Arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085529Z" creationid="Hipter" creationdate="20160708T082836Z">
        <seg>$(DERS_BOLUMU $(IX 关联数组) $(IX AA) 关联数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX class) Classes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160701T014126Z" creationid="Hipter" creationdate="20160701T014126Z">
        <seg>$(DERS_BOLUMU $(IX class) 类)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX compilation) Compilation)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003000Z" creationid="Heromyth" creationdate="20170820T003000Z">
        <seg>$(DERS_BOLUMU $(IX compilation) 编译)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX concurrency, message passing) $(IX message passing concurrency) Message Passing Concurrency)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T011541Z" creationid="Heromyth" creationdate="20170824T011541Z">
        <seg>$(DERS_BOLUMU $(IX concurrency, message passing) $(IX message passing concurrency) 基于消息传递的并发)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU $(IX user defined attributes) $(IX UDA) User Defined Attributes (UDA))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170719T105356Z" creationid="Heromyth" creationdate="20170719T054011Z">
        <seg>$(DERS_BOLUMU $(IX user defined attributes) $(IX UDA) 自定义属性（UDA）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU Programming in D)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T011008Z" creationid="Heromyth" creationdate="20170726T011008Z">
        <seg>$(DERS_BOLUMU D 语言编程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(DERS_BOLUMU Strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T000617Z" creationid="大处着手小处着眼" creationdate="20160716T000617Z">
        <seg>$(DERS_BOLUMU 字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX &amp;quot;) Double quotes, not single quotes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144659Z" creationid="Hipter" creationdate="20160712T075419Z">
        <seg>$(H5 $(IX &amp;quot;) 使用双引号，而非单引号)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX .length) Using $(C .length) to get or set the number of elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071657Z" creationid="大处着手小处着眼" creationdate="20160725T071657Z">
        <seg>$(H5 $(IX .length) 使用 $(C .length) 来获取或设置元素的个数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX Tid) $(IX thisTid) $(IX ownerTid) Thread identifiers)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232217Z" creationid="Heromyth" creationdate="20170824T232217Z">
        <seg>$(H5 $(IX Tid) $(IX thisTid) $(IX ownerTid) 线程 ID)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX []) Accessing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T142855Z" creationid="大处着手小处着眼" creationdate="20160723T142855Z">
        <seg>$(H5 $(IX []) 元素的访问)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX compiler) Compiler)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004712Z" creationid="Heromyth" creationdate="20170820T004712Z">
        <seg>$(H5 $(IX compiler) 编译器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX concatenation, string) String concatenation)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153034Z" creationid="大处着手小处着眼" creationdate="20160715T032440Z">
        <seg>$(H5 $(IX concatenation, string) 字符串连接)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX container) $(IX element) Containers and elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033618Z" creationid="大处着手小处着眼" creationdate="20160720T033618Z">
        <seg>$(H5 $(IX container) $(IX element) 容器和元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX delegate, message passing) Expecting different types of messages)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235801Z" creationid="Heromyth" creationdate="20170824T235801Z">
        <seg>$(H5 $(IX delegate, message passing) 接收不同类型的消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX exception, concurrency) Exceptions during the execution of the worker)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044616Z" creationid="Heromyth" creationdate="20170825T044616Z">
        <seg>$(H5 $(IX exception, concurrency) 工作线程中的异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX fixed-length array) $(IX dynamic array) $(IX static array) Fixed-length arrays vs. dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T031444Z" creationid="大处着手小处着眼" creationdate="20160725T031444Z">
        <seg>$(H5 $(IX 定长数组) $(IX 动态数组) $(IX 静态数组) 定长数组与动态数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX formattedRead) $(C formattedRead) for parsing strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T132149Z" creationid="Hipter" creationdate="20160712T022848Z">
        <seg>$(H5 $(IX formattedRead) 使用 $(C formattedRead) 函数来解析字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX in, associative array) Determining the presence of a key)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144209Z" creationid="Hipter" creationdate="20160709T034906Z">
        <seg>$(H5 $(IX in, 关联数组) 确定某个键是否存在)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX index) Index)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T015845Z" creationid="大处着手小处着眼" creationdate="20160725T015845Z">
        <seg>$(H5 $(IX index) Index（索引）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX initialization, array) Initializing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082357Z" creationid="大处着手小处着眼" creationdate="20160725T082342Z">
        <seg>$(H5 $(IX 初始化,数组) 初始化元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX interpreter) Interpreter)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004222Z" creationid="Heromyth" creationdate="20170820T004222Z">
        <seg>$(H5 $(IX interpreter) 解释器)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX length, string) Potentially confusing length of strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T010012Z" creationid="大处着手小处着眼" creationdate="20160714T005946Z">
        <seg>$(H5 $(IX length, string) 有可能让人困惑的字符串长度)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX literal, string) String literals)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T014642Z" creationid="大处着手小处着眼" creationdate="20160715T014642Z">
        <seg>$(H5 $(IX literal, string) 字符串字面量)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX machine code) Machine code)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003231Z" creationid="Heromyth" creationdate="20170820T003231Z">
        <seg>$(H5 $(IX machine code) 机器码)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX programming language) Programming language)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004025Z" creationid="Heromyth" creationdate="20170820T004025Z">
        <seg>$(H5 $(IX programming language) 编程语言)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX readln) $(IX strip) $(C readln) and $(C strip), instead of $(C readf))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T111020Z" creationid="Hipter" creationdate="20160711T092224Z">
        <seg>$(H5 $(IX readln) $(IX strip) 使用 $(C readln) 和 $(C strip)，而非 $(C readf))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX receiveTimeout) Waiting for messages up to a certain time)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043213Z" creationid="Heromyth" creationdate="20170825T043213Z">
        <seg>$(H5 $(IX receiveTimeout) 在指定的时间内等待消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX remove) Removing key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032109Z">
        <seg>$(H5 $(IX remove) 移除键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX send) $(IX receiveOnly) Message Passing)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232728Z" creationid="Heromyth" creationdate="20170824T232728Z">
        <seg>$(H5 $(IX send) $(IX receiveOnly) 消息传递)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX spawn) Starting threads)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054229Z" creationid="Heromyth" creationdate="20170824T054229Z">
        <seg>$(H5 $(IX spawn) 启动线程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string), $(C wstring), and $(C dstring) are immutable)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144832Z" creationid="Hipter" creationdate="20160712T080114Z">
        <seg>$(H5 $(IX string) $(IX wstring) $(IX dstring) $(IX char[]) $(IX wchar[]) $(IX dchar[]) $(IX immutable) $(C string)、$(C wstring) 和 $(C dstring) 是 immutable （不可变的）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Adding key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T144521Z">
        <seg>$(H5 添加键值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 An array example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072336Z" creationid="大处着手小处着眼" creationdate="20160725T072336Z">
        <seg>$(H5 一个数组例子)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Basic array operations)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051122Z" creationid="大处着手小处着眼" creationdate="20160726T012123Z">
        <seg>$(H5 数组的基本操作)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Comparing strings)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033521Z" creationid="大处着手小处着眼" creationdate="20160715T033521Z">
        <seg>$(H5 比较字符串)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Comparing with structs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123652Z" creationid="Heromyth" creationdate="20170819T123652Z">
        <seg>$(H5 与结构对比)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Concepts)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012345Z" creationid="Heromyth" creationdate="20170824T012345Z">
        <seg>$(H5 相关概念)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094803Z" creationid="Hipter" creationdate="20160708T094803Z">
        <seg>$(H5 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Detecting thread termination)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051954Z" creationid="Heromyth" creationdate="20170825T051954Z">
        <seg>$(H5 检测线程终止)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083417Z" creationid="Hipter" creationdate="20160709T083417Z">
        <seg>$(H5 样例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Initialization)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030542Z" creationid="Hipter" creationdate="20160709T030542Z">
        <seg>$(H5 初始化)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Lowercase and uppercase are different)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T035759Z" creationid="大处着手小处着眼" creationdate="20160715T035759Z">
        <seg>$(H5 小写与大写不同)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Online version)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052519Z" creationid="Heromyth" creationdate="20170801T052519Z">
        <seg>$(H5 在线版本)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Properties)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143437Z" creationid="Hipter" creationdate="20160709T042827Z">
        <seg>$(H5 特性)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Removing key-value pairs)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144123Z" creationid="Heromyth" creationdate="20170818T144123Z">
        <seg>$(H5 删除键-值对)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 Summary)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T054023Z" creationid="Hipter" creationdate="20160707T015616Z">
        <seg>$(H5 小结)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H5 The benefit of user defined attributes)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121738Z" creationid="Heromyth" creationdate="20170815T121738Z">
        <seg>$(H5 自定义属性的好处)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX LinkTerminated) $(IX spawnLinked) $(C LinkTerminated) exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052242Z" creationid="Heromyth" creationdate="20170825T052242Z">
        <seg>$(H6 $(IX LinkTerminated) $(IX spawnLinked) $(C LinkTerminated) 异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX OwnerTerminated) $(C OwnerTerminated) exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052019Z" creationid="Heromyth" creationdate="20170825T052019Z">
        <seg>$(H6 $(IX OwnerTerminated) $(C OwnerTerminated) 异常)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX assignment, class) Assignment)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024616Z" creationid="Hipter" creationdate="20160706T024616Z">
        <seg>$(H6 $(IX assignment, class) 赋值)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX copy, array) Copying fixed-length arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013007Z" creationid="大处着手小处着眼" creationdate="20160726T013007Z">
        <seg>$(H6 $(IX 复制, 数组) 复​​制定长数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX copy, class) Copying)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011913Z" creationid="Hipter" creationdate="20160706T011913Z">
        <seg>$(H6 $(IX copy, class) 复制)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX error, compilation) $(IX compilation error) Compilation error)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005043Z" creationid="Heromyth" creationdate="20170820T005043Z">
        <seg>$(H6 $(IX error, compilation) $(IX compilation error) 编译错误)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX is, operator) $(IX !is) The $(C is) and $(C !is) operators)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013714Z" creationid="Hipter" creationdate="20160707T013714Z">
        <seg>$(H6 $(IX is, 运算符) $(IX !is)   $(C is) 和 $(C !is) 运算符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX null, class) $(new, class) Class variables may be $(C null))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124204Z" creationid="Heromyth" creationdate="20170819T124204Z">
        <seg>$(H6 $(IX null, class) $(new, class) 类变量可以为 $(C null))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX remove, array) Removing elements from dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T051918Z" creationid="Heromyth" creationdate="20170817T051918Z">
        <seg>$(H6 $(IX remove, array) 从动态数组里删除元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX reverse) Reversing the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021701Z" creationid="大处着手小处着眼" creationdate="20160726T021701Z">
        <seg>$(H6 $(IX reverse（反转）) 反转元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX sort) Sorting the elements)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021045Z" creationid="大处着手小处着眼" creationdate="20160726T021045Z">
        <seg>$(H6 $(IX sort（排序）) 排序元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX variable, class) $(IX object, class) Class variables versus class objects)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130756Z" creationid="Heromyth" creationdate="20170819T130756Z">
        <seg>$(H6 $(IX variable, class) $(IX object, class) 类变量与类对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX ~, concatenation) $(IX concatenation, array) Combining arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T041030Z" creationid="大处着手小处着眼" creationdate="20160726T014408Z">
        <seg>$(H6 $(IX ~, 连接) $(IX 连接, 数组) 连接数组)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 $(IX ~=) $(IX append, array) $(IX add element, array) Adding elements to dynamic arrays)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013609Z" creationid="大处着手小处着眼" creationdate="20160726T013609Z">
        <seg>$(H6 $(IX ~=) $(IX 附加, 数组) $(IX 添加元素, 数组) 给动态数组添加元素)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Classes are reference types)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123955Z" creationid="Heromyth" creationdate="20170819T123955Z">
        <seg>$(H6 类是引用类型)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Construction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033741Z" creationid="Hipter" creationdate="20160706T032028Z">
        <seg>$(H6 构造函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Definition)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031821Z" creationid="Hipter" creationdate="20160706T031821Z">
        <seg>$(H6 定义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Destruction)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033752Z" creationid="Hipter" creationdate="20160706T033700Z">
        <seg>$(H6 析构函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Example)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233909Z" creationid="Heromyth" creationdate="20170824T233909Z">
        <seg>$(H6 示例)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member access)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002524Z" creationid="Heromyth" creationdate="20170820T002524Z">
        <seg>$(H6 成员访问)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Member functions)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005242Z" creationid="Hipter" creationdate="20160707T005242Z">
        <seg>$(H6 成员函数)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Operator overloading)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004731Z" creationid="Hipter" creationdate="20160707T004731Z">
        <seg>$(H6 运算符重载)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(H6 Receiving any type of message)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000705Z" creationid="Heromyth" creationdate="20170825T000705Z">
        <seg>$(H6 接收任意类型的消息)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE array =) array.remove!(a =&gt; $(HILITE a == 42));    // Assigned back to array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145745Z" creationid="Heromyth" creationdate="20170817T145745Z">
        <seg>$(HILITE array =) array.remove!(a =&gt; $(HILITE a == 42));    // 回赋给 array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE array =) array.remove($(HILITE 1));                // Assigned back to array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145201Z" creationid="Heromyth" creationdate="20170817T145201Z">
        <seg>$(HILITE array =) array.remove($(HILITE 1));                // 回赋给 array</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE Recommended)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012540Z" creationid="Hipter" creationdate="20160707T012540Z">
        <seg>$(HILITE final) int func() {    $(CODE_NOTE 推荐)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I ($(B Note:) This is related to name scopes, as well as object lifetimes, which will be explained in $(LINK2 /ders/d.en/lifetimes.html, a later chapter.)))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025009Z" creationid="Hipter" creationdate="20160707T022842Z">
        <seg>$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I type_name)[$(I value_count)] $(I variable_name);
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032737Z" creationid="大处着手小处着眼" creationdate="20160720T032737Z">
        <seg>$(I 类型名称)[$(I 值的个数)] $(I 变量名称);
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(I value_type)[$(I key_type)] $(I associative_array_name);
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095157Z" creationid="Hipter" creationdate="20160708T095114Z">
        <seg>$(I 值类型)[$(I 键类型)] $(I 关联数组名);
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Encapsulation:) Controlling access to members ($(I Encapsulation is available for structs as well but it has not been mentioned until this chapter.))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120907Z" creationid="Heromyth" creationdate="20170819T120907Z">
        <seg>$(LI
$(B 封装：) 控制成员的访问（$(I 封装也可用于结构，只是到本章之前一直未提及。)）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Inheritance:) Acquiring members of another type
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120944Z" creationid="Heromyth" creationdate="20170819T120944Z">
        <seg>$(LI
$(B 继承：) 获取另一个类型的成员
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
$(B Polymorphism:) Being able to use a more special type in place of a more general type
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T121346Z" creationid="Heromyth" creationdate="20170819T121346Z">
        <seg>$(LI
$(B 多态性：) 能够使用较特定的类型取代较通用的类型
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Although both programming models use operating system threads, in parallelism threads are encapsulated by the concept of task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012201Z" creationid="Heromyth" creationdate="20170824T012154Z">
        <seg>$(LI
虽然两者都涉及线程操作，但并行用 task 对线程做了包装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Although some of the functions in Phobos modules will be easy to use with strings, library documentations are usually terse compared to tutorials.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T070344Z" creationid="大处着手小处着眼" creationdate="20160714T093404Z">
        <seg>$(LI
尽管 Phobos 模块中的一些函数易于处理字符串，但库文档通常比教程简短。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Another solution is to assign an empty array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115803Z" creationid="Hipter" creationdate="20160711T012526Z">
        <seg>$(LI
另一种解法是用空数组赋值：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
In parallelism, tasks are independent from each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012119Z" creationid="Heromyth" creationdate="20170824T012119Z">
        <seg>$(LI
在并行中，任务之间相互独立。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Many other functions may be chained as well:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151035Z" creationid="大处着手小处着眼" creationdate="20160714T095132Z">
        <seg>$(LI
许多别的函数可以嵌套使用：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Parallelism is easy to use, and as long as tasks are independent it is easy to produce programs that work correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012219Z" creationid="Heromyth" creationdate="20170824T012219Z">
        <seg>$(LI
并行上手容易，由于任务相互独立的缘故我们写出的程序很少出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Since the initial value of an array is an empty array anyway, the following technique would achieve the same result:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013753Z" creationid="Hipter" creationdate="20160711T013753Z">
        <seg>$(LI
由于数组的初始值无论如何都是一个空数组，那么下面的技术将得到一样的结果：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
Specifying the elements to remove with a $(I lambda function), which we will cover in $(LINK2 /ders/d.en/lambda.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145615Z" creationid="Heromyth" creationdate="20170817T145615Z">
        <seg>$(LI
使用一个 $(I 匿名函数) （在 $(LINK2 /ders/d.cn/lambda.html, 后面章节) 会讲解它）来指定需要删除的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The $(C .keys) property returns a slice (i.e. dynamic array) that includes all of the keys of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141924Z" creationid="Hipter" creationdate="20160709T101654Z">
        <seg>$(LI
特性 $(C .keys) 返回的是一个分片(即动态数组)，其中包含关联数组的所有键。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The explanations are included as code comments:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025910Z" creationid="大处着手小处着眼" creationdate="20160726T025910Z">
        <seg>$(LI
解释包含在代码说明中：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The goal is to store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T013837Z" creationid="Hipter" creationdate="20160711T013837Z">
        <seg>$(LI
目标是存储每个学生的多个成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
The main purpose of parallelism is to take advantage of microprocessor cores to improve the performance of programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T011955Z" creationid="Heromyth" creationdate="20170824T011955Z">
        <seg>$(LI
并行的主要目的是利用多核心的运算能力提高程序的性能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI
There are three mistakes (bugs) in this program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141623Z" creationid="大处着手小处着眼" creationdate="20160726T030739Z">
        <seg>$(LI
程序有三个错误（bug）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI  类是引用类型。The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041335Z" creationid="Hipter" creationdate="20160708T041335Z">
        <seg>$(LI  类是引用类型。 $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(B The numbers start with zero:) Although humans assign numbers to items starting with 1, the numbers in arrays start at 0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023625Z" creationid="大处着手小处着眼" creationdate="20160724T023559Z">
        <seg>$(LI $(B 从零开始编号：) 虽然人们习惯于从 1 开始给项目分配编号，但数组是从 0 开始的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(B Two different uses of the $(C[]) characters:) Don't confuse the two separate uses of the $(C []) characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T024921Z" creationid="大处着手小处着眼" creationdate="20160724T024914Z">
        <seg>$(LI $(B$(C[]) 的两种不同用法：) 不要混淆 $(C []) 的两种独特用法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C catch) and $(C finally) cannot be used without a $(C try) block.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022354Z" creationid="Hipter" creationdate="20160707T022354Z">
        <seg>$(LI 没有一个 $(C try) 块， $(C catch) 和 $(C finally) 不能使用。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(failure)): the expression is executed only if the scope is being exited due to an exception)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051533Z" creationid="Hipter" creationdate="20160707T025720Z">
        <seg>$(LI $(C scope(failure))：表达式只在因出现异常而退出作用域时被执行。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(C scope(success)): the expression is executed only if the scope is being exited successfully)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025415Z" creationid="Hipter" creationdate="20160707T025415Z">
        <seg>$(LI $(C scope(success))：表达式只在成功退出作用域时被执行。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKey) $(C .byKey) provides access to the keys without copying them; we will see how $(C .byKey) is used in $(C foreach) loops in the next chapter.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025532Z" creationid="Hipter" creationdate="20160709T081414Z">
        <seg>$(LI $(IX .byKey) $(C .byKey) 提供对键的直接访问；在下一章我们将看到在 $(C foreach) 循环中如何使用 $(C .byKey) 。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) provides access to the key-value pairs without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025550Z" creationid="Hipter" creationdate="20160709T082623Z">
        <seg>$(LI $(IX .byKeyValue) $(C .byKeyValue) 提供对键值对的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .byValue) $(C .byValue) provides access to the values without copying them.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T025539Z" creationid="Hipter" creationdate="20160709T082217Z">
        <seg>$(LI $(IX .byValue) $(C .byValue) 提供对值的直接访问。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .clear) $(C .clear) removes all elements.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083332Z" creationid="Hipter" creationdate="20160709T083332Z">
        <seg>$(LI $(IX .clear) $(C .clear) 移除全部元素。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .get) $(C .get) returns the value if it exists, the default value otherwise.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133139Z" creationid="Hipter" creationdate="20160709T083159Z">
        <seg>$(LI $(IX .get) $(C .get) 值存在即返回相应值，否则返回默认值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .keys) $(C .keys) returns a copy of all keys as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080658Z" creationid="Hipter" creationdate="20160709T080658Z">
        <seg>$(LI $(IX .keys) $(C .keys) 返回全部键的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .length) $(C .length) returns the number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080521Z" creationid="Hipter" creationdate="20160709T080521Z">
        <seg>$(LI $(IX .length) $(C .length) 返回键值对的个数。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .rehash) $(C .rehash) may make the array more efficient in some cases, such as after inserting a large number of key-value pairs.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T082830Z" creationid="Hipter" creationdate="20160709T082830Z">
        <seg>$(LI $(IX .rehash) $(C .rehash) 在一些例子中可以让数组更有效率，比如在插入大量的键值对之后。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .remove) $(C .remove) removes the specified key and its value from the array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T083314Z" creationid="Hipter" creationdate="20160709T083314Z">
        <seg>$(LI $(IX .remove) $(C .remove) 从数组中移除指定的键和值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .remove, associative array) $(C .remove) removes the specified key and its value from the array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143538Z" creationid="Heromyth" creationdate="20170818T143538Z">
        <seg>$(LI $(IX .remove, associative array) $(C .remove) 从数组里删除指定的键及其值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) is the size of the array $(I reference) (it has nothing to do with the number of key-value pairs in the table and is the same value for all associative arrays).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T045628Z" creationid="Hipter" creationdate="20160709T083105Z">
        <seg>$(LI $(IX .sizeof, associative array) $(C .sizeof) 数组$(I 引用)大小（它不受表中键值对个数的影响，对所有的关联数组来说值都是一样的）。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX .values) $(C .values) returns a copy of all values as a dynamic array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T081449Z" creationid="Hipter" creationdate="20160709T081449Z">
        <seg>$(LI $(IX .values) $(C .values) 返回全部值的动态数组副本。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX allMembers) $(C __traits(allMembers)) produces the members of a type (or a module) as strings.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053356Z" creationid="Heromyth" creationdate="20170804T053356Z">
        <seg>$(LI $(IX allMembers) $(C __traits(allMembers)) 会以字符串列表的形式生成某个类型（或模块）的所有成员。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI $(IX getMember) $(C __traits(getMember)) produces a $(I symbol) useful when accessing a member.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053639Z" creationid="Heromyth" creationdate="20170804T053639Z">
        <seg>$(LI $(IX getMember) $(C __traits(getMember)) 会生成一个 $(I 符号)，可以在访问某个成员时使用它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A class destructor must not access a member that is managed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001816Z" creationid="Heromyth" creationdate="20170820T001647Z">
        <seg>$(LI 类的析构函数不能访问由垃圾回收器管理的成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI A class destructor must not allocate new memory that is managed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001802Z" creationid="Heromyth" creationdate="20170820T001723Z">
        <seg>$(LI 类的析构函数一定不要分配由垃圾回收器管理的新内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assigning an empty associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084451Z" creationid="Hipter" creationdate="20160709T084139Z">
        <seg>$(LI 用一个空的关联数组赋值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Assignment associates a variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020548Z" creationid="Hipter" creationdate="20160707T020548Z">
        <seg>$(LI 赋值会把一个变量与一个对象相关联。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Class variables that are not associated with any object are $(C null).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020015Z" creationid="Hipter" creationdate="20160707T020015Z">
        <seg>$(LI 不与任何对象相关联的类变量为 $(C null)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes and structs share common features but have big differences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015731Z" creationid="Hipter" creationdate="20160707T015731Z">
        <seg>$(LI 类和结构虽然有共同特点，但还是有很大的差异。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Classes are reference types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015816Z" creationid="Hipter" creationdate="20160707T015816Z">
        <seg>$(LI  类是引用类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Each member is tested with $(C hasUDA) to determine whether it has the $(C Encrypted) attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042259Z" creationid="Heromyth" creationdate="20170815T042259Z">
        <seg>$(LI 每个成员都使用 $(C hasUDA) 来测试，以便确定它是否拥有 $(C Encrypted) 特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Removing them one-by-one from the associative array.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084106Z" creationid="Hipter" creationdate="20160709T084106Z">
        <seg>$(LI 从关联数组中逐个移除它们。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Similar to the previous method, assigning the array's $(C .init) property.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084440Z" creationid="Hipter" creationdate="20160709T084440Z">
        <seg>$(LI 与前一方法相似，用数组的 $(C .init) 属性赋值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Some of the variables that these blocks need may not be accessible within these blocks:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022405Z" creationid="Hipter" creationdate="20160707T022405Z">
        <seg>$(LI 属于块的某些变量，块范围内有可能访问不到：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The act of copying associates an additional variable with an object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020218Z" creationid="Hipter" creationdate="20160707T020218Z">
        <seg>$(LI 复制操作将增加一个与对象关联的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The color attribute of each member is determined with $(C colorAttributeOf()), which we will see below.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T043241Z" creationid="Heromyth" creationdate="20170815T043241Z">
        <seg>$(LI 每个成员的 color 属性可以使用 $(C colorAttributeOf()) 来检测。下面便来看看这个方法。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The duration between each step: This information is used for determining when the robot's next step will be.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234324Z" creationid="Heromyth" creationdate="20170824T234324Z">
        <seg>$(LI 每一步的间隔时间：决定机器人何时走下一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The members of the type are determined by $(C __traits(allMembers)).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T110101Z" creationid="Heromyth" creationdate="20170814T110101Z">
        <seg>$(LI 该类型的所有成员可以通过 $(C __traits(allMembers)) 获得。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The number (id) of the robot: This information is sent back to the owner to identify the robot that the message is related to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234234Z" creationid="Heromyth" creationdate="20170824T234234Z">
        <seg>$(LI 机器人的编号 (id)：这个参数会随着消息传回线程所有者，这样我们就可以通过它确认消息的来源。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The origin: This is where the robot starts moving from.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234259Z" creationid="Heromyth" creationdate="20170824T234259Z">
        <seg>$(LI 起点：机器人的初始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI The value of each member is converted to $(C string) to be used later when printing to the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042044Z" creationid="Heromyth" creationdate="20170815T042044Z">
        <seg>$(LI 每个成员值都被转换为 $(C string)，以便后面输出时使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI There is a $(C d) at the end of the literal $(STRING "résumé"d), specifying its type as an array of $(C dchar)s.)
)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020544Z" creationid="大处着手小处着眼" creationdate="20160714T020544Z">
        <seg>$(LI 有一个 $(C d) 在字面量 $(STRING "résumé"d) 的末尾，指定了它的类型是一个 $(C dchar) 型数组。)
)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI This program uses two indexes to make a slice:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095454Z" creationid="大处着手小处着眼" creationdate="20160714T095340Z">
        <seg>$(LI 这段程序使用两个索引值来生成一个切片：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be accessed at compile time by $(C hasUDA) and $(C __traits(getAttributes)) to alter the way the program is compiled.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053248Z" creationid="Heromyth" creationdate="20170815T053248Z">
        <seg>$(LI 自定义属性在编译时可以通过 $(C hasUDA) 和 $(C __traits(getAttributes)) 来访问，以便达到更改程序编译方式的目的。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be assigned to any declaration.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053036Z" creationid="Heromyth" creationdate="20170815T053036Z">
        <seg>$(LI 自定义属性可用于任何声明。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI User defined attributes can be type names as well as values.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053114Z" creationid="Heromyth" creationdate="20170815T053114Z">
        <seg>$(LI 自定义属性可以是类型名，也可以是具体值。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI Writing all of potentially unrelated expressions in the single $(C finally) block at the bottom separates those expressions from the actual code that they are related to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024639Z" creationid="Hipter" creationdate="20160707T024639Z">
        <seg>$(LI 把所有可能无关联的表达式写在底部单独的 $(C finally) 块，就可以分离那些有关联的可执行代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有必要保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060951Z" creationid="Hipter" creationdate="20160708T060116Z">
        <seg>$(LI 一个类的析构函数不得访问由垃圾回收器管理的成员。这是因为垃圾回收器没有被要求保证该对象及其成员按任何特定顺序终结。当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LI 类的析构函数不必分配新的内存给垃圾回收器。这是因为垃圾回收器没有必要保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T060943Z" creationid="Hipter" creationdate="20160708T055701Z">
        <seg>$(LI 类的析构函数一定不分配由垃圾回收器管理的新内存。这是因为垃圾回收器没有被要求保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(LINK2 /ders/d.en/inheritance.html, Polymorphism) is for abstracting parts of programs from each other and is achieved by class $(I interfaces).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013450Z" creationid="Heromyth" creationdate="20170819T122822Z">
        <seg>$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 实现的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(MONO
$(B
Operation   Value            Meaning)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003833Z" creationid="Heromyth" creationdate="20170820T003833Z">
        <seg>$(MONO
$(B
操作   值            含义)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(OL
$(LI
Providing the index of the element to remove.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144608Z" creationid="Heromyth" creationdate="20170817T144608Z">
        <seg>$(OL
$(LI
提供需要删除的那个元素的索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(OL
$(LI The type of string literals like $(STRING "hello") is $(C string), not $(C char[]), so they are immutable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150351Z" creationid="Hipter" creationdate="20160713T024251Z">
        <seg>$(OL
$(LI 像 $(STRING "hello") 这样的字符串字面量的类型是 $(C string)，而不是 $(C char[])，因此它们是  immutable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(B Hint:) You may want to put the elements in separate arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023612Z" creationid="大处着手小处着眼" creationdate="20160726T023612Z">
        <seg>$(P
$(B 提示：) 你可以把元素放入单独的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(B Reminder:) The element numbers of January and December are 0 and 11 respectively; not 1 and 12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T015216Z" creationid="大处着手小处着眼" creationdate="20160725T015216Z">
        <seg>$(P
$(B 提醒：) 一月和十二月的元素位置数分别是 0 和 11；而不是 1 和 12。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C .clear) removes all elements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034400Z" creationid="Hipter" creationdate="20160709T034400Z">
        <seg>$(P
$(C .clear) 移除全部元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C hasUDA) can be used with an attribute type as well as a specific value of that type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104724Z" creationid="Heromyth" creationdate="20170810T104724Z">
        <seg>$(P
$(C hasUDA) 除了可以与属性类型的特定值一起使用外，还可以与属性类型一起使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C is) specifies whether two class variables provide access to the same class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014640Z" creationid="Hipter" creationdate="20160707T014640Z">
        <seg>$(P
$(C is) 确定两个类变量是否提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C main()) stores the return value of $(C spawn()) under the name $(C worker) and uses that variable when sending messages to the worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233209Z" creationid="Heromyth" creationdate="20170824T233209Z">
        <seg>$(P
$(C main()) 将 $(C spawn()) 的返回值储存在 $(C worker) 变量中并通过它来给工作线程发送消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) can be used without a parameter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021213Z" creationid="Hipter" creationdate="20160712T021213Z">
        <seg>$(P
$(C readln()) 没有参数也可以使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) is more suitable when reading strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015132Z" creationid="Hipter" creationdate="20160712T015132Z">
        <seg>$(P
$(C readln()) 更适合读取字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C readln()) stores the new-line character as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135825Z" creationid="Hipter" creationdate="20160712T015736Z">
        <seg>$(P
$(C readln()) 也存储换行符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C receiveOnly()) can expect only one type of message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235822Z" creationid="Heromyth" creationdate="20170824T235822Z">
        <seg>$(P
$(C receiveOnly()) 只能接收指定的那一个类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C scope) statements can be specified as blocks as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035056Z" creationid="Hipter" creationdate="20160707T035056Z">
        <seg>$(P
$(C scope) 语句也可以像块一样使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C send()) sends messages and $(C receiveOnly()) waits for a message of a particular type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232755Z" creationid="Heromyth" creationdate="20170824T232755Z">
        <seg>$(P
D 语言使用 $(C send()) 发送消息，使用 $(C receiveOnly()) 等待指定类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C spawn()) takes a function pointer as a parameter and starts a new thread from that function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054244Z" creationid="Heromyth" creationdate="20170824T054244Z">
        <seg>$(P
$(C spawn()) 需要一个函数指针，新线程将会从指定的函数启动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C spawnLinked()) is used in the same way as $(C spawn()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052301Z" creationid="Heromyth" creationdate="20170825T052301Z">
        <seg>$(P
$(C spawnLinked()) 与 $(C spawn()) 用法相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.reverse) reverses the elements in place (the first element becomes the last element, etc.):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021752Z" creationid="大处着手小处着眼" creationdate="20160726T021752Z">
        <seg>$(P
$(C std.algorithm.reverse) 反转元素的位置（第一个元素成为最后一个元素，以此类推）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.algorithm.sort) can sort the elements of many types of collections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051323Z" creationid="大处着手小处着眼" creationdate="20160726T021228Z">
        <seg>$(P
$(C std.algorithm.sort) 可以对许多类型集合中的元素进行排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C std.concurrency) does not provide such a convenience for general exception types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044657Z" creationid="Heromyth" creationdate="20170825T044657Z">
        <seg>$(P
$(C std.concurrency) 并未提供这种捕获异常的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(C thisTid()) returns the identifier of the $(I current) thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232250Z" creationid="Heromyth" creationdate="20170824T232250Z">
        <seg>$(P
$(C thisTid()) 返回$(I 当前)线程的 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) An associative array that is defined without any element is $(LINK2 /ders/d.en/null_is.html, $(C null)), not empty.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T143323Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
$(I $(B 注：) 已定义的没有任何元素的关联数组是 $(LINK2 /ders/d.cn/null_is.html, $(C null))，而不是空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) It is usually not proper to access members directly as in the code above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T023005Z" creationid="Hipter" creationdate="20160707T004627Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The indexes above are for demonstration purposes only; they are not stored in the computer's memory.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024515Z" creationid="大处着手小处着眼" creationdate="20160725T024249Z">
        <seg>$(P
$(I $(B 注意：) 上面的索引仅用于演示；并没有存储在计算机的内存中。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) The meaning of the assignment operation is completely different for dynamic arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013455Z" creationid="大处着手小处着眼" creationdate="20160726T013455Z">
        <seg>$(P
$(I $(B 注意：) 赋值运算符的含义与动态数组完全不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B Note:) Unicode does not define how the characters are ordered other than their Unicode codes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T110655Z" creationid="大处着手小处着眼" creationdate="20160715T033832Z">
        <seg>$(P
$(I $(B 注：)除了 Unicode 编码顺序之外，Unicode 不定义字符的排列顺序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020523Z" creationid="Hipter" creationdate="20160708T020523Z">
        <seg>$(P
$(I $(B 注：) 在上面的代码中，一般不这样直接访问成员。若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的一章) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX .init, clearing a variable) $(I $(B Note:) The $(C .init) property of any variable or type is the initial value of that type:)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T084743Z" creationid="Hipter" creationdate="20160709T084655Z">
        <seg>$(P
$(IX .init, 清除一个变量) $(I $(B 注：) 任何变量或类型的 $(C .init) 属性是类型的初始值：)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX :, associative array) Sometimes some of the mappings between the keys and the values are already known at the time of the definition of the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T030702Z" creationid="Hipter" creationdate="20160709T030702Z">
        <seg>$(P
$(IX :, 关联数组) 有时候一些键与值的映射在定义关联数组的时候就已经明确。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX @) The user defined attribute syntax consists of the $(C @) sign followed by the attribute and appear before the declaration that it is being assigned to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T041949Z" creationid="Heromyth" creationdate="20170720T041949Z">
        <seg>$(P
$(IX @)自定义属性的语法格式：符号 $(C @)  的后面紧跟属性名，并且需要放置在与之相关的那个声明前面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX CPU bound) $(IX I/O bound) $(IX thread performance) Every operating system puts limits on the number of threads that can exist at one time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T231837Z" creationid="Heromyth" creationdate="20170824T231837Z">
        <seg>$(P
$(IX CPU bound) $(IX I/O bound) $(IX thread performance) 每个操作系统都有对同时运行线程个数的限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX CPU) $(IX microprocessor) The brain of the computer is the microprocessor (or the CPU, short for $(I central processing unit)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003419Z" creationid="Heromyth" creationdate="20170820T003419Z">
        <seg>$(P
$(IX CPU) $(IX microprocessor) 计算机的大脑是微处理器（CPU，即 $(I 中央处理单元) 的简称)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX MessageMismatch) If the types do not match, a $(C MessageMismatch) exception is thrown:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233608Z" creationid="Heromyth" creationdate="20170824T233608Z">
        <seg>$(P
$(IX MessageMismatch) 如果类型不匹配，程序将会抛出一个 $(C MessageMismatch) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX OOP) $(IX object oriented programming) $(IX user defined type) Similar to structs, $(C class) is a feature for defining new types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T115209Z" creationid="Heromyth" creationdate="20170819T115209Z">
        <seg>$(P
$(IX OOP) $(IX object oriented programming) $(IX user defined type) 与结构相似，$(C class) 具有定义新类型的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T015721Z" creationid="Hipter" creationdate="20160708T015721Z">
        <seg>$(P
$(IX OOP) $(IX 面向对象编程) 与结构相似， $(C class) 具有定义新类型的功能。不同于结构的是，在D语言中，类提供 $(I 面向对象编程) (OOP) 模型。下面是OOP的主要方面：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX Variant, concurrency) $(C std.variant.Variant) is a type that can encapsulate any type of data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T042428Z" creationid="Heromyth" creationdate="20170825T042428Z">
        <seg>$(P
$(IX Variant, concurrency) $(C std.variant.Variant) 类型可以封装任意类型的数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX __traits) $(IX getAttributes) The meaning of attributes is solely determined by the programmer for the needs of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043110Z" creationid="Heromyth" creationdate="20170803T110205Z">
        <seg>$(P
$(IX __traits) $(IX getAttributes) 属性的实际含义完全由程序员根据程序的需要来决定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX final) As overridable member functions have a runtime performance cost, without going into more detail, I recommend that you define all $(C class) functions that do not need to be overridden with the $(C final) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012042Z" creationid="Hipter" creationdate="20160707T012042Z">
        <seg>$(P
$(IX final) 由于可重写的成员函数有一个运行时性能消耗，在这儿不讨论更多细节，我推荐您定义全部没必要用 $(C final) 关键字重写的 $(C class) 成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX finalizer versus destructor) However, different from structs, class destructors are not executed at the time when the lifetime of a class object ends.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T134503Z" creationid="Heromyth" creationdate="20170819T134503Z">
        <seg>$(P
$(IX finalizer versus destructor) 不过，与结构有所不同的是，类的析构函数在类对象的生命期结束时并不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX hasUDA, std.traits) Another useful tool is $(C std.traits.hasUDA), which determines whether a symbol has a specific attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104354Z" creationid="Heromyth" creationdate="20170810T104354Z">
        <seg>$(P
$(IX hasUDA, std.traits) 另一个有用的工具是 $(C std.traits.hasUDA)，它可检测某个符号是否拥有某个特定的属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX message) $(B Message): Data that is passed between threads are called messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054058Z" creationid="Heromyth" creationdate="20170824T054058Z">
        <seg>$(P
$(IX message) $(B 消息)：在线程间传递的数据叫做消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX owner) $(B Owner): Any thread that starts another thread is called the owner of the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054156Z" creationid="Heromyth" creationdate="20170824T054156Z">
        <seg>$(P
$(IX owner) $(B 所有者)：启动线程的线程即为被启动线程的所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX parallelism vs. concurrency) $(IX concurrency vs. parallelism) The following are the differences between parallelism and concurrency:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T011639Z" creationid="Heromyth" creationdate="20170824T011639Z">
        <seg>$(P
$(IX parallelism vs. concurrency) $(IX concurrency vs. parallelism) 下面是并发和并行的区别：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX scalar) That definition can be read as $(I 5 double values).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044231Z" creationid="大处着手小处着眼" creationdate="20160720T030622Z">
        <seg>$(P
$(IX 标量) 这个定义可以理解为 $(I 5 个 double 值)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread id) $(B Thread identifier): Every thread has an id, which is used for specifying recipients of messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054136Z" creationid="Heromyth" creationdate="20170824T054136Z">
        <seg>$(P
$(IX thread id) $(B 线程 ID)：每一个线程都有一个 ID，你可以使用它们指定消息的接收者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX thread) $(B Thread): Operating systems execute programs as work units called $(I threads).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012434Z" creationid="Heromyth" creationdate="20170824T012434Z">
        <seg>$(P
$(IX thread) $(B 线程)：操作系统执行程序的工作单元叫做 $(I 线程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX worker) $(B Worker): Any thread that is started by an owner is called a worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054216Z" creationid="Heromyth" creationdate="20170824T054216Z">
        <seg>$(P
$(IX worker) $(B 工作线程)：被所有者启动的线叫做工作线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类析构函数应该叫 $(I 终结函数)) 。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T151443Z" creationid="Hipter" creationdate="20160707T050655Z">
        <seg>$(P
$(IX 终结与析构) 然而，不同于结构，在一个类对象的生命期结束时，类的析构函数并不执行。正如上面我们看到的，析构函数在一个垃圾回收周期内的未来某个时候执行。(通过这样的区分，更准确的说，类的析构函数应该叫 $(I 终结函数)) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
$(LINK_DOWNLOAD /ders/d.en/Programming_in_D_code_samples.zip, Click here to download code samples as a $(C .zip) file.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052452Z" creationid="Heromyth" creationdate="20170801T052326Z">
        <seg>$(P
$(LINK_DOWNLOAD /ders/d.en/Programming_in_D_code_samples.zip, 点击此处可下载 $(C .zip) 文件形式的示例代码。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A class variable on the other hand is a language feature for accessing class objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013346Z" creationid="Heromyth" creationdate="20170820T013346Z">
        <seg>$(P
另一方面，类变量一种访问类对象的语言功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
A compiler is another tool that reads the instructions of a program from source code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004725Z" creationid="Heromyth" creationdate="20170820T004725Z">
        <seg>$(P
编译器是另一种从源码中读取程序指令的工具。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Accordingly, the equivalent of the five separate variables above can be defined as an array of five values using the following syntax:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T025431Z" creationid="大处着手小处着眼" creationdate="20160720T025022Z">
        <seg>$(P
因此，上面的五个独立的变量可以等效的使用下面的语法定义为含五个值的数组：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Additionally, as a consequence of their ASCII code values, all of the latin uppercase letters are sorted before all of the lowercase letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143655Z" creationid="大处着手小处着眼" creationdate="20160715T143655Z">
        <seg>$(P
另外，受 ASCII 编码值的影响，所有拉丁大写字母都排在小写字母的前面。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Additionally, the length of dynamic arrays can be changed by assigning a value to this property:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072227Z" creationid="大处着手小处着眼" creationdate="20160725T072227Z">
        <seg>$(P
另外，通过对这个 property 指定一个值就可以修改动态数组的 length：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
All of the elements of the $(C values) array above are initialized to $(C double.nan):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082906Z" creationid="大处着手小处着眼" creationdate="20160725T082906Z">
        <seg>$(P
上面 $(C values) 数组的所有元素都初始化为 $(C double.nan)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
All of the messages in this simple program go from the worker to the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234607Z" creationid="Heromyth" creationdate="20170824T234607Z">
        <seg>$(P
本例中的所有消息都是从工作线程向线程所有者传递的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Also available as $(LINK2 https://gumroad.com/l/PinD, $(I pay-what-you-want) eBooks at Gumroad) and $(I free) here as $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.pdf, PDF), $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.epub, EPUB), $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.azw3, AZW3), and $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.mobi, MOBI).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T012601Z" creationid="Heromyth" creationdate="20170801T042848Z">
        <seg>$(P
其他提供形式还包括：$(LINK2 https://gumroad.com/l/PinD, Gumroad提供的$(I 按需支付) 电子书) 以及各种$(I 免费) 版本的电子书，如 $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.pdf, PDF)、$(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.epub, EPUB)、$(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.azw3, AZW3) 和 $(LINK_DOWNLOAD http://ddili.org/ders/d.en/Programming_in_D.mobi, MOBI)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although "résumé" contains six $(I letters), the length of the $(C string) is the number of UTF-8 code units that it contains:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T001021Z" creationid="大处着手小处着眼" creationdate="20160714T012628Z">
        <seg>$(P
虽然 "résumé" 包含6个$(I 字母)，但$(C 字符串)的长度是它包含的 UTF-8 编码单元的个数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although member functions are defined and used the same way as structs, there is an important difference: Class member functions can be and by-default are $(I overridable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005644Z" creationid="Hipter" creationdate="20160707T005311Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although the syntax makes it look as if a member of the $(I variable) is being accessed, it is actually the member of the $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004236Z" creationid="Hipter" creationdate="20160707T004236Z">
        <seg>$(P
虽然语法上看起来像访问 $(I 变量) 的成员，实际上是 $(I 对象) 的成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Although these statements are closely related to exceptions, they can be used without a $(C try-catch) block.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025855Z" creationid="Hipter" creationdate="20160707T025855Z">
        <seg>$(P
虽然这些语句只在特殊情况下使用，但是没有 $(C try-catch) 块也能用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An attribute can be a type name as well as a value of a user defined or a fundamental type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043344Z" creationid="Heromyth" creationdate="20170803T043344Z">
        <seg>$(P
属性除了可以是自定义类型值或基础类型值以外，还可是以类型名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An index need not be a constant value; the value of a variable can also be used as an index, making arrays even more useful.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021213Z" creationid="大处着手小处着眼" creationdate="20160725T021213Z">
        <seg>$(P
索引不必是恒定值；变量的值也能用作索引，这会让数组更有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
An interpreter is a tool (a program) that reads the instructions from source code and executes them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004237Z" creationid="Heromyth" creationdate="20170820T004237Z">
        <seg>$(P
解释器是一种能从源码中读取指令并执行相应命令的工具（程序）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another difference from structs is that some member functions are automatically inherited from the $(C Object) class.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T012709Z" creationid="Hipter" creationdate="20160707T012709Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Another method would be to send the actual exception object itself to the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051841Z" creationid="Heromyth" creationdate="20170825T051841Z">
        <seg>$(P
另外一种方法是直接将将异常对象发送回所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Any declaration (e.g. struct type, class type, variable, etc.) can be assigned attributes, which can then be accessed at compile time to alter the way the code is compiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170719T105759Z" creationid="Heromyth" creationdate="20170719T105759Z">
        <seg>$(P
所有声明（如结构、类和变量等）都可以加上属性，以便在编译时访问这些属性来调整该部分代码的编译方式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Array elements can be removed with the $(C remove()) function from the $(C std.algorithm) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T143321Z" creationid="Heromyth" creationdate="20170817T143321Z">
        <seg>$(P
可以使用模块 $(C std.algorithm) 里的 $(C remove()) 函数删除数组元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays are containers where the elements are placed side by side in the computer's memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T023531Z" creationid="大处着手小处着眼" creationdate="20160725T023454Z">
        <seg>$(P
数组是容器，其中的元素在计算机的内存中是逐个放置的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays are useful in such cases: the array feature allows us to define a single variable that stores multiple values together.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022057Z" creationid="大处着手小处着眼" creationdate="20160720T021831Z">
        <seg>$(P
数组在这种情况下是有用的：数组功能允许我们定义一个把多个值存储到一起的单个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays have properties as well, of which we will see only $(C .length) here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T071857Z" creationid="大处着手小处着眼" creationdate="20160725T071857Z">
        <seg>$(P
数组也有 properties（属性），在这儿我们只会看到 $(C .length)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Arrays provide convenience operations that apply to all of their elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012802Z" creationid="大处着手小处着眼" creationdate="20160726T012802Z">
        <seg>$(P
数组提供了适用于所有元素的方便操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As a result, the objects that are associated with $(C var1) and $(C var2) are different.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T132622Z" creationid="Hipter" creationdate="20160706T023913Z">
        <seg>$(P
最后，与 $(C var1) 和 $(C var2) 关联的那些对象并不相同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As an example, let's write the function above with a $(C scope(failure)) statement:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T030221Z" creationid="Hipter" creationdate="20160707T030221Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As it has been mentioned briefly in $(LINK2 /ders/d.en/null_is.html, The $(CH4 null) Value and the $(CH4 is) Operator chapter), class variables can be $(C null).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013535Z" creationid="Heromyth" creationdate="20170819T124929Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, $(CH4 null) 值和 $(CH4 is) 运算符一章)已提到过，类变量可以为 $(C null)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As it is indicated in their documentation, the return types of $(C indexOf()) and $(C lastIndexOf()) are not $(C int) nor $(C size_t), but $(C ptrdiff_t).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154528Z" creationid="大处着手小处着眼" creationdate="20160715T144120Z">
        <seg>$(P
与它们的文档中所指出的一样，$(C indexOf()) 和 $(C lastIndexOf()) 的返回类型既不是 $(C int) 也不是 $(C size_t)，而是 $(C ptrdiff_t)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As seen in the outputs, the blocks of the $(C scope) statements are executed in reverse order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045137Z" creationid="Hipter" creationdate="20160707T035844Z">
        <seg>$(P
在输出中我们看到，$(C scope) 语句块是按相反的顺序执行的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As soon as a new thread is started, the owner and the worker start executing separately as if they were independent programs:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054625Z" creationid="Heromyth" creationdate="20170824T054625Z">
        <seg>$(P
新线程启动后，所有者和工作线程将会独立执行，看上去它们就像是独立的程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As the compiler compiles a program according to the rules of the language, it stops the compilation as soon as it comes across $(I illegal) instructions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005114Z" creationid="Heromyth" creationdate="20170820T005114Z">
        <seg>$(P
当编译器按照语言规则编译程序时，一旦碰到 $(I 非法) 指令就会停止编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we have seen in the previous chapter, expressions that must always be executed are written in the $(C finally) block, and expressions that must be executed when there are error conditions are written in $(C catch) blocks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T021804Z" creationid="Hipter" creationdate="20160707T021608Z">
        <seg>$(P
在前面的章节我们已经看到，写在 $(C finally) 块里的表达式一定总被执行。当有错误条件的时候，写在 $(C catch) 块里的表达式总被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we have seen in the previous chapter, the facilities of the $(C std.parallelism) module automatically catch exceptions that have been thrown during the execution of tasks and rethrow them in the context of the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044635Z" creationid="Heromyth" creationdate="20170825T044635Z">
        <seg>$(P
上一章的 $(C std.parallelism) 自动捕获 task 执行中抛出的异常并在所有者的线程中重新抛出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As we will see later in $(LINK2 /ders/d.en/memory.html, the Memory Management chapter), class destructors must observe the following rules:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001603Z" creationid="Heromyth" creationdate="20170820T001603Z">
        <seg>$(P
在后面的 $(LINK2 /ders/d.en/memory.html, 内存管理一章) 将会看到，类的析构函数必须遵循以下几条规则：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the constructor is $(C this).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032221Z" creationid="Hipter" creationdate="20160706T032221Z">
        <seg>$(P
与结构一样，构造函数的名称是 $(C this) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As with structs, the name of the destructor is $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033855Z" creationid="Hipter" creationdate="20160706T033855Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As you can see, the $(C monthDays) array is defined and initialized at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T004534Z" creationid="大处着手小处着眼" creationdate="20160726T004534Z">
        <seg>$(P
正如你所看到的，$(C monthDays) 数组在定义的时候就已初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
As you would also remember, comparing a reference to $(C null) by the $(C ==) or the $(C !=) operator is an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130303Z" creationid="Heromyth" creationdate="20170819T130303Z">
        <seg>$(P
大家都还记得吧，引用与运算符 $(C null) 不能通过运算符 $(C ==) 或 $(C !=) 进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assigning to a class variable disassociates that variable from its current object and associates it with a new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T030537Z" creationid="Hipter" creationdate="20160706T030537Z">
        <seg>$(P
给类变量赋值，会解除变量与当前对象的关联，并关联到一个新对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays allow indexing not only using integers but also using any other type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085816Z" creationid="Hipter" creationdate="20160708T085816Z">
        <seg>$(P
关联数组允许索引不只是整型而是任何类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are a feature that is found in most modern high-level languages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092745Z" creationid="Hipter" creationdate="20160708T014736Z">
        <seg>$(P
关联数组是大多数现代高级编程语言所具有的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays are implemented in D using a $(I hash table).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023247Z" creationid="Hipter" creationdate="20160708T091112Z">
        <seg>$(P
在D语言中，关联数组是一个 $(I hash 表) 实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Associative arrays make it easy to access the grades by the name of the student as in $(C grades["emre"]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030054Z" creationid="Hipter" creationdate="20160709T092116Z">
        <seg>$(P
在 $(C grades["emre"]) 中通过学生姓名关联数组让它很容易访问到成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Assume that an associative array is used for storing student grades.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085200Z" creationid="Hipter" creationdate="20160709T085200Z">
        <seg>$(P
假设使用关联数组来存储学生成绩。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because Unicode adopts the letters of the basic Latin alphabet from the ASCII table, the strings that contain only the letters of the ASCII table will always be ordered correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153844Z" creationid="大处着手小处着眼" creationdate="20160715T035730Z">
        <seg>$(P
由于 Unicode 采用来自于 ASCII 表的基本拉丁字母，仅包含 ASCII 字母的字符串将会正确排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because all of the Unicode characters of "résumé" can be represented by a single $(C wchar) or $(C dchar), the last two lengths are equal to the number of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T143937Z" creationid="大处着手小处着眼" creationdate="20160715T031823Z">
        <seg>$(P
因为所有的“résumé”的 Unicode 字符都能用单个 $(C wchar) 或者 $(C dchar) 表示，所以最后两个的长度与字符个数是一致的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because classes are reference types, defining a new class variable as a copy of another makes two variables that provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012453Z" creationid="Hipter" creationdate="20160706T012143Z">
        <seg>$(P
因为类是引用类型，定义一个新的类变量做为另一个副本，将产生两个访问同一对象的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because each character has a unique code, every letter variant is different from the others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151559Z" creationid="大处着手小处着眼" creationdate="20160715T143244Z">
        <seg>$(P
因为每个字母都有一个唯一的编码，每个字母变体都与其它的不同。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Because strings are arrays (and as a corollary, $(I ranges)), the functions of the $(C std.array), $(C std.algorithm), and $(C std.range) modules are very useful with strings as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T124852Z" creationid="大处着手小处着眼" creationdate="20160715T143825Z">
        <seg>$(P
因为字符串是数组(进一步而言，是 $(I range))，所以 $(C std.array)、$(C std.algorithm) 和 $(C std.range) 模块中的函数对于字符串也都非常有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Being character arrays, strings can contain control characters like $(STRING '\n') as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T092733Z" creationid="Hipter" creationdate="20160711T092733Z">
        <seg>$(P
作为字符数组，字符串能包含像 $(STRING '\n') 这样的控制字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Being so close to hardware, machine code is not suitable for representing higher level concepts like $(I a playing card) or $(I a student record).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004014Z" creationid="Heromyth" creationdate="20170820T004014Z">
        <seg>$(P
由于机器码太靠近硬件，因此它并不适合用于表示 $(I 扑克牌) 或 $(I 学生记录) 等较为高级的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both $(C readf()) and $(C formattedRead()) $(I return) the number of items that they could parse and convert successfully.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063405Z" creationid="Hipter" creationdate="20160712T035510Z">
        <seg>$(P
$(C readf()) 和 $(C formattedRead()) 函数 都可以$(I 返回)成功解析及转换的项目个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both of the arrays that we have defined above are fixed-length arrays because their element counts are specified as 5 and 12 at the time when the program is written.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033000Z" creationid="大处着手小处着眼" creationdate="20160725T033000Z">
        <seg>$(P
上面我们定义的数组都为定长数组，因为元素的个数在写程序时已指定为 5 和 12。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Both of the variables above provide access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015547Z" creationid="Hipter" creationdate="20160707T015547Z">
        <seg>$(P
上面的两个变量都提供对同一对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Class objects are constructed by the $(C new) keyword; they do not have names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131126Z" creationid="Heromyth" creationdate="20170819T131126Z">
        <seg>$(P
类对象由关键字 $(C new) 构造；它们没有名字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Class variable and class object are separate concepts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130812Z" creationid="Heromyth" creationdate="20170819T130812Z">
        <seg>$(P
类变量和类对象是独立的概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Classes are defined by the $(C class) keyword instead of the $(C struct) keyword:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032013Z" creationid="Hipter" creationdate="20160706T032013Z">
        <seg>$(P
类由 $(C class) 关键字定义而不是 $(C struct) 关键字：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Concurrency is similar to but different from the topic of the previous chapter, parallelism.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T011602Z" creationid="Heromyth" creationdate="20170824T011602Z">
        <seg>$(P
虽然并发（concurrency）与并行（parallelism）很相似，但我们不能将其混为一谈。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Conversely, the owner of a worker thread is obtained by the $(C ownerTid()) function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232630Z" creationid="Heromyth" creationdate="20170824T232630Z">
        <seg>$(P
与之相对的是在工作线程中使用 $(C ownerTid()) 获取其所有者的 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Copying affects only the variables, not the object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011948Z" creationid="Hipter" creationdate="20160706T011948Z">
        <seg>$(P
复制只影响变量，而不是对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
D supports both models of concurrency: message passing and data sharing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012320Z" creationid="Heromyth" creationdate="20170824T012320Z">
        <seg>$(P
D 语言支持两种并发模型：消息传递和数据共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Data structures that bring elements of a certain type together are called $(I containers).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143201Z" creationid="大处着手小处着眼" creationdate="20160723T141510Z">
        <seg>$(P
聚集特定类型元素的数据结构称为 $(I 容器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Defining dynamic arrays is simpler than defining fixed-length arrays because omitting the length makes a dynamic array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033657Z" creationid="大处着手小处着眼" creationdate="20160725T033657Z">
        <seg>$(P
因为省略了长度，所以定义动态数组比定长数组简单：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Encapsulation is achieved by $(I protection attributes), which we will see in $(LINK2 /ders/d.en/encapsulation.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013433Z" creationid="Heromyth" creationdate="20170819T122633Z">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现的，关于这一点在 $(LINK2 /ders/d.cn/encapsulation.html, 后面章节) 会看到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Fix the bugs of this program and make it work as expected:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051752Z" creationid="大处着手小处着眼" creationdate="20160726T024805Z">
        <seg>$(P
请修复程序的 bug，让它按预期的方式执行：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Fixed-length arrays are also known as static arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033913Z" creationid="大处着手小处着眼" creationdate="20160725T033844Z">
        <seg>$(P
定长数组也被称为静态数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, an associative array that maps day names of type $(C string) to day numbers of type $(C int) can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T095549Z" creationid="Hipter" creationdate="20160708T095549Z">
        <seg>$(P
例如，下面这个关联数组这样定义，它把日期名的类型 $(C string) 映射到日期的数字类型 $(C int) ：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the following $(C receive()) call specifies two message handlers that handle messages of types $(C int) and $(C string), respectively:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000100Z" creationid="Heromyth" creationdate="20170825T000100Z">
        <seg>$(P
例如，下面这个 $(C receive()) 使用了两个委托分别用来处理类型为 $(C int) 和 $(C string) 的消息：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, the following code that tries to capitalize the first letter of a $(C string) would cause a compilation error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T134044Z" creationid="Hipter" creationdate="20160712T082540Z">
        <seg>$(P
例如，下面这段代码尝试着修改 $(C string) 的首字母为大写，这将引发一个编译错误： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For example, when the following numbers are entered,
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023108Z" creationid="大处着手小处着眼" creationdate="20160726T023000Z">
        <seg>$(P
例如，当输入了下面的数字，
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For plain arrays, index values are not stored at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T092502Z" creationid="Hipter" creationdate="20160708T092502Z">
        <seg>$(P
对于简单数组，索引值根本就没有存储。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For reasons like safety and performance, some languages have been designed to be compiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005003Z" creationid="Heromyth" creationdate="20170820T005003Z">
        <seg>$(P
出于对安全及效率等原因的考量，某些语言被设计为可编译的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
For that syntax to work, a constructor must be defined explicitly by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T033504Z" creationid="Hipter" creationdate="20160706T033504Z">
        <seg>$(P
那样的语法要通过编译，就需要程序员显式的定义构造函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Further, $(C printAsXML()) and the attributes that it considers can be used with other types as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042701Z" creationid="Heromyth" creationdate="20170816T042701Z">
        <seg>$(P
此外，$(C printAsXML()) 和它涉及到的属性还可以与其他类型一起使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is a program that prints the Turkish names of colors that are specified in English:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133329Z" creationid="Hipter" creationdate="20160709T083500Z">
        <seg>$(P
这是一段打印英文颜色的土耳其语表达的程序，它的键指定为英文：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is another function that tests all three of these statements:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035222Z" creationid="Hipter" creationdate="20160707T035222Z">
        <seg>$(P
这儿是另一个函数，来测试全部三个语句：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Here is the complete program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234706Z" creationid="Heromyth" creationdate="20170824T234706Z">
        <seg>$(P
下面是完整的程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
How can you solve this problem?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092601Z" creationid="Hipter" creationdate="20160709T092601Z">
        <seg>$(P
怎么解决这个问题？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, programming languages adhere to much more strict and formal rules than any spoken language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004212Z" creationid="Heromyth" creationdate="20170820T004212Z">
        <seg>$(P
然而，编程语言依然比口语更严格、正规。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
However, there are important differences between classes and structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123940Z" creationid="Heromyth" creationdate="20170819T123940Z">
        <seg>$(P
然而，类与结构之间有重要的区别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
I will start using that form after introducing the $(C string) type below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T131706Z" creationid="Hipter" creationdate="20160712T021829Z">
        <seg>$(P
在介绍了下面的 $(C string) 类型之后，我们将开始使用这种格式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If an exception is thrown, the output includes the $(C scope(exit)) and $(C scope(failure)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035711Z" creationid="Hipter" creationdate="20160707T035711Z">
        <seg>$(P
如果抛出异常， 输出包括 $(C scope(exit)) 和 $(C scope(failure)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If no exception is thrown, the output of the function includes only the $(C scope(exit)) and $(C scope(success)) expressions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T035723Z" creationid="Hipter" creationdate="20160707T035405Z">
        <seg>$(P
如果没有抛出异常， 函数的输出只包括 $(C scope(exit)) 和 $(C scope(success)) 表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If the array sizes are not equal, the program is terminated with an error during assignment:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T020045Z" creationid="大处着手小处着眼" creationdate="20160726T020045Z">
        <seg>$(P
如果数组大小不一致，会导致赋值期间出错而终止程序：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
If there is no other class variable that still provides access to the object that has been disassociated from, then that object is going to be destroyed some time in the future by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031054Z" creationid="Hipter" creationdate="20160706T031054Z">
        <seg>$(P
如何没有别的类变量能访问已解除关联对象，那该对象将由垃圾回收器在将来某个时候销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In any case, keep in mind that the use of $(C dchar[]) and $(C dstring) does not solve all of the problems of manipulating Unicode characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T021458Z" creationid="大处着手小处着眼" creationdate="20160714T021458Z">
        <seg>$(P
无论如何，请记住使用 $(C dchar[]) 和 $(C dstring) 并不能解决所有的操作 Unicode 字符的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In general, classes are very similar to structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123716Z" creationid="Heromyth" creationdate="20170819T123716Z">
        <seg>$(P
一般情况下，类与结构非常相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In order to differentiate the variables in the exercise of the previous chapter, we had to append an underscore and a number to their names as in $(C value_1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T021122Z" creationid="大处着手小处着眼" creationdate="20160723T151308Z">
        <seg>$(P
为了与前一章练习中的变量有所区别，我们给变量的名字加上了下划线与数字，像 $(C value_1) 这样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In summary, the definition of an array variable consists of the type of the values, the number of values, and the name of the variable that refers to the array of values:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032617Z" creationid="大处着手小处着眼" creationdate="20160720T031809Z">
        <seg>$(P
总之，数组变量的定义包括值的类型、 值的个数和涉及数组值的变量名称：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In summary, the owner is identified by $(C ownerTid) and the worker is identified by the return value of $(C spawn()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232710Z" creationid="Heromyth" creationdate="20170824T232710Z">
        <seg>$(P
总之，调用 $(C ownerTid) 获取其所有者 ID，通过 $(C spawn()) 的返回值获取工作线程 ID。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
In the code above, $(C variable2) is being initialized by $(C variable1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T021450Z" creationid="Hipter" creationdate="20160706T021450Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is equally wrong to allocate new memory $(I indirectly) from the garbage collector in a destructor.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002405Z" creationid="Heromyth" creationdate="20170820T002405Z">
        <seg>$(P
在析构函数里 $(I 间接地) 从垃圾回收器里分配新的内存，这种做法同样是错的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is not possible to add elements to fixed-length arrays:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T014134Z" creationid="大处着手小处着眼" creationdate="20160726T014134Z">
        <seg>$(P
不可能给定长数组添加元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is possible to define variables with the $(C auto) keyword, which we will see in a later chapter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144206Z" creationid="大处着手小处着眼" creationdate="20160715T144206Z">
        <seg>$(P
也可以使用 $(C auto) 关键字定义变量，这个我们将在后面的一章中看到：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It is possible to send more than one value as a part of the same message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233324Z" creationid="Heromyth" creationdate="20170824T233324Z">
        <seg>$(P
也可以在一次消息中发送多个值，这些值都会成为这次消息的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
It may not make sense to wait for messages beyond a certain time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043226Z" creationid="Heromyth" creationdate="20170825T043226Z">
        <seg>$(P
可能经过一段时间后就不再需要继续等待消息了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Just like copying, assignment affects only the variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024635Z" creationid="Hipter" creationdate="20160706T024635Z">
        <seg>$(P
就像复制，赋值只影响变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Key-value pairs can be removed by using $(C .remove()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032137Z">
        <seg>$(P
通过 $(C .remove()) 可以移除键值对：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Lambda functions and objects of types that define the $(C opCall()) member function can also be passed to $(C receive()) as message handlers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000506Z" creationid="Heromyth" creationdate="20170825T000429Z">
        <seg>$(P
lambda 函数和定义了 $(C opCall()) 成员函数的对象都可以传递给 $(C receive()) 作为消息处理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the following code that we have seen previously in the $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types chapter):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011152Z" creationid="Hipter" creationdate="20160706T011152Z">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's consider the following code that we saw previously in the $(LINK2 /ders/d.en/value_vs_reference.html, Value Types and Reference Types chapter):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013414Z" creationid="Heromyth" creationdate="20170819T131840Z">
        <seg>$(P
一起来看看下面这段代码，之前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型一章)已见过，如下所示：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's design a function template that prints the values of all members of a $(C struct) object in XML format.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103704Z" creationid="Heromyth" creationdate="20170814T103704Z">
        <seg>$(P
一起来设计一个函数模板，让它以XML格式输出一个 $(C struct) 对象的所有成员的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's now revisit the exercise with the five values and write it again by using an array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072509Z" creationid="大处着手小处着眼" creationdate="20160725T072501Z">
        <seg>$(P
现在我们重温一下使用五个值的例子，用数组重写一下它：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Let's use what we have seen so far in a simulation program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234055Z" creationid="Heromyth" creationdate="20170824T234055Z">
        <seg>$(P
现在我们在一个模拟程序里实践一下刚了解到的内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Like every variable in D, the elements of arrays are automatically initialized.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082520Z" creationid="大处着手小处着眼" creationdate="20160725T082520Z">
        <seg>$(P
像在 D 语言中的每个变量，数组的元素自动初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Messages of type $(C int) would match $(C intHandler()) and messages of type $(C string) would match $(C stringHandler()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000129Z" creationid="Heromyth" creationdate="20170825T000129Z">
        <seg>$(P
$(C int) 消息匹配 $(C intHandler())，而 $(C string) 消息匹配 $(C stringHandler())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Most CPU architectures use machine code specific to that particular architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003639Z" creationid="Heromyth" creationdate="20170820T003620Z">
        <seg>$(P
大多数 CPU 都使用特定架构的机器码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Multiple attributes can be specified separately or as a parenthesized list of attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042405Z" creationid="Heromyth" creationdate="20170720T042405Z">
        <seg>$(P
多个属性可以分别指定，也可以采用括号列表形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Obviously, the values of the elements can be changed later during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083134Z" creationid="大处着手小处着眼" creationdate="20160725T083134Z">
        <seg>$(P
显然，元素的值可以在以后程序执行期间发生变化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other hand, associative arrays do store both the keys and the values of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T093619Z" creationid="Hipter" creationdate="20160708T093619Z">
        <seg>$(P
另一方面，关联数组既存储键又存储元素值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
On the other side, the worker receives the message that it needs as an $(C int), uses that value in a calculation, and sends the result as type $(C double) to its owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233236Z" creationid="Heromyth" creationdate="20170824T233236Z">
        <seg>$(P
另一方面，工作线程需要 $(C int) 类型的消息并对其进行计算，之后将计算得到的 $(C double) 类型的结果返回给其所有者：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Once a line is read from the input or from any other source, it is possible to parse and convert separate data that it may contain with $(C formattedRead()) of the $(C std.format) module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T142725Z" creationid="Hipter" creationdate="20160712T031338Z">
        <seg>$(P
一但从输入流或其它任何来源中读取了一行字符，就可以用 $(C std.format) 模块的 $(C formattedRead()) 函数来解析并转换它所包含的独立数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One thing that the worker can do is to catch the exception explicitly and to send it as a special error message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045106Z" creationid="Heromyth" creationdate="20170825T045106Z">
        <seg>$(P
工作线程能做的就是手动捕获异常并将其作为特殊的错误信息发送给所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
One way of terminating the standard input stream in a terminal is pressing Ctrl-D under Unix-based systems and Ctrl-Z under Windows systems.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T005431Z" creationid="Hipter" creationdate="20160712T004913Z">
        <seg>$(P
在终端结束标准输入流的方法随系统而不同，在 Unix 系统下按 Ctrl-D，在 Windows 系统下按 Ctrl-Z。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Only the index values between zero and one less than the length of the array are valid.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T032531Z" creationid="大处着手小处着眼" creationdate="20160725T022637Z">
        <seg>$(P
只有与数组长度的差值在 0 与 1 之间的索引才有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Other than the fact that $(C opAssign) cannot be overloaded for classes, operator overloading is the same as structs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005026Z" creationid="Hipter" creationdate="20160707T005026Z">
        <seg>$(P
虽然 $(C opAssign) 不能被类重载，但与结构一样，可以实现运算符重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Please note the two differences in the new code:
)
$(OL
$(LI The type of the string is $(C dchar[]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020223Z" creationid="大处着手小处着眼" creationdate="20160714T020156Z">
        <seg>$(P
请注意新代码的两个不同：
)
$(OL
$(LI 字符串的类型是 $(C dchar[])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Programming languages are designed as efficient ways of programming a CPU, capable of representing higher-level concepts.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004037Z" creationid="Heromyth" creationdate="20170820T004037Z">
        <seg>$(P
编程语言的设计目标是用来对 CPU 高效编程，且有能力描述高级概念。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Same as structs, the members are accessed by the $(I dot) operator:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002609Z" creationid="Hipter" creationdate="20160707T004024Z">
        <seg>$(P
与结构一样，可以使用 $(I 点) 运算符来访问成员：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, $(C char[]) cannot be used where a $(C string) is needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T030046Z" creationid="Hipter" creationdate="20160713T030046Z">
        <seg>$(P
同样的，$(C char[]) 不能被用到需要 $(C string) 的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, an $(C immutable) copy of an object can be provided by a member function appropriately named $(C idup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133836Z" creationid="Heromyth" creationdate="20170819T132306Z">
        <seg>$(P
同样地，可以通过名为 $(C idup()) 的成员函数的提供对象的  $(C immutable) 副本：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Similarly, an $(C immutable) copy of an object can be provided by a member function appropriately named $(C idup()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T024412Z" creationid="Hipter" creationdate="20160706T024412Z">
        <seg>$(P
同样的，可以由命名为 $(C idup()) 的适当的成员函数提供对象的 $(C immutable) 副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since $(C char[]) is mutable and $(C string) is not, there is a mismatch.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T024802Z" creationid="Hipter" creationdate="20160713T024802Z">
        <seg>$(P
由于 $(C char[]) 可变而 $(C string) 不可变，两者不批配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since it is more beneficial for you to debug the third mistake yourself, I would like you to first run the program after fixing the previous two bugs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084348Z" creationid="大处着手小处着眼" creationdate="20160726T031903Z">
        <seg>$(P
自行调试第三个错误对你来说更有益，建议你在修复了前两个 bug 之后先运行一下程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since no object gets copied, the postblit function $(C this(this)) is not available for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T013216Z" creationid="Hipter" creationdate="20160706T013139Z">
        <seg>$(P
由于没有复制对象， postblit 函数 $(C this(this)) 不能用于类变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the array does not contain a value for the key $(STRING "purple"), $(C .get()) returns -1:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094942Z" creationid="Hipter" creationdate="20160709T042816Z">
        <seg>$(P
由于键 $(STRING "purple") 的值不在数组中，$(C .get()) 返回 -1：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since the objects of $(C myKing) and $(C yourKing) variables are different, the $(C !is) operator returns $(C true).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015100Z" creationid="Hipter" creationdate="20160707T015100Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Since they are actually arrays, all of the array operations can be applied to strings as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033032Z" creationid="大处着手小处着眼" creationdate="20160715T033032Z">
        <seg>$(P
由于它们实际上是数组，所有数组的操作也都能应用到字符串上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Some languages like Perl, Python and Ruby have been designed to be very flexible and dynamic, making code analysis harder.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004655Z" creationid="Heromyth" creationdate="20170820T004655Z">
        <seg>$(P
一些语言被设计得非常灵活与动态，诸如 Perl、Python 和 Ruby，这使得代码分析困难重重。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Sometimes it makes sense to use a default value if a key does not exist in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035616Z" creationid="Hipter" creationdate="20160709T035616Z">
        <seg>$(P
有时候在关联数组中，为不存在的键使用一个默认值是有道理的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Sometimes the desired values of the elements are known at the time when the array is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083707Z" creationid="大处着手小处着眼" creationdate="20160725T083707Z">
        <seg>$(P
有时在数组定义时元素的期望值是已知的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Such control characters as well as all whitespace characters at both ends of strings can be removed by $(C std.string.strip):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140053Z" creationid="Hipter" creationdate="20160712T020538Z">
        <seg>$(P
像字符串两端的空白字符这样的控制字符能被 $(C std.string.strip) 移除：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That also happened when reading a value from the input:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083509Z" creationid="大处着手小处着眼" creationdate="20160725T083509Z">
        <seg>$(P
从输入流中读取值时也发生了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That expression can be read as $(I the element with the number 0 of the array named values).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T022700Z" creationid="大处着手小处着眼" creationdate="20160724T022700Z">
        <seg>$(P
这个表达式可以理解为 $(I 数组 values 位置 0 处的元素)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That function first modifies the reference parameter and then reverts this modification when an exception is thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022649Z" creationid="Hipter" creationdate="20160707T022649Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That information can be stored in the following $(C Job) struct:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234348Z" creationid="Heromyth" creationdate="20170824T234348Z">
        <seg>$(P
这些信息可以储存在下面这个 $(C Job) 结构中：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
That solution may be slow especially for large arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T141716Z" creationid="Hipter" creationdate="20160711T012152Z">
        <seg>$(P
对于大型数组这恐怕会非常慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C calculate()) function below receives $(C string) messages, converts them to $(C double), adds 0.5, and sends the result back as a message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044801Z" creationid="Heromyth" creationdate="20170825T044801Z">
        <seg>$(P
下面这个 $(C calculate()) 接收一个 $(C string) 消息，将其转换为 $(C double) 并加 0.5，之后将运算的结果作为消息传递回去：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C colorAttributeOf()) function template can be implemented as in the following code:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052323Z" creationid="Heromyth" creationdate="20170815T052323Z">
        <seg>$(P
函数模板 $(C colorAttributeOf()) 可以实现成下面的样子：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dayNumbers) variable above is an associative array that can be used as a table that provides a mapping from day names to day numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030402Z" creationid="Hipter" creationdate="20160708T141034Z">
        <seg>$(P
上面的 $(C dayNumbers) 变量是一个关联数组，它能用来作为从日期名映射到日期数字的表。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C dup()) member function makes a new object by taking advantage of the constructor of $(C Foo) and returns the new object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023149Z" creationid="Hipter" creationdate="20160706T023149Z">
        <seg>$(P
$(C dup())  成员函数利用 $(C Foo) 的构造函数，创建并返回新的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C in) operator determines whether a given key exists in the associative array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035220Z" creationid="Hipter" creationdate="20160709T035220Z">
        <seg>$(P
$(C in) 运算符确定一个给定的键是否存在于关联数组中：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C new) keyword constructs an anonymous class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T011520Z" creationid="Hipter" creationdate="20160706T011520Z">
        <seg>$(P
 $(C new) 关键字构造了一个匿名的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope(failure)) statement above ensures that the $(C r -= addend) expression will be executed if the function's scope is exited due to an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T033858Z" creationid="Hipter" creationdate="20160707T033858Z">
        <seg>$(P
上面的 $(C scope(failure)) 确保 $(C r -= addend) 表达式在因异常退出时被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C scope) statements have similar functionality with the $(C catch) and $(C finally) scopes but they are better in many respects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T024746Z" creationid="Hipter" creationdate="20160707T024746Z">
        <seg>$(P
$(C scope) 语句与 $(C catch) 和 $(C finally) 有相似功能，但在许多方面表现的更好。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C strip()) expression above returns a new string that does not contain the trailing control characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160719T150826Z" creationid="Hipter" creationdate="20160712T020830Z">
        <seg>$(P
上面的 $(C strip()) 表达式返回一个不包含尾随控制符的新字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C to!double()) call above would throw an exception if the string cannot be converted to a $(C double) value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044939Z" creationid="Heromyth" creationdate="20170825T044827Z">
        <seg>$(P
如果该字符串不能转换为一个 $(C double) 值，则调用 $(C to!double()) 会抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~) operator creates a new array by combining two arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T014946Z" creationid="大处着手小处着眼" creationdate="20160726T014946Z">
        <seg>$(P
 $(C ~) 运算符通过连接两个数组从而创建一个新数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~=) operator adds new elements to the end of a dynamic array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013844Z" creationid="大处着手小处着眼" creationdate="20160726T013844Z">
        <seg>$(P
$(C ~=) 运算符是指在动态数组的尾部添加新的元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The $(C ~=) operator cannot be used when the left-hand side array is a fixed-length array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015809Z" creationid="大处着手小处着眼" creationdate="20160726T015809Z">
        <seg>$(P
左侧数组是定长数组时 $(C ~=) 运算符不能使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The Enter key that the user presses after the name does not terminate the input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T004459Z" creationid="Hipter" creationdate="20160712T004052Z">
        <seg>$(P
用户在名字之后按的 Enter 键并没有结束输入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment above makes $(C variable1) leave its object and start providing access to $(C variable2)'s object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031250Z" creationid="Hipter" creationdate="20160706T031250Z">
        <seg>$(P
上面的赋值让 $(C variable1) 离开其对象并且开始提供对 $(C variable2) 的对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The assignment operator copies all of the elements from the right-hand side to the left-hand side:
)
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013149Z" creationid="大处着手小处着眼" creationdate="20160726T013149Z">
        <seg>$(P
赋值运算符将所有元素从右手侧复制到左手侧：
)
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The attributes of $(C a) and $(C b) above are of different kinds: The attribute of $(C a) is the type $(C Encrypted) itself, while the attribute of $(C b) is an $(I object) of type $(C Encrypted).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T054610Z" creationid="Heromyth" creationdate="20170803T054610Z">
        <seg>$(P
上面 $(C a) 和 $(C b) 的属性属于不同类别：$(C a) 的属性是 $(C Encrypted) 类型，而 $(C b) 的属性是 $(C Encrypted) 类型的一个$(I 对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The behavior of assignment cannot be changed for classes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031647Z" creationid="Hipter" creationdate="20160706T031647Z">
        <seg>$(P
赋值操作不能改变类。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The benefit of user defined attributes is being able to change the attributes of declarations without needing to change any other part of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042134Z" creationid="Heromyth" creationdate="20170816T042134Z">
        <seg>$(P
自定义属性的好处在于能够更改声明的属性，且不需要更改程序的其他部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The biggest difference from structs is that structs are $(I value types) and classes are $(I reference types).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124110Z" creationid="Heromyth" creationdate="20170819T124110Z">
        <seg>$(P
与结构的最大区别在于结构是 $(I 值类型)  而类是 $(I 引用类型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The compiler may also emit a $(I compilation warning) when it sees a suspicious piece of code that may cause concern but not necessarily an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005224Z" creationid="Heromyth" creationdate="20170820T005224Z">
        <seg>$(P
当编译器看到某段可疑但又不是错误的代码时，会发出 $(I 编译警告)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The complete program has more explanations:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052903Z" creationid="Heromyth" creationdate="20170815T052903Z">
        <seg>$(P
列出整个程序代码更能说明问题：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The concept of compilation and the function of the compiler must also be understood when using $(I compiled) languages like D.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003218Z" creationid="Heromyth" creationdate="20170820T003218Z">
        <seg>$(P
当使用类似 D 语言的 $(I 编译型) 语言时，需要理解编译的概念和编译器的功能。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The definition of array variables is very similar to the definition of normal variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022547Z" creationid="大处着手小处着眼" creationdate="20160720T022547Z">
        <seg>$(P
数组变量的定义与正常变量的定义非常相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The details of $(C Variant) are outside of the scope of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043202Z" creationid="Heromyth" creationdate="20170825T043202Z">
        <seg>$(P
有关 $(C Variant) 的详细内容已超出本章范围。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The element at index 0 has the value 31 (number of days in January); the element at index 1 has the value of 28 (number of days in February), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T032422Z" creationid="大处着手小处着眼" creationdate="20160725T031328Z">
        <seg>$(P
索引 0 处元素的值为 31（一月的天数）；索引1 处元素的值为 28（二月的天数）依次类推。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The examples in this chapter call $(C Thread.sleep) to slow down threads to demonstrate that they run at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054704Z" creationid="Heromyth" creationdate="20170824T054704Z">
        <seg>$(P
本章中的例子调用 $(C Thread.sleep) 减慢线程执行的速度来更方便的展示线程运行的情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The exceptions that the worker may throw cannot be caught by the owner.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233756Z" creationid="Heromyth" creationdate="20170824T233756Z">
        <seg>$(P
所有者无法捕获由工作线程抛出的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The exclamation mark appears after those characters instead of being printed right after the name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135758Z" creationid="Hipter" creationdate="20160712T015039Z">
        <seg>$(P
感叹号出现在了那些字符之后，而不是在名字之后立即输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The fact that plain arrays provide access to their values through index numbers can be described as an $(I association) of indexes with values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023126Z" creationid="Hipter" creationdate="20160708T084434Z">
        <seg>$(P
事实上简单数组通过索引访问值可以被描述为索引与值的$(I 关联) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first line above is the definition of a variable which stores a single value, just like the variables that we have defined so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T023154Z" creationid="大处着手小处着眼" creationdate="20160720T023154Z">
        <seg>$(P
上面的第一行定义了一个存储单个值的变量，就像我们以前定义过的变量那样。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first line above removes the key-value pair "Tuesday" / $(C 1).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160709T032313Z">
        <seg>$(P
上面第一行移除了键值对 "Tuesday" / $(C 1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The first parameter of $(C receiveTimeout()) determines how long the message should be waited for.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043309Z" creationid="Heromyth" creationdate="20170825T043309Z">
        <seg>$(P
$(C receiveTimeout()) 的第一个参数决定等待消息时要等待多长时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following code makes use of $(C dup()) to create a new object:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133505Z" creationid="Hipter" creationdate="20160706T023705Z">
        <seg>$(P
下面的代码利用 $(C dup()) 创建一个新的对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following code shows how the attributes of a specific $(C struct) member (e.g. $(C Person.name)) can be accessed by $(C __traits(getAttributes)):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043714Z" creationid="Heromyth" creationdate="20170804T043714Z">
        <seg>$(P
下面代码展示的是如何使用使用$(C __traits(getAttributes))来访问某个特定 $(C struct) 成员（如 $(C Person.name)）的属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The following program simulates independent robots moving around randomly in a two dimensional space.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234125Z" creationid="Heromyth" creationdate="20170824T234125Z">
        <seg>$(P
下面这个程序模拟的是两个互不相关的机器人在二维空间中随机移动。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The grades can also be assigned in one go with an array literal:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022153Z" creationid="Hipter" creationdate="20160711T022153Z">
        <seg>$(P
成绩也可以作为数组文本一次性赋值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The high performance of hash tables comes at the expense of storing the elements in an unordered way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131431Z" creationid="Hipter" creationdate="20160708T092120Z">
        <seg>$(P
hash 表的高性能的代价是元素的存储是无序的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The highlighted parts of the code are explained below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103955Z" creationid="Heromyth" creationdate="20170814T103955Z">
        <seg>$(P
下面来解释一下这段代码的高亮部分：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The interpreter must read and understand the instructions every time the program is executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004509Z" creationid="Heromyth" creationdate="20170820T004509Z">
        <seg>$(P
每一次执行程序之前，解释器都必须重新读入源码并了解它们的含义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The keys of associative arrays can be of any type, including user-defined $(C struct) and $(C class) types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142042Z" creationid="Hipter" creationdate="20160708T141705Z">
        <seg>$(P
关联数组的键可以是任何类型，包括用户定义的 $(C struct) 和 $(C class) 类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The length of associative arrays cannot be specified when defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T142139Z" creationid="Hipter" creationdate="20160708T142139Z">
        <seg>$(P
定义时，不能指定关联数组的长度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The length of such an array can increase or decrease during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033816Z" creationid="大处着手小处着眼" creationdate="20160725T033816Z">
        <seg>$(P
在程序的执行过程中这种数组的长度可以增加或减少。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The lines of the output may be different at different times depending on how the threads are paused and resumed by the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T231803Z" creationid="Heromyth" creationdate="20170824T231803Z">
        <seg>$(P
程序的输出顺序可能会和上面有所不同，具体情况取决于操作系统对线程的调度。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The main thread reports the messages that it sends and the messages that it receives:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233258Z" creationid="Heromyth" creationdate="20170824T233258Z">
        <seg>$(P
主线程会将它发送的和接收的消息一起输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The name of a specific day can be accessed by its index in that array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T235015Z" creationid="Hipter" creationdate="20160708T084239Z">
        <seg>$(P
在数组里通过索引访问特定的英文日期名：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The number of an element is called its $(I index) and the act of accessing an element is called $(I indexing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T020218Z" creationid="大处着手小处着眼" creationdate="20160725T020218Z">
        <seg>$(P
元素的位置数称为 $(I index)，访问元素的行为称为$(I 索引)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The operating system can pause threads at unpredictable times for unpredictable durations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012545Z" creationid="Heromyth" creationdate="20170824T012545Z">
        <seg>$(P
操作系统会不定期的将线程暂停一段时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The operation above involves three steps: Reading the value of the variable, incrementing the value, and assigning the new value back to the variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054020Z" creationid="Heromyth" creationdate="20170824T054020Z">
        <seg>$(P
上面这个看似简单的操作实际上包含三个步骤：读取变量的值、将其加一、将结果写回变量所在的内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The optional character that is specified after string literals determines the type of the elements of the string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T031212Z" creationid="大处着手小处着眼" creationdate="20160715T020121Z">
        <seg>$(P
在字符串字面量之后指定的可选字符决定了字符串的元素类型：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output indicates that the values 0 and 1 correspond to keys "Monday" and "Tuesday", respectively:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091105Z" creationid="Hipter" creationdate="20160709T024828Z">
        <seg>$(P
下面的输出表明了元素值 0 和 1 分别对应着键 “Monday” 和 “Tuesday”：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of one of the threads is highlighted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055331Z" creationid="Heromyth" creationdate="20170824T055331Z">
        <seg>$(P
其中一个线程的输出被高亮了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program indicates that the messages are handled by matching functions on the receiver's side:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000358Z" creationid="Heromyth" creationdate="20170825T000358Z">
        <seg>$(P
程序的输出表明了接收端的函数是如何匹配和处理消息的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program lists all attributes of all members of $(C Person):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T135005Z" creationid="Heromyth" creationdate="20170805T135005Z">
        <seg>$(P
此程序的输出会列出 $(C Person) 的所有成员的所有属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program lists the attributes of $(C Person.name):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T044037Z" creationid="Heromyth" creationdate="20170804T044037Z">
        <seg>$(P
这个程序的输出内容是 $(C Person.name) 的各个属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output of the program shows that the members have the correct color and that the $(C name) member is encrypted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121614Z" creationid="Heromyth" creationdate="20170815T121507Z">
        <seg>$(P
上面程序的输出内容包含那些拥有正确颜色的成员和被加密过的  $(C name) 成员：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T033423Z" creationid="大处着手小处着眼" creationdate="20160715T033423Z">
        <seg>$(P
输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner above waits for a message for up to 600 milliseconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044510Z" creationid="Heromyth" creationdate="20170825T044510Z">
        <seg>$(P
上面的线程所有者将等待消息 600 毫秒。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner in the following program sends its worker a message of type $(C int) and waits for a message from the worker of type $(C double).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232941Z" creationid="Heromyth" creationdate="20170824T232941Z">
        <seg>$(P
下面这个程序中，线程所有者会向工作线程发送 $(C int) 类型的消息并等待工作线程返回 $(C double) 类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner receives the response for "1.2" as 1.7 but because the worker has been terminated, the owner would be blocked waiting for a message that would never arrive:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045039Z" creationid="Heromyth" creationdate="20170825T045039Z">
        <seg>$(P
由于工作线程已被终止，所有者只会收到将“1.2”变为 1.7 的消息的反馈。而它并不知道工作线程已经终止，所有者线程会被阻塞来等待永远不会到达的消息：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The owner simply waits for these messages in an infinite loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234434Z" creationid="Heromyth" creationdate="20170824T234434Z">
        <seg>$(P
线程所有者仅仅通过一个死循环等待消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The parameters that the thread function takes are passed to $(C spawn()) as its second and later arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055237Z" creationid="Heromyth" creationdate="20170824T055237Z">
        <seg>$(P
线程函数需要的参数应通过 $(C spawn()) 的二个参数传入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program automatically waits for all of the threads to finish executing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054954Z" creationid="Heromyth" creationdate="20170824T054954Z">
        <seg>$(P
程序在所有线程执行完毕后才会退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program can now be compiled and will print the modified string:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025856Z" creationid="Hipter" creationdate="20160713T025856Z">
        <seg>$(P
现在程序能通过编译并且打印修改后的字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program is terminated with an exception:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002254Z" creationid="Heromyth" creationdate="20170820T002254Z">
        <seg>$(P
这个程序会抛一个异常，并中断：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The program prints every movement until terminated:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235641Z" creationid="Heromyth" creationdate="20170824T235641Z">
        <seg>$(P
程序会不停地显示所有机器人的运动信息，除非手动终止：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The reason is that, the $(C ==) operator may need to consult the values of the members of the objects and that attempting to access the members through a potentially $(C null) variable would cause a memory access error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130649Z" creationid="Heromyth" creationdate="20170819T130649Z">
        <seg>$(P
原因是，运算符 $(C ==) 会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The reason why the $(C shared) specifiers are necessary is explained in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051942Z" creationid="Heromyth" creationdate="20170825T051942Z">
        <seg>$(P
我们会在下一章解释为什么此处必须使用 $(C shared) 说明符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The return type of $(C thisTid()) is $(C Tid), which has no significance for the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232512Z" creationid="Heromyth" creationdate="20170824T232512Z">
        <seg>$(P
$(C thisTid()) 返回的类型为 $(C Tid)，它对这个程序没有什么作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The return value of $(C spawn()), which I have been ignoring until this point, is the id of the worker thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232612Z" creationid="Heromyth" creationdate="20170824T232612Z">
        <seg>$(P
我们之前一直没有用到的 $(C spawn()) 的返回值即为工作线程的 ID：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The solution here is to take a copy of the immutable string by using the $(C .dup) property:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T151110Z" creationid="Hipter" creationdate="20160713T025651Z">
        <seg>$(P
此处的解决办法是通过 $(C .dup) property（属性）得到一个不可变字符串的副本：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The syntax of associative arrays is similar to the array syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T094902Z" creationid="Hipter" creationdate="20160708T094902Z">
        <seg>$(P
关联数组的语法与数组相似。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The table grows automatically with each association.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132057Z" creationid="Hipter" creationdate="20160708T145054Z">
        <seg>$(P
随着每次的关联，该表会自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The thread function that moves each robot sends the id of the robot and its movement to the owner thread continuously:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234407Z" creationid="Heromyth" creationdate="20170824T234407Z">
        <seg>$(P
移动机器人的线程会不断地将对应机器人的 ID 和它的移动情况发送给所有者线程：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The two 'e' characters do not replace the two 'é' characters; they replace single code units, resulting in an invalid UTF-8 encoding:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T150159Z" creationid="大处着手小处着眼" creationdate="20160714T015145Z">
        <seg>$(P
两个‘e’字符不能代替两个‘é’字符；用单字节编码单元替换后，结果就是得到一个无效的 UTF-8 编码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The type of the elements of string literals like $(STRING "hello") is $(C char) and each $(C char) value represents a UTF-8 code unit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T014126Z" creationid="大处着手小处着眼" creationdate="20160714T013933Z">
        <seg>$(P
像 $(STRING "hello") 这样的字符串字面量的元素类型是 $(C char)，并且每个 $(C char) 值对应一个 UTF-8 编码单元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The type of the values can also be a user-defined type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032844Z" creationid="大处着手小处着眼" creationdate="20160720T032844Z">
        <seg>$(P
值的类型也可以是用户定义的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The value of $(C i) is 5 when the first $(C while) loop terminates, and that value is causing the logical expression of the second loop to be $(C false), which in turn is preventing the second loop to be entered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032634Z" creationid="大处着手小处着眼" creationdate="20160726T032634Z">
        <seg>$(P
当第一个 $(C while) 循环结束时 $(C i) 值为 5，该值导致第二个循环的逻辑表达式的值为 $(C false)，是它阻止进入第二个循环。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The variables of a container are called $(I elements).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143213Z" creationid="大处着手小处着眼" creationdate="20160723T142747Z">
        <seg>$(P
容器的变量称为 $(I 元素)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
The worker can catch that exception to exit gracefully:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052215Z" creationid="Heromyth" creationdate="20170825T052215Z">
        <seg>$(P
工作线程也可以通过捕获这个异常来优雅地退出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are surprises even when reading strings from the terminal.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T094459Z" creationid="Hipter" creationdate="20160711T092623Z">
        <seg>$(P
从终端读字符串您会有一些惊奇。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three $(I aliases) of the $(I immutable) versions of those types: $(C string), $(C wstring), and $(C dstring).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T082950Z" creationid="Hipter" creationdate="20160712T081640Z">
        <seg>$(P
这些类型的 $(I immutable) 版本有三个$(I 别名)：$(C string)、$(C wstring) 和 $(C dstring)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three anonymous functions below that are passed to $(C receive()) as message handlers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000621Z" creationid="Heromyth" creationdate="20170825T000621Z">
        <seg>$(P
有 3 个匿名函数被传递给了 $(C receive()) 来作为消息处理器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are three string types that correspond to the three character types: $(C char[]), $(C wchar[]), and $(C dchar[]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160719T145013Z" creationid="Hipter" creationdate="20160712T080418Z">
        <seg>$(P
对应着三种字符类型，分别存在着三种字符串类型：$(C char[])、$(C wchar[]) 和 $(C dchar[])。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are two different ways of using $(C remove()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144240Z" creationid="Heromyth" creationdate="20170817T144240Z">
        <seg>$(P
$(C remove()) 的使用方式有以下两种：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There are two important points worth stressing here:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023255Z" creationid="大处着手小处着眼" creationdate="20160724T023255Z">
        <seg>$(P
还有两点值得强调：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
There can be only one value per key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132156Z" creationid="Hipter" creationdate="20160709T025550Z">
        <seg>$(P
每个键有且仅有一个对应值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These machine code instructions are special numbers, which represent various operations supported by the CPU.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003718Z" creationid="Heromyth" creationdate="20170820T003718Z">
        <seg>$(P
机器码指令都是特定的数字，它们表示 CPU 支持的各种操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These operators operate on class variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013802Z" creationid="Hipter" creationdate="20160707T013802Z">
        <seg>$(P
这些运算符应用在类变量上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
These options have different prices, shipping times, shipping costs, customs and other fees, availability at local book stores, etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T042617Z" creationid="Heromyth" creationdate="20170801T042617Z">
        <seg>$(P
以上各个版本受诸多因素影响而存在差异，如价格、运送时间、运送成本、关税与其他费用，以及当地书店是否有售等等
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This chapter covers only some of the features of arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022235Z" creationid="大处着手小处着眼" creationdate="20160720T022235Z">
        <seg>$(P
本章仅涉及数组的部分功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This chapter will introduce classes at a high level, underlining the fact that they are reference types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123555Z" creationid="Heromyth" creationdate="20170819T123555Z">
        <seg>$(P
本章将深入介绍类，特别强调一点，类是引用类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This exception is thrown when receiving a message from the owner if the owner has been terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052036Z" creationid="Heromyth" creationdate="20170825T052036Z">
        <seg>$(P
如果所有者线程已被终止，工作线程在接收消息时就会抛出这个异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This method of defining variables individually does not scale to cases where even more variables are needed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T020639Z" creationid="大处着手小处着眼" creationdate="20160720T020639Z">
        <seg>$(P
这种定义个别变量的方法不能扩展到需要更多变量的情况下。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This program demonstrates how helpful message passing concurrency can be: Movements of robots are calculated independently by separate threads without knowledge of each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235707Z" creationid="Heromyth" creationdate="20170824T235707Z">
        <seg>$(P
这个程序展现了并发的强大之处：机器人的移动可以在单独的线程中独立计算，而且它们之间无需相互交换信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This simple definition may be misleading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091239Z" creationid="Hipter" creationdate="20160711T091239Z">
        <seg>$(P
这个简单的定义可能是个误导。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the compilation error is due to the combination of two factors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150238Z" creationid="Hipter" creationdate="20160713T023816Z">
        <seg>$(P
这次的编译错误是因为两个因素的联合作用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
This time the reason of the failure is printed by the owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051831Z" creationid="Heromyth" creationdate="20170825T051831Z">
        <seg>$(P
这次错误的原因会被所有者输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Threads can detect that the receiver of a message has terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052007Z" creationid="Heromyth" creationdate="20170825T052007Z">
        <seg>$(P
线程可以检测消息的接收者是否已经终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
To see how this program is better than the previous one, imagine needing to read 20 values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T134911Z" creationid="大处着手小处着眼" creationdate="20160725T081024Z">
        <seg>$(P
要看一看这个程序怎样才能比以前的更好，让我们设想需要读取 20 个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Two other $(C __traits) expressions are useful when dealing with user defined attributes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053206Z" creationid="Heromyth" creationdate="20170804T053206Z">
        <seg>$(P
在处理自定义属性时，还有其他两个 $(C __traits) 表达式可以使用：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike an interpreter, the compiler reads and understands the source code only once, during compilation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004834Z" creationid="Heromyth" creationdate="20170820T004834Z">
        <seg>$(P
不像解释器，编译器一次性地在编译期读入和理解源码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Unlike structs, there is no automatic object construction where the constructor parameters are assigned to members sequentially:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032818Z" creationid="Hipter" creationdate="20160706T032818Z">
        <seg>$(P
不像结构，构造函数参数按顺序分配给成员时，类没有自动构造对象：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Using the assignment operator is sufficient to build the association between a key and a value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144951Z" creationid="Hipter" creationdate="20160708T144951Z">
        <seg>$(P
使用赋值运算符就足以构建键与值的关联：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Values that are passed as parts of a single message appear as a tuple on the receiver's side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233401Z" creationid="Heromyth" creationdate="20170824T233401Z">
        <seg>$(P
如果在一次消息中传递多个值的话，接收者会将它们看作一个 tuple。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
Violating these rules is undefined behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001909Z" creationid="Heromyth" creationdate="20170820T001909Z">
        <seg>$(P
违反这些规则即会产生未定义行为。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We can make the following observations about the use of these blocks:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022106Z" creationid="Hipter" creationdate="20160707T022106Z">
        <seg>$(P
对于这些块的用法，我们可以作以下观测：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have defined five variables in one of the exercises of the last chapter, and used them in certain calculations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T043538Z" creationid="大处着手小处着眼" creationdate="20160716T144940Z">
        <seg>$(P
在上一章的一个练习中我们定义过五个变量，并用它们做过特定计算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that single quotes are used to define character literals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005300Z" creationid="Hipter" creationdate="20160712T075903Z">
        <seg>$(P
我们已经看到单引号用于定义字符字面量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that some Unicode characters are represented by more than one byte.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T011246Z" creationid="大处着手小处着眼" creationdate="20160714T011246Z">
        <seg>$(P
我们已经知道一些 Unicode 字符串由多个字节表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have seen that the two tools that are used most in D programming are $(I the text editor) and $(I the compiler).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003058Z" creationid="Heromyth" creationdate="20170820T003058Z">
        <seg>$(P
用 D 编程时经常会用到两个工具，它们分别是 $(I 文本编辑器) 和 $(I 编译器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have used comparison operators $(C &lt;), $(C &gt;=), etc. with integer and floating point values before.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T034612Z" creationid="大处着手小处着眼" creationdate="20160715T034612Z">
        <seg>$(P
我们以前把比较运算符 $(C &lt;)，$(C &gt;=) 等等用于整型和浮点数值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We have used strings in many programs that we have seen so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T090616Z" creationid="Hipter" creationdate="20160711T090616Z">
        <seg>$(P
迄今为至，我们已经看到，好多程序都用到了字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We may think of defining the variable as a $(C char[]) instead of the $(C string) alias but that cannot be compiled either:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150152Z" creationid="Hipter" creationdate="20160713T023409Z">
        <seg>$(P
我们可能想到把变量定义为 $(C char[]) 而不是别名 $(C string)，但这也不能通过编译：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We saw in the $(LINK2 /ders/d.en/arrays.html, Arrays chapter) that plain arrays are containers that store their elements side-by-side and provide access to them by index.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T151814Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/arrays.html, 数组) 一章中我们已经看到简单数组作为容器逐个存储元素，按索引访问它们。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
We will see below that this exception can be received as a message as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052231Z" creationid="Heromyth" creationdate="20170825T052231Z">
        <seg>$(P
之后我们会看到也可以将这个异常当作消息发送。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When dealing with letters, symbols, and other Unicode characters directly, as in the code above, the correct type to use is $(C dchar):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T020029Z" creationid="大处着手小处着眼" creationdate="20160714T015921Z">
        <seg>$(P
当直接处理字母、符号或其它 Unicode 字符的时候，比如在上面代码中，应该使用正确的类型 $(C dchar)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When initializing arrays, it is possible to use a single value on the right-hand side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011926Z" creationid="大处着手小处着眼" creationdate="20160726T011926Z">
        <seg>$(P
当初始化数组时，也可以在右手侧使用单个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the actual object needs to be copied, the class must have a member function for that purpose.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022112Z" creationid="Hipter" creationdate="20160706T021806Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the compile-time evaluations are completed, the $(C printAsXML()) function template would be instantiated for the $(C Person) type as the equivalent of the following function:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052641Z" creationid="Heromyth" creationdate="20170815T052641Z">
        <seg>$(P
当编译时计算完成时，函数模板 $(C printAsXML()) 会根据 $(C Person) 类型实例化，并与下面这个函数相似：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the input cannot be converted to $(C name) and $(C age), the program prints an error:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144631Z" creationid="Hipter" creationdate="20160712T075010Z">
        <seg>$(P
当输入不能转换到 $(C name) 和 $(C age) 时，程序将打印一个错误：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the length of an array is specified when the program is written, that array is a $(I fixed-length array).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T085322Z" creationid="大处着手小处着眼" creationdate="20160725T032037Z">
        <seg>$(P
当数组的长度是在写程序时指定时，该数组就是一个$(I 定长数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the type of $(C s) is $(C char[]), the type of the expression on the right-hand side of the assignment above is $(C char[]) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T000923Z" creationid="Hipter" creationdate="20160713T032929Z">
        <seg>$(P
当 $(C s) 的类型是 $(C char[])，上面右手侧赋值的表达式类型也是 $(C char[])，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the value of $(C monthIndex) is 2, the expression above would print the value of $(C monthDays[2]), the number of days in March.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021903Z" creationid="大处着手小处着眼" creationdate="20160725T021903Z">
        <seg>$(P
当 $(C monthIndex) 的值为 2，上面的表达式将输出 $(C monthDays[2]) 的值，即三月的天数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
When the variables provide access to the same object, $(C is) returns $(C true):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015456Z" creationid="Hipter" creationdate="20160707T015456Z">
        <seg>$(P
当变量提供对同一对象的访问时，$(C is) 返回 $(C true)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
You may find the $(C indexOf()) and $(C lastIndexOf()) functions useful to get the two indexes needed to produce a slice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154350Z" creationid="大处着手小处着眼" creationdate="20160715T144100Z">
        <seg>$(P
你或许会发现 $(C indexOf()) 和 $(C lastIndexOf()) 函数对生成切片所需要的两个索引很有用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
have the program print the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T023131Z" creationid="大处着手小处着眼" creationdate="20160726T023131Z">
        <seg>$(P
程序会输出以下内容：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的章节) 中解释。))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T021046Z" creationid="Hipter" creationdate="20160708T021046Z">
        <seg>$(P
上面这个函数首先修改引用参数，当出现异常时再恢复修改。不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。$(I ($(B 注：) 这与命名作用域，以及对象生存期有关，这将在 $(LINK2 /ders/d.cn/lifetimes.html, 后面的一章) 中解释。))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020733Z" creationid="Hipter" creationdate="20160708T020733Z">
        <seg>$(P
与结构不同的是一些成员函数自动继承自 $(C Object) 类。在 $(LINK2 /ders/d.cn/inheritance.html, 下一章) 中我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035217Z" creationid="Hipter" creationdate="20160708T035045Z">
        <seg>$(P
与结构的最大区别是结构是 $(I 值类型) 而类是 $(I 引用类型)。下面的其它不同大部分与此有关。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下面的函数：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034510Z" creationid="Hipter" creationdate="20160708T034510Z">
        <seg>$(P
例如，让我们用 $(C scope(failure)) 语句写一下下面的函数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104213Z" creationid="Hipter" creationdate="20160707T104213Z">
        <seg>$(P
像结构一样，析构函数的名称是 $(C ~this)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
原因是， $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104345Z" creationid="Hipter" creationdate="20160707T104345Z">
        <seg>$(P
原因是 $(C ==) 运算符会查询对象成员的值，并尝试通过一个潜在的 $(C null) 变量访问成员，这将引发一个内存访问错误。因此，类变量必须总是通过 $(C is) 和 $(C !is) 运算符做比较。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T035630Z" creationid="Hipter" creationdate="20160708T035630Z">
        <seg>$(P
另一方面，类变量是用于访问类对象的一种语言特性。虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I 对象)。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, The $(CH4 null) 值和 $(CH4 is) 运算符章节)， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020020Z" creationid="Hipter" creationdate="20160708T020020Z">
        <seg>$(P
在 $(LINK2 /ders/d.cn/null_is.html, $(CH4 null) 值和 $(CH4 is) 运算符一章) 中， 本书已简要的提到，类变量可以是 $(C null)。换句话说，类变量可以不提供对任何对象的访问。类变量没有值本身；实际的类对象必须由 $(C new) 关键字构造。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104919Z" creationid="Hipter" creationdate="20160707T104919Z">
        <seg>$(P
在上面的代码中， $(C variable2) 由 $(C variable1) 初始化。这俩变量可访问同一对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的章节) 将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T034923Z" creationid="Hipter" creationdate="20160708T015803Z">
        <seg>$(P
封装是通过 $(I 保护属性) 来实现， 在 $(LINK2 /ders/d.cn/encapsulation.html, 稍后的一章) 中将会看到。继承是用于获取其它类型的 $(I 实现) 。$(LINK2 /ders/d.cn/inheritance.html, 多态性) 是从类之间抽象出部分代码，通过 $(I 接口) 来实现。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T103944Z" creationid="Hipter" creationdate="20160707T103944Z">
        <seg>$(P
当需要复制实际的对象时，类必须有一个针对此目的的成员函数。为与数组兼容，该函数可以命名为 $(C dup())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
我们将在后面看到 $(LINK2 /ders/d.cn/memory.html, 内存管理章节)，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020446Z" creationid="Hipter" creationdate="20160708T020446Z">
        <seg>$(P
我们将在后面 $(LINK2 /ders/d.cn/memory.html, 内存管理一章) 中看到，类的析构函数必须遵守以下规则：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T041227Z" creationid="Hipter" creationdate="20160708T041227Z">
        <seg>$(P
由于 $(C myKing) 和 $(C yourKing) 变量来自不同的对象，$(C !is) 运算符返回 $(C true)。即使这两个对象由同一字符 $(C'♔')  参数构造， 它们仍是两个单独的对象。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020547Z" creationid="Hipter" creationdate="20160708T020547Z">
        <seg>$(P
虽然成员函数的定义与用法与结构相同，有个重要的不同：类成员函数默认是 $(I 可重写的) 。在 $(LINK2 /ders/d.cn/inheritance.html,继承一章) 中我们将看到相关内容。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P
让我们考虑一下下面我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型章节) 看到过的代码：
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T020154Z" creationid="Hipter" creationdate="20160708T020154Z">
        <seg>$(P
让我们考虑一下下面的我们以前在 $(LINK2 /ders/d.cn/value_vs_reference.html, 值类型和引用类型一章) 中看到过的代码：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(B Observations:) The value of $(C counter) determines how many times the loops are repeated (iterated).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T074518Z" creationid="大处着手小处着眼" creationdate="20160725T074518Z">
        <seg>$(P $(B 观测：) $(C counter) 的值决定了循环的重复次数（迭代）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(P $(LINK2 /ders/d.en/ix.html, $(B The Index Section)) (useful for keyword searches))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T052832Z" creationid="Heromyth" creationdate="20170801T052832Z">
        <seg>$(P $(LINK2 /ders/d.en/ix.html, $(B 索引)) （可以使用关键字搜索）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Browse the documentations of the $(C std.string), $(C std.array), $(C std.algorithm), and $(C std.range) modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160716T083116Z" creationid="大处着手小处着眼" creationdate="20160715T143846Z">
        <seg>$(PROBLEM
浏览 $(C std.string)、$(C std.array)、$(C std.algorithm) 和 $(C std.range) 模块的文档。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
How can all of the key-value pairs of an associative array be removed other than calling $(C .clear)?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T094612Z" creationid="Hipter" creationdate="20160709T083844Z">
        <seg>$(PROBLEM
除 $(C .clear) 函数外还有什么方法能移除关联数组的全部键值对？ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Just like with arrays, there can be only one value for each key.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085009Z" creationid="Hipter" creationdate="20160709T085009Z">
        <seg>$(PROBLEM
与数组一样，每个键有且仅有一个值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Read a line from the input and print the part between the first and last 'e' letters of the line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144015Z" creationid="大处着手小处着眼" creationdate="20160715T144015Z">
        <seg>$(PROBLEM
从输入中读取一行并打印该行的第一个和最后一个‘e’字母之间的部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
The following is a program that does not work as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024119Z" creationid="大处着手小处着眼" creationdate="20160726T024119Z">
        <seg>$(PROBLEM
以下为预期不起作用的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that asks the user how many values will be entered and then reads all of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T022157Z" creationid="大处着手小处着眼" creationdate="20160726T022157Z">
        <seg>$(PROBLEM
编写一个程序，要求用户输入多少值，然后全部读取。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that makes use of the $(C ~) operator: The user enters the first name and the last name, all in lowercase letters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154258Z" creationid="大处着手小处着眼" creationdate="20160715T143917Z">
        <seg>$(PROBLEM
写一个使用 $(C ~) 运算符的程序：让用户都以小写键入英文名字和姓氏，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(PROBLEM
Write a program that reads numbers from the input, and prints the odd and even ones separately but in order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051538Z" creationid="大处着手小处着眼" creationdate="20160726T022628Z">
        <seg>$(PROBLEM
编写一个程序，从输入流中读取数字，并先后按顺序分别输出奇数和偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL
Before: résumé
After : re�sueé    $(SHELL_NOTE_WRONG INCORRECT)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T015218Z" creationid="大处着手小处着眼" creationdate="20160714T015218Z">
        <seg>$(SHELL
Before: résumé
After : re�sueé    $(SHELL_NOTE_WRONG 不正确)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE (Let's assume that Enter is pressed a second time here))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135416Z" creationid="Hipter" creationdate="20160712T004651Z">
        <seg>$(SHELL_NOTE （让我们假设在这儿第二次按了 Enter 键）)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE The input is not terminated although Enter has been pressed)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144927Z" creationid="Hipter" creationdate="20160712T004632Z">
        <seg>$(SHELL_NOTE 虽然按了 Enter 键，但输入没有中断)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE no new-line character)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140423Z" creationid="Hipter" creationdate="20160712T021122Z">
        <seg>$(SHELL_NOTE 没有换行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE waiting for a message that will never arrive)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045053Z" creationid="Heromyth" creationdate="20170825T045053Z">
        <seg>$(SHELL_NOTE 等待永远不会到达的消息)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG (one more before the exclamation mark))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135551Z" creationid="Hipter" creationdate="20160712T014834Z">
        <seg>$(SHELL_NOTE_WRONG （在感叹号前还有一个）)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character after the name)
!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135540Z" creationid="Hipter" creationdate="20160712T014717Z">
        <seg>$(SHELL_NOTE_WRONG 名字之后的换行符)
!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(SHELL_NOTE_WRONG new-line character before the exclamation mark)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135845Z" creationid="Hipter" creationdate="20160712T020346Z">
        <seg>$(SHELL_NOTE_WRONG 感叹号前有换行符)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(STRING 'a') is a character; $(STRING "a") is a string that contains a single character.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T080044Z" creationid="Hipter" creationdate="20160712T080044Z">
        <seg>$(STRING 'a') 是一个字符；$(STRING "a") 是一个包含单字符的字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(C scope(exit)): the expression is always executed when exiting the scope, regardless of whether successfully or due to an exception)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025349Z" creationid="Hipter" creationdate="20160707T025349Z">
        <seg>$(UL
$(LI $(C scope(exit))：表达式总是在退出作用域时被执行， 无论是否成功或出现异常。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(LINK2 $(ROOT_DIR)/ders/d/, $(IMG bullet_black.png) This book in Turkish))
$(LI $(LINK2 mailto:acehreli@yahoo.com, $(IMG bullet_black.png) Contact))
$(BR)
$(LI $(LINK2 $(ROOT_DIR)/copyright.html, $(IMG cc_80x15.png) Rights))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060209Z" creationid="Heromyth" creationdate="20170718T105411Z">
        <seg>$(UL
$(LI $(LINK2 $(ROOT_DIR)/ders/d/, $(IMG bullet_black.png) 土耳其语版))
$(LI $(LINK2 mailto:acehreli@yahoo.com, $(IMG bullet_black.png) 联系方式))
$(BR)
$(LI $(LINK2 $(ROOT_DIR)/copyright.html, $(IMG cc_80x15.png) 版权))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(LI $(LINK2 /ders/d.en/struct.html, Structs))
$(LI $(LINK2 /ders/d.en/member_functions.html, Member Functions))
$(LI $(LINK2 /ders/d.en/const_member_functions.html, $(CH4 const ref) Parameters and $(CH4 const) Member Functions))
$(LI $(LINK2 /ders/d.en/special_functions.html, Constructor and Other Special Functions))
$(LI $(LINK2 /ders/d.en/operator_overloading.html, Operator Overloading))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013521Z" creationid="Heromyth" creationdate="20170819T123920Z">
        <seg>$(UL
$(LI $(LINK2 /ders/d.cn/struct.html, 结构))
$(LI $(LINK2 /ders/d.cn/member_functions.html, 成员函数))
$(LI $(LINK2 /ders/d.cn/const_member_functions.html, $(CH4 const ref) 参数和 $(CH4 const) 成员函数))
$(LI $(LINK2 /ders/d.cn/special_functions.html, 构造函数和其它特殊函数))
$(LI $(LINK2 /ders/d.cn/operator_overloading.html, 运算符重载))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>$(UL
$(WORK_IN_PROCESS
$(LI $(LINK2 /ders/d.en/foreword1.html, Foreword by Walter Bright))
)
$(LI $(LINK2 /ders/d.en/foreword2.html, Foreword by Andrei Alexandrescu))
$(LI $(LINK2 /ders/d.en/preface.html, Preface))
$(LI $(LINK2 /ders/d.en/hello_world.html, The Hello World Program) $(INDEX_KEYWORDS main))
$(LI $(LINK2 /ders/d.en/writeln.html, writeln and write))
$(LI $(LINK2 /ders/d.en/compiler.html, Compilation))
$(LI $(LINK2 /ders/d.en/types.html, Fundamental Types) $(INDEX_KEYWORDS char int double (and more)))
$(LI $(LINK2 /ders/d.en/assignment.html, Assignment and Order of Evaluation) $(INDEX_KEYWORDS =))
$(LI $(LINK2 /ders/d.en/variables.html, Variables))
$(LI $(LINK2 /ders/d.en/io.html, Standard Input and Output Streams) $(INDEX_KEYWORDS stdin stdout))
$(LI $(LINK2 /ders/d.en/input.html, Reading from the Standard Input))
$(LI $(LINK2 /ders/d.en/logical_expressions.html, Logical Expressions) $(INDEX_KEYWORDS bool true false !</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T012639Z" creationid="Heromyth" creationdate="20170801T100252Z">
        <seg>$(UL
$(WORK_IN_PROCESS
$(LI $(LINK2 /ders/d.cn/foreword1.html, Walter Bright 序))
)
$(LI $(LINK2 /ders/d.cn/foreword2.html, Andrei Alexandrescu 序))
$(LI $(LINK2 /ders/d.cn/preface.html, 前言))
$(LI $(LINK2 /ders/d.cn/hello_world.html, Hello World程序) $(INDEX_KEYWORDS main))
$(LI $(LINK2 /ders/d.cn/writeln.html, writeln 和 write))
$(LI $(LINK2 /ders/d.cn/compiler.html, 编译))
$(LI $(LINK2 /ders/d.cn/types.html, 基础类型) $(INDEX_KEYWORDS char int double (等)))
$(LI $(LINK2 /ders/d.cn/assignment.html, 赋值与计算顺序) $(INDEX_KEYWORDS =))
$(LI $(LINK2 /ders/d.cn/variables.html, 变量))
$(LI $(LINK2 /ders/d.cn/io.html, 标准输入、输出流) $(INDEX_KEYWORDS stdin stdout))
$(LI $(LINK2 /ders/d.cn/input.html, 从标准输入读取))
$(LI $(LINK2 /ders/d.cn/logical_expressions.html, 逻辑表达式) $(INDEX_KEYWORDS bool true false !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="black"&amp;gt;Dbooft&amp;lt;/address&amp;gt;       $(SHELL_NOTE encrypted)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042758Z" creationid="Heromyth" creationdate="20170816T042458Z">
        <seg>&amp;lt;address color="black"&amp;gt;Dbooft&amp;lt;/address&amp;gt;       $(SHELL_NOTE 已加密)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="red"&amp;gt;Avignon&amp;lt;/address&amp;gt;         $(SHELL_NOTE red)
&amp;lt;/Person&amp;gt;
&amp;lt;Person&amp;gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121650Z" creationid="Heromyth" creationdate="20170815T121650Z">
        <seg>&amp;lt;address color="red"&amp;gt;Avignon&amp;lt;/address&amp;gt;         $(SHELL_NOTE 红色)
&amp;lt;/Person&amp;gt;
&amp;lt;Person&amp;gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;address color="red"&amp;gt;Bordeaux&amp;lt;/address&amp;gt;        $(SHELL_NOTE red)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121720Z" creationid="Heromyth" creationdate="20170815T121720Z">
        <seg>&amp;lt;address color="red"&amp;gt;Bordeaux&amp;lt;/address&amp;gt;        $(SHELL_NOTE 红色)
&amp;lt;/Person&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;lastName color="black"&amp;gt;ef!Dbooft&amp;lt;/lastName&amp;gt;  $(SHELL_NOTE encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042755Z" creationid="Heromyth" creationdate="20170816T042453Z">
        <seg>&amp;lt;lastName color="black"&amp;gt;ef!Dbooft&amp;lt;/lastName&amp;gt;  $(SHELL_NOTE 已加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;message color="blue"&amp;gt;hello world&amp;lt;/message&amp;gt;    $(SHELL_NOTE blue)
&amp;lt;/Data&amp;gt;
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042713Z" creationid="Heromyth" creationdate="20170816T042713Z">
        <seg>&amp;lt;message color="blue"&amp;gt;hello world&amp;lt;/message&amp;gt;    $(SHELL_NOTE 蓝色)
&amp;lt;/Data&amp;gt;
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="black"&amp;gt;Djoez&amp;lt;/name&amp;gt;              $(SHELL_NOTE encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042750Z" creationid="Heromyth" creationdate="20170816T042446Z">
        <seg>&amp;lt;name color="black"&amp;gt;Djoez&amp;lt;/name&amp;gt;              $(SHELL_NOTE 已加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="blue"&amp;gt;Bmjdf&amp;lt;/name&amp;gt;                $(SHELL_NOTE blue and encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121639Z" creationid="Heromyth" creationdate="20170815T121639Z">
        <seg>&amp;lt;name color="blue"&amp;gt;Bmjdf&amp;lt;/name&amp;gt;                $(SHELL_NOTE 蓝色且加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&amp;lt;name color="blue"&amp;gt;Cfo&amp;lt;/name&amp;gt;                  $(SHELL_NOTE blue and encrypted)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121714Z" creationid="Heromyth" creationdate="20170815T121714Z">
        <seg>&amp;lt;name color="blue"&amp;gt;Cfo&amp;lt;/name&amp;gt;                  $(SHELL_NOTE 蓝色且加密)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>($(C .clear) is the most natural method.) There are at least three methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T144029Z" creationid="Hipter" creationdate="20160709T084034Z">
        <seg>（$(C .clear) 是最自然的方法。） 至少有三种方法：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Because $(C hasUDA) requires $(I symbols) to work with, note how $(C __traits(getMember)) is used to get the member as a symbol (e.g. $(C Person.name)).))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T043031Z" creationid="Heromyth" creationdate="20170815T043031Z">
        <seg>（因为 $(C hasUDA) 需要 $(I 符号) 才能工作，请参考一下如何使用 $(C __traits(getMember)) 以符号方式（如 $(C Person.name)）获取成员的。）)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(By this distinction, class destructors should have more accurately been called $(I finalizers)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T135044Z" creationid="Heromyth" creationdate="20170819T135044Z">
        <seg>（基于此点差异，类的析构函数被叫作 $(I 终结函数) 会更加确切）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(There is also $(C prioritySend()), $(C receive()), and $(C receiveTimeout()), which will be explained later below.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232913Z" creationid="Heromyth" creationdate="20170824T232913Z">
        <seg>除了它们，标准库还提供了其他实用函数，像 $(C prioritySend())、$(C receive())、$(C receiveTimeout()) 。后面章节会对它们进行解释。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Warning: Caesar cipher is a very weak encryption</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121011Z" creationid="Heromyth" creationdate="20170815T121011Z">
        <seg>（警告：Caesar cipher 是一种强度很弱的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see D's $(I immutability) concept in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T134539Z" creationid="Hipter" creationdate="20160712T082117Z">
        <seg>（在稍后的章节我们将看到 D 的$(I 不可变性)概念。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see functions in a later chapter.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021526Z" creationid="大处着手小处着眼" creationdate="20160726T021515Z">
        <seg>（在后面的章节我们将看到这些函数。）
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(We will see user-defined types later.) For example:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T032924Z" creationid="大处着手小处着眼" creationdate="20160720T032924Z">
        <seg>（我们将在后面看到用户定义类型。）例如：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(anonymous MyClass object)    variable1    variable2</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131919Z" creationid="Hipter" creationdate="20160706T011847Z">
        <seg>(匿名 MyClass 对象)    变量1    变量2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>)
$(LI The $(C char[]) on the left-hand side is a slice, which, if the code compiled, would provide access to all of the characters of the right-hand side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T150532Z" creationid="Hipter" creationdate="20160713T024324Z">
        <seg>)
$(LI 左手侧的 $(C char[]) 是一个切片，这意味着，一旦代码编译成功，它将会访问右手侧的全部字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The default color is Color.black.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120021Z" creationid="Heromyth" creationdate="20170815T120021Z">
        <seg>* 默认颜色为 Color.black。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* associative array is being defined with an extra</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122913Z" creationid="Hipter" creationdate="20160711T020244Z">
        <seg>*关联数组在定义时附加了额外的空格，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* attributes of its members.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121232Z" creationid="Heromyth" creationdate="20170815T121232Z">
        <seg>* 以 XML 格式输出它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120448Z" creationid="Heromyth" creationdate="20170815T120448Z">
        <seg>* 属性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* blue.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120350Z" creationid="Heromyth" creationdate="20170815T120350Z">
        <seg>* 蓝色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* encrypted.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T115828Z" creationid="Heromyth" creationdate="20170815T115236Z">
        <seg>* 的那个符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* member has that attribute, Color.black otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120805Z" creationid="Heromyth" creationdate="20170815T120805Z">
        <seg>* 则输出它的值，否则输出 Color.black。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* method.) */
auto encrypted(string value) {</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121025Z" creationid="Heromyth" creationdate="20170815T121025Z">
        <seg>* 加密方法。） */
auto encrypted(string value) {</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* of the neighbors at eight directions, or the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235342Z" creationid="Heromyth" creationdate="20170824T235342Z">
        <seg>* 八个方向中的一个，也可能是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* position itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235411Z" creationid="Heromyth" creationdate="20170824T235411Z">
        <seg>* 指定那个位置本身。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* robots.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235540Z" creationid="Heromyth" creationdate="20170824T235540Z">
        <seg>* 的信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* see the 'foreach' loop in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011359Z" creationid="Hipter" creationdate="20160711T011324Z">
        <seg>*看到‘foreach’循环。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* space in between to help distinguish the value type: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T122942Z" creationid="Hipter" creationdate="20160711T020350Z">
        <seg>* 以易于区分值类型： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120911Z" creationid="Heromyth" creationdate="20170815T120911Z">
        <seg>* 版本。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* terminates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233148Z" creationid="Heromyth" creationdate="20170824T233148Z">
        <seg>*使其终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* the value type is int[], i.e. an array of ints.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120729Z" creationid="Hipter" creationdate="20160711T014929Z">
        <seg>* 值类型为 int[] ，即整型数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* used for appending the new grade to that array: */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021222Z" creationid="Hipter" creationdate="20160711T021222Z">
        <seg>* 将用于附加新成绩：*/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
/* The equivalent of the printAsXML!Person instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T052807Z" creationid="Heromyth" creationdate="20170815T052807Z">
        <seg>---
/* printAsXML!Person 实例的等同函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>---
// ... at the worker ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051905Z" creationid="Heromyth" creationdate="20170825T051905Z">
        <seg>---
// ... 工作线程中 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* 'foreach' is similar but superior to 'for'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T115742Z" creationid="Hipter" creationdate="20160711T011155Z">
        <seg>/* ‘foreach’类似于‘for’，但比它更有优势。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* ... other operations may be executed here ... */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043409Z" creationid="Heromyth" creationdate="20170825T043409Z">
        <seg>/* ... 可在此处执行其他操作... */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Print the movement of this robot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235618Z" creationid="Heromyth" creationdate="20170824T235618Z">
        <seg>/* 输出机器人的运动情况。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Printing the grades of "emre": */</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021258Z" creationid="Hipter" creationdate="20160711T021258Z">
        <seg>/* 打印“emre”的成绩： */</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Prints the specified object in XML format according to the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T121156Z" creationid="Heromyth" creationdate="20170815T121156Z">
        <seg>/* 根据指定对象的各个成员的属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Ready to collect information about the movements of the</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235522Z" creationid="Heromyth" creationdate="20170824T235522Z">
        <seg>/* 准备好接收有关机器人的移动情况</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns a neighbor of the specified Position.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235307Z" creationid="Heromyth" creationdate="20170824T235307Z">
        <seg>/* 返回指定位置周围的坐标。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns a random position around 0,0.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235044Z" creationid="Heromyth" creationdate="20170824T234849Z">
        <seg>/* 返回一个坐标在 0,0 周边的随机位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns at most one step from the specified coordinate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235236Z" creationid="Heromyth" creationdate="20170824T234940Z">
        <seg>/* 返回一个坐标，它相对从指定坐标最多变化一步。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns the Caesar-encrypted version of the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120903Z" creationid="Heromyth" creationdate="20170815T120903Z">
        <seg>/* 返回指定字符串的 Caesar 加密</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Returns the value of the Colored attribute if the specified</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T041914Z" creationid="Heromyth" creationdate="20170815T120718Z">
        <seg>/* 如果被特定要求的成员拥有 Colored 属性，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Robots with various restDurations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235435Z" creationid="Heromyth" creationdate="20170824T235435Z">
        <seg>/* 不同移动时间间隔的机器人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Sending a negative value to the worker so that it</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233138Z" creationid="Heromyth" creationdate="20170824T233138Z">
        <seg>/* 向工作线程发送一个负数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Specifies that the symbol that it is assigned to should be</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120233Z" creationid="Heromyth" creationdate="20170815T115215Z">
        <seg>/* 特别要求加密应用此自定义属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Specifies the color of the symbol that it is assigned to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120216Z" creationid="Heromyth" creationdate="20170815T115939Z">
        <seg>/* 特别指定应用此自定义属性的那个符号的颜色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Start a mover thread for each robot.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235453Z" creationid="Heromyth" creationdate="20170824T235453Z">
        <seg>/* 为每一个机器人启动一个移动线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The array of ints that correspond to "emre" is being</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T021215Z" creationid="Hipter" creationdate="20160711T021215Z">
        <seg>/* 与“emre” 对应的整型数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* The key type of this associative array is string and</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120710Z" creationid="Hipter" creationdate="20160711T014817Z">
        <seg>/* 该关联数组的键类型为 string，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member does not have any user defined</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T120442Z" creationid="Heromyth" creationdate="20170815T120442Z">
        <seg>/* 这个成员没有自定义</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member is specified to be encrypted and printed in</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042034Z" creationid="Heromyth" creationdate="20170815T120327Z">
        <seg>/* 此成员被特定要求加密，并且输出为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* This member is specified to be printed in red.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T041920Z" creationid="Heromyth" creationdate="20170815T120529Z">
        <seg>/* 此成员被特定要求输出为红色。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>/* Wait for a message composed of Tid, int, and double.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233458Z" creationid="Heromyth" creationdate="20170824T233458Z">
        <seg>/* 等待一个包含 Tid、int 和 double 类型的消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//          in a class destructor</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002129Z" creationid="Heromyth" creationdate="20170820T002129Z">
        <seg>//          显式分配内存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   false: overcast</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033314Z" creationid="大处着手小处着眼" creationdate="20160720T033314Z">
        <seg>//   false：阴天</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   has terminated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052144Z" creationid="Heromyth" creationdate="20170825T052144Z">
        <seg>//   它将抛出异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   thrown if the owner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052149Z" creationid="Heromyth" creationdate="20170825T052134Z">
        <seg>//   拥有者线程已经终止，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   thrown if the worker</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052348Z" creationid="Heromyth" creationdate="20170825T052348Z">
        <seg>//   工作线程已经终止，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>//   true : sunny</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033338Z" creationid="大处着手小处着眼" creationdate="20160720T033338Z">
        <seg>//   true ：晴天</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ... at the owner ...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051928Z" creationid="Heromyth" creationdate="20170825T051928Z">
        <seg>// ... 所有者线程 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Adding to the corresponding array, depending on</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030303Z" creationid="大处着手小处着眼" creationdate="20160726T030303Z">
        <seg>// 根据值的奇偶性，把值添加到</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An array that holds the weather information of all</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044505Z" creationid="大处着手小处着眼" creationdate="20160720T033122Z">
        <seg>// 保存所有城市气象信息的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// An array that holds the weights of a hundred boxes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033502Z" creationid="大处着手小处着眼" creationdate="20160720T033502Z">
        <seg>// 保存一百个箱子重量的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Concatenate:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153500Z" creationid="大处着手小处着眼" creationdate="20160715T033356Z">
        <seg>// 连接：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Information about the students of a school</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033532Z" creationid="大处着手小处着眼" creationdate="20160720T033532Z">
        <seg>// 有关学校学生的信息</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Printing the array elements in a loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030650Z" creationid="大处着手小处着眼" creationdate="20160726T030650Z">
        <seg>// 在循环中输出数组元素</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reading the value</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030108Z" creationid="大处着手小处着眼" creationdate="20160726T030108Z">
        <seg>// 从输入流中读取值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reading the values in a loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025423Z" creationid="大处着手小处着眼" creationdate="20160725T073220Z">
        <seg>// 在循环中从输入流读取元素值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The counter is commonly named as 'i'</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025710Z" creationid="大处着手小处着眼" creationdate="20160726T025710Z">
        <seg>// 计数器通常命名作‘i’</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The definition of a fixed-length array of five</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072914Z" creationid="大处着手小处着眼" creationdate="20160725T072914Z">
        <seg>// 定义了一个可包含五个 double </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The loop that calculates the fifths of the values would</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050503Z" creationid="大处着手小处着眼" creationdate="20160725T074237Z">
        <seg>// 经过计算的五个数值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The odds and evens arrays are sorted separately</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030529Z" creationid="大处着手小处着眼" creationdate="20160726T030529Z">
        <seg>// 分别排序奇偶数的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The special value of -1 breaks the loop</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030137Z" creationid="大处着手小处着眼" creationdate="20160726T030137Z">
        <seg>// 特殊值 -1 中断循环</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The two arrays are then appended to form a new array</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084011Z" creationid="大处着手小处着眼" creationdate="20160726T030624Z">
        <seg>// 连接两个数组从而形成一个新数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a definition.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014411Z" creationid="大处着手小处着眼" creationdate="20160724T025327Z">
        <seg>// 这个是数组的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is an access.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014444Z" creationid="大处着手小处着眼" creationdate="20160725T014130Z">
        <seg>// 这个是数组的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is another access.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014618Z" creationid="大处着手小处着眼" creationdate="20160725T014618Z">
        <seg>// 这是另一个访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This variable is used as a loop counter</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050225Z" creationid="大处着手小处着眼" creationdate="20160725T072652Z">
        <seg>// 该变量用作循环计数器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Using dynamic arrays because it is not known how many</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030010Z" creationid="大处着手小处着眼" creationdate="20160726T030010Z">
        <seg>// 使用动态数组的原因是不知道有多少</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 0 with key "Monday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090946Z" creationid="Hipter" creationdate="20160708T145014Z">
        <seg>// 关联值 0 与 键 “Monday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// associates value 1 with key "Tuesday"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090956Z" creationid="Hipter" creationdate="20160708T145024Z">
        <seg>// 关联值 1 与 键 “Tuesday”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// be written similarly
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T050445Z" creationid="大处着手小处着眼" creationdate="20160725T074248Z">
        <seg>//将在循环中输出
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044438Z" creationid="大处着手小处着眼" creationdate="20160720T033142Z">
        <seg>// 数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// corresponds to December and sets its value to 31.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014554Z" creationid="大处着手小处着眼" creationdate="20160725T014554Z">
        <seg>// 十二月的元素，并设置它的值为 31。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// corresponds to January, the value of which is passed to</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014818Z" creationid="大处着手小处着眼" creationdate="20160725T014726Z">
        <seg>// 一月的元素，并把它的值传给</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// elements of type double</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072939Z" creationid="大处着手小处着眼" creationdate="20160725T072939Z">
        <seg>// 类型元素的数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" does not exist in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T145133Z" creationid="Hipter" creationdate="20160709T035323Z">
        <seg>// 这张表里不存在 “purple” 键</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// key "purple" exists in the table</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T091115Z" creationid="Hipter" creationdate="20160709T035300Z">
        <seg>// 键 “purple” 在表中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// number if there is no remainder when divided by 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T141551Z" creationid="大处着手小处着眼" creationdate="20160726T030452Z">
        <seg>// 除时没有余数，那这个数就是偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// of 12 elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025446Z" creationid="大处着手小处着眼" creationdate="20160724T025446Z">
        <seg>// 12个元素的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// of days in each month.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025653Z" creationid="大处着手小处着眼" creationdate="20160724T025653Z">
        <seg>// 每个月的天数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// values are going to be read from the input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030041Z" creationid="大处着手小处着眼" creationdate="20160726T030041Z">
        <seg>// 值要从输入流中读取</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// whether the value is odd or even.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030322Z" creationid="大处着手小处着眼" creationdate="20160726T030322Z">
        <seg>//相应的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// writeln.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014829Z" creationid="大处着手小处着眼" creationdate="20160725T014829Z">
        <seg>// writeln 函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== != &lt; &lt;= &gt; &gt;= || &amp;&amp;))
$(LI $(LINK2 /ders/d.en/if.html, if Statement) $(INDEX_KEYWORDS if else))
$(LI $(LINK2 /ders/d.en/while.html, while Loop) $(INDEX_KEYWORDS while continue break))
$(LI $(LINK2 /ders/d.en/arithmetic.html, Integers and Arithmetic Operations) $(INDEX_KEYWORDS ++ -- + - * / % ^^ += -= *= /= %= ^^=))
$(LI $(LINK2 /ders/d.en/floating_point.html, Floating Point Types) $(INDEX_KEYWORDS .nan .infinity isNaN))
$(LI $(LINK2 /ders/d.en/arrays.html, Arrays) $(INDEX_KEYWORDS [] .length ~ ~=))
$(LI $(LINK2 /ders/d.en/characters.html, Characters) $(INDEX_KEYWORDS char wchar dchar))
$(LI $(LINK2 /ders/d.en/slices.html, Slices and Other Array Features) $(INDEX_KEYWORDS ..</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170801T100919Z" creationid="Heromyth" creationdate="20170801T100919Z">
        <seg>== != &lt; &lt;= &gt; &gt;= || &amp;&amp;))
$(LI $(LINK2 /ders/d.cn/if.html, if 语句) $(INDEX_KEYWORDS if else))
$(LI $(LINK2 /ders/d.cn/while.html, while 循环) $(INDEX_KEYWORDS while continue break))
$(LI $(LINK2 /ders/d.cn/arithmetic.html, 整型和算术运算) $(INDEX_KEYWORDS ++ -- + - * / % ^^ += -= *= /= %= ^^=))
$(LI $(LINK2 /ders/d.cn/floating_point.html, 浮点类型) $(INDEX_KEYWORDS .nan .infinity isNaN))
$(LI $(LINK2 /ders/d.cn/arrays.html, 数组) $(INDEX_KEYWORDS [] .length ~ ~=))
$(LI $(LINK2 /ders/d.cn/characters.html, 字符) $(INDEX_KEYWORDS char wchar dchar))
$(LI $(LINK2 /ders/d.cn/slices.html, 分片与其他数组功能) $(INDEX_KEYWORDS ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@$(HILITE $(PARANTEZ_AC))Encrypted, Colored$(HILITE $(PARANTEZ_KAPA)) string address;    $(CODE_NOTE together)
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043202Z" creationid="Heromyth" creationdate="20170803T043202Z">
        <seg>@$(HILITE $(PARANTEZ_AC))Encrypted, Colored$(HILITE $(PARANTEZ_KAPA)) string address;    $(CODE_NOTE 组合一起)
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@(42)                int d;    $(CODE_NOTE literal (discouraged))
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043642Z" creationid="Heromyth" creationdate="20170803T043642Z">
        <seg>@(42)                int d;    $(CODE_NOTE 文字量（不赞成）)
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Colored(Color.blue) int c;    $(CODE_NOTE object)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043625Z" creationid="Heromyth" creationdate="20170803T043625Z">
        <seg>@Colored(Color.blue) int c;    $(CODE_NOTE 对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted           int a;    $(CODE_NOTE type name)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043608Z" creationid="Heromyth" creationdate="20170803T043608Z">
        <seg>@Encrypted           int a;    $(CODE_NOTE 类型名)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted @Colored string lastName;     $(CODE_NOTE separately)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043207Z" creationid="Heromyth" creationdate="20170803T043139Z">
        <seg>@Encrypted @Colored string lastName;     $(CODE_NOTE 单独分开)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>@Encrypted()         int b;    $(CODE_NOTE object)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043617Z" creationid="Heromyth" creationdate="20170803T043617Z">
        <seg>@Encrypted()         int b;    $(CODE_NOTE 对象)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A benefit of $(C scope(failure)) is the fact that the expression that reverts another expression is written close to it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T034926Z" creationid="Hipter" creationdate="20160707T034511Z">
        <seg>$(C scope(failure)) 的好处是靠近它的表达式可以还原已写的另一个表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A problem that this may cause is when we try to replace a two-code-unit character with a single-code-unit character:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T014415Z" creationid="大处着手小处着眼" creationdate="20160714T014341Z">
        <seg>当我们试着用一个单字节字符替换一个双字节字符时问题就来了：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A thread that is busily working at a given time is said to be $(I CPU bound) at that point in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232048Z" creationid="Heromyth" creationdate="20170824T232048Z">
        <seg>在指定运行时间消耗大量 CPU 资源的线程叫做 $(I CPU 密集型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing an array with an invalid index causes the program to be terminated with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T023148Z" creationid="大处着手小处着眼" creationdate="20160725T023148Z">
        <seg>访问具有无效索引的数组将导致出错从而终止程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to this definition, arrays are containers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T141542Z" creationid="大处着手小处着眼" creationdate="20160723T141542Z">
        <seg>根据定义，数组就是容器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ada, C, C++, and D are some of them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005030Z" creationid="Heromyth" creationdate="20170820T005030Z">
        <seg>Ada、C、C++ 和 D 都属于这样的语言。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, interpreters usually perform very little analysis on the code before executing it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004604Z" creationid="Heromyth" creationdate="20170820T004604Z">
        <seg>此外，解释器在执行代码之前对代码的分析大都非常有限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the languages that are easy to compile are usually less dynamic than those that run in an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004927Z" creationid="Heromyth" creationdate="20170820T004927Z">
        <seg>此外，容易编译的语言与在解释器中运行的语言相比往往缺乏灵活性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, this program takes advantage of a special message type to signal to the worker when it is time to exit:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045140Z" creationid="Heromyth" creationdate="20170825T045140Z">
        <seg>此外，这个程序还使用了特殊的消息类型来通知工作线程退出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All members may have already been finalized when the destructor is executing.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001709Z" creationid="Heromyth" creationdate="20170820T001709Z">
        <seg>当析构函数执行时，全部成员应该已经终结。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the operations of the program are normally executed on that thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012510Z" creationid="Heromyth" creationdate="20170824T012510Z">
        <seg>通常情况下程序的所有操作都将在这个线程中完成。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the number of the month, which is in the range &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt;, is converted to a valid array index in the range &lt;span style="white-space: nowrap"&gt;0-11&lt;/span&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011231Z" creationid="大处着手小处着眼" creationdate="20160726T010435Z">
        <seg>另外请注意， &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; 范围内的月份数字转换为了有效的数组索引范围 &lt;span style="white-space: nowrap"&gt;0-11&lt;/span&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, unlike arrays, the elements of hash tables are not stored side-by-side.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T131420Z" creationid="Hipter" creationdate="20160708T092324Z">
        <seg>不像数组，hash 表的元素不是逐个排列存储的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it may seem syntactically that operations are being performed on a class $(I variable), the operations are actually dispatched to a class $(I object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T010501Z" creationid="Hipter" creationdate="20160706T010501Z">
        <seg>虽然语法上看起来是在类 $(I 变量) 上执行，但实际上调度了一个类 $(I object)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although simple, arrays are the most common data structure used to store a collection of values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022207Z" creationid="大处着手小处着眼" creationdate="20160720T022155Z">
        <seg>虽然简单，但数组是用于存储值的集合中最常见的数据结构。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although this difference makes associative arrays use more memory, it also allows them to use $(I sparse) key values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233339Z" creationid="Hipter" creationdate="20160708T093947Z">
        <seg>虽然这种不同让关联数组使用更多内存，但它也允许它们使用$(I 稀疏)键值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array that stores the names of the days of the week can be defined like this:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T143411Z" creationid="Hipter" creationdate="20160708T083910Z">
        <seg>一个存储一周当中每天的英文名称的数组可以定义下面这样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of a concurrent program would be a server program that is responding to requests of more than one client at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012047Z" creationid="Heromyth" creationdate="20170824T012047Z">
        <seg>比如说服务器程序就是并发的，它需要在同一时间处理多个客户端的请求。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any operations that are carried out by that function, including other functions that it may call, would be executed on the new thread.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054254Z" creationid="Heromyth" creationdate="20170824T054254Z">
        <seg>函数中进行的包括函数调用在内的所有操作都将在新线程中执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any value that is entered outside of the &lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; range would cause the program to be terminated with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T011653Z" creationid="大处着手小处着眼" creationdate="20160726T011653Z">
        <seg>&lt;span style="white-space: nowrap"&gt;1-12&lt;/span&gt; 范围外的任何值都将导致程序出现错误而终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays of these character types lead to three separate string types, some of which may have surprising outcomes in some string operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T110916Z" creationid="Hipter" creationdate="20160711T092039Z">
        <seg>这些字符类型的数组对应着三种独立的字符串类型，其中一些可能会在一些字符串操作上有出人意料的结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, even operations as simple as incrementing a variable may be paused mid operation:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012558Z" creationid="Heromyth" creationdate="20170824T012558Z">
        <seg>也就是说，即使是一个简单的自增操作也可能会在执行到一半时被操作系统暂停：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, most interpreters discover programming errors only after they start executing the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004620Z" creationid="Heromyth" creationdate="20170820T004620Z">
        <seg>最后，大多数解释器在执行程序之后方能发现编程错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the program uses invalid indexes and attempts to access elements that are not parts of the arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031254Z" creationid="大处着手小处着眼" creationdate="20160726T031254Z">
        <seg>结果是，程序使用无效的索引，试图访问不在数组中的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As it should be in every design decision that concerns program performance, one must take actual measurements to be exactly sure whether that really is the case.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232153Z" creationid="Heromyth" creationdate="20170824T232153Z">
        <seg>基于对性能设计的考量，我们需要谨慎分析并确定线程的类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the value of that variable is incremented at the end of each iteration, the $(C values[counter]) expression refers to the elements of the array one by one: $(C values[0]), $(C values[1]), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T080800Z" creationid="大处着手小处着眼" creationdate="20160725T080744Z">
        <seg>在每个迭代结束时该变量值都会递增，$(C values[counter]) 表达式指的是数组的逐个元素：$(C values[0])、$(C values[1]) 等等。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As these two concepts both involve executing programs on threads, and as parallelism is based on concurrency, they are sometimes confused with each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T011615Z" creationid="Heromyth" creationdate="20170824T011615Z">
        <seg>这两个概念都涉及多线程，且并行是基于并发的，在刚接触它们时有些迷惑也是正常的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen above, the destructor is executed some time in the future during a garbage collection cycle.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T134733Z" creationid="Heromyth" creationdate="20170819T134733Z">
        <seg>正如上面看到的，析构函数会在未来垃圾回收周期内的某个时候被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we have seen in the $(LINK2 /ders/d.en/characters.html, Characters chapter), D has three separate character types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135037Z" creationid="Hipter" creationdate="20160711T091315Z">
        <seg>正如我们在 $(LINK2 /ders/d.cn/characters.html, 字符) 一章中看到的，D 具有三种独立的字符类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we will see below, it is also possible to receive $(C OwnerTerminated) and $(C LinkTerminated) exceptions as messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044720Z" creationid="Heromyth" creationdate="20170825T044720Z">
        <seg>就像我们下面看到的那样，可以将 $(C OwnerTerminated) 和 $(C LinkTerminated) 当作消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning that return value back to $(C name) produces the intended output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T021109Z" creationid="Hipter" creationdate="20160712T021109Z">
        <seg>返回值再赋值给 $(C name)，得到预期的输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays are initialized similarly to regular arrays, using a colon to separate each key from its respective value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T024011Z" creationid="Hipter" creationdate="20160709T031925Z">
        <seg>关联数组的初始化与常规数组相似，不同的是用冒号分隔每个键与相应的值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associative arrays store their elements as key-value pairs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T090211Z">
        <seg>关联数组通过键值对存储它们的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming that the leftmost 3 bits are the operation number and the rightmost 5 bits are the value that is used in that operation, a sample program in machine code for this CPU might look like the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003804Z" creationid="Heromyth" creationdate="20170820T003804Z">
        <seg>假定最左边 3 位表示操作码，最右边 5 位表示用于运算的值，该 8 位 CPU 上机器码示例程序如下所示：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the lowest level these machine code instructions are implemented as electrical signals.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003654Z" creationid="Heromyth" creationdate="20170820T003654Z">
        <seg>它们在最底层由电子信号实现。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BREADCRUMBS_FULL=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; $(LINK2 /ders/d.en/index.html, Prg in D)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170823T010647Z" creationid="Heromyth" creationdate="20170820T014719Z">
        <seg>BREADCRUMBS_FULL=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; $(LINK2 /ders/d.cn/index.html, D 语言编程)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BREADCRUMBS_INDEX=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; Prg in D</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014714Z" creationid="Heromyth" creationdate="20170820T014714Z">
        <seg>BREADCRUMBS_INDEX=$(LINK2 /index.html, Main Page) &amp;gt; $(LINK2 /ders/index.html, Books) &amp;gt; D 语言编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because array elements are stored side-by-side in memory, index values are implicitly the relative positions of elements from the beginning of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093155Z" creationid="Hipter" creationdate="20160708T093357Z">
        <seg>因为在内存中数组元素是逐个存储的，索引值就是元素位置与数组的起始位置的相对值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because such an exception would terminate the worker thread right away, the owner in the following program can receive a response only for the first message:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044959Z" creationid="Heromyth" creationdate="20170825T044959Z">
        <seg>由于异常会立刻终止工作线程，所有者只能收到第一条消息的反馈：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the ease of coding is not a primary consideration at this level, writing programs directly in the form of the machine code of the CPU is a very difficult task.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003705Z" creationid="Heromyth" creationdate="20170820T003705Z">
        <seg>在这层，编码的舒适度不是主要考虑因素，所以直接按照 CPU 机器码形式编写程序非常困难。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there may be more than one $(I slice) to the same elements, $(C remove()) cannot actually change the number of element of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144435Z" creationid="Heromyth" creationdate="20170817T143753Z">
        <seg>由于数组里可能拥有多个具有相同元素的 $(I 分片) ，$(C remove()) 实际上不会改变原有数组的元素个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Being value types, $(C o) and $(C i) are copied automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023459Z" creationid="Hipter" creationdate="20160706T023459Z">
        <seg>做为值类型，$(C o) 和 $(C i) 自动被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By this definition, classes are $(I user defined types).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T115500Z" creationid="Heromyth" creationdate="20170819T115500Z">
        <seg>根据此定义，类是 $(I 自定义类型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>COZUM_METIN=the solution
COZUMLER_METIN=the solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060242Z" creationid="Heromyth" creationdate="20170718T105637Z">
        <seg>COZUM_METIN=答案
COZUMLER_METIN=答案</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Can you figure out the remaining problem before reading the following paragraph?</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031548Z" creationid="大处着手小处着眼" creationdate="20160726T031548Z">
        <seg>在没有读下面这段话之前你能指出剩下的问题吗？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining the result of $(C readln()) to $(C strip()) enables a shorter and more readable syntax:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T140612Z" creationid="Hipter" creationdate="20160712T021719Z">
        <seg>把 $(C readln()) 的结果放到 $(C strip()) 中，能得到更短且可读性更好的语法：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking against $(C null) must be done by $(C is) or $(C !is), not by $(C ==) or $(C !=).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020106Z" creationid="Hipter" creationdate="20160707T020106Z">
        <seg>检查 $(C null) 必须使用 $(C is) 或 $(C !is)，而不是 $(C ==) 或 $(C !=)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class variables do not have members, the class objects do.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004327Z" creationid="Hipter" creationdate="20160707T004327Z">
        <seg>类变量没有成员，类对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class variables do not have values themselves; the actual class objects must be constructed by the $(C new) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T125718Z" creationid="Heromyth" creationdate="20170819T125718Z">
        <seg>类变量并不拥有值本身；实际的类对象必须使用关键字 $(C new) 来构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes will be explained in more detail in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123613Z" creationid="Heromyth" creationdate="20170819T123613Z">
        <seg>稍后的章节中将展示类的更多细节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compilers usually perform advanced analysis on the code, which help with producing fast programs and catching programming errors before the program even starts running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004854Z" creationid="Heromyth" creationdate="20170820T004854Z">
        <seg>编译器素来对源码进行深入的分析，这有助于生成更高效的程序，甚至于在程序执行之前就捕捉到编程错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency is about making a program run on more than one thread at a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012106Z" creationid="Heromyth" creationdate="20170824T012037Z">
        <seg>并发即程序同时运行多个线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency is easy only when it is based on $(I message passing).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012251Z" creationid="Heromyth" creationdate="20170824T012251Z">
        <seg>并发则只有在基于 $(I 消息传递) 时才比较简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency makes use of threads explicitly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012205Z" creationid="Heromyth" creationdate="20170824T012205Z">
        <seg>而并发则需要显式调用线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concurrency on the other hand, is a concept that may be needed even on a single-core environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012004Z" creationid="Heromyth" creationdate="20170824T012004Z">
        <seg>而并发这个概念在单核心系统中也有用到。并发即程序同时运行多个线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20080919T151013Z" creationid="ZXP" creationdate="20080919T151013Z">
        <seg>内容</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D programs are written in text editors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003147Z" creationid="Heromyth" creationdate="20170820T003147Z">
        <seg>D 程序需要在文本编辑器里编写。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D programs start executing with $(C main()) on a thread that has been assigned to that program by the operating system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012459Z" creationid="Heromyth" creationdate="20170824T012459Z">
        <seg>D 语言程序在操作系统指定的线程上执行 $(C main()) 函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DERLEME_HATASI_METIN=compilation ERROR</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105651Z" creationid="Heromyth" creationdate="20170718T105651Z">
        <seg>DERLEME_HATASI_METIN=编译出错</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Assigning user defined attributes to declarations, determining the attributes at compile time, and compiling the code according to those attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T053512Z" creationid="Heromyth" creationdate="20170815T053512Z">
        <seg>DESCRIPTION=为声明加上自定义属性、在编译时检测属性，并根据那些属性编译代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Basic array operations of the D programming language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T150219Z" creationid="大处着手小处着眼" creationdate="20160726T024919Z">
        <seg>DESCRIPTION=D 语言的数组基本操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=D programming language tutorial from the ground up.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T032110Z" creationid="Heromyth" creationdate="20170726T032110Z">
        <seg>DESCRIPTION=全新编写的 D 编程语言教程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022345Z" creationid="Hipter" creationdate="20160711T022345Z">
        <seg>DESCRIPTION=D语言习题解答：关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032947Z" creationid="大处着手小处着眼" creationdate="20160726T032947Z">
        <seg>DESCRIPTION=D 语言编程习题解答：数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=Programming in D exercise solutions: strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T134924Z" creationid="大处着手小处着眼" creationdate="20160714T095637Z">
        <seg>DESCRIPTION=D 语言编程习题解答：字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The associative arrays of the d programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092656Z" creationid="Hipter" creationdate="20160709T092656Z">
        <seg>DESCRIPTION=D语言的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The basic object oriented programming (OOP) feature of the D programming language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013728Z" creationid="Hipter" creationdate="20160707T020838Z">
        <seg>DESCRIPTION=基本的 D 语言面向对象编程（OOP） 功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The introduction of the compiler and compiled languages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005338Z" creationid="Heromyth" creationdate="20170820T005338Z">
        <seg>DESCRIPTION=编译与编译型编程语言简介</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The scope(success), scope(failure), and scope(exit) statements that are used for specifying expressions that must be executed when exiting scopes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045751Z" creationid="Hipter" creationdate="20160707T045751Z">
        <seg>DESCRIPTION=scope(success)，scope(failure)，和 scope(exit) 语句用于当退出作用域时一定要执行的特殊表达式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DESCRIPTION=The strings of the D programming language</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T154816Z" creationid="大处着手小处着眼" creationdate="20160715T144240Z">
        <seg>DESCRIPTION=D 语言的字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DUSEY_NAVIGASYON=
&lt;div class="vertinavheader"&gt;Other D Resources&lt;/div&gt;
$(UL
$(LI $(LINK2 http://wiki.dlang.org/Books, $(IMG bullet_black.png) Books))
$(LI $(LINK2 http://forum.dlang.org/, $(IMG bullet_black.png) Newsgroups))
$(LI $(LINK2 http://dlang.org/lex.html, $(IMG bullet_black.png) Language spec))
$(LI $(LINK2 http://dlang.org/phobos/index.html, $(IMG bullet_black.png) Standard library))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105310Z" creationid="Heromyth" creationdate="20170718T105310Z">
        <seg>DUSEY_NAVIGASYON=
&lt;div class="vertinavheader"&gt;其他D语言资源&lt;/div&gt;
$(UL
$(LI $(LINK2 http://wiki.dlang.org/Books, $(IMG bullet_black.png) 书籍))
$(LI $(LINK2 http://forum.dlang.org/, $(IMG bullet_black.png) 社区))
$(LI $(LINK2 http://dlang.org/lex.html, $(IMG bullet_black.png) 语言规范))
$(LI $(LINK2 http://dlang.org/phobos/index.html, $(IMG bullet_black.png) 标准库))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ddoc</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070111T134422Z" creationid="ZXP" creationdate="20070111T134422Z">
        <seg>Ddoc</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define an associative array that can store multiple grades per student.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092617Z" creationid="Hipter" creationdate="20160709T092617Z">
        <seg>定义一个能存储每个学生的多个成绩的关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different from an interpreter, it does not execute the code; rather, it produces a program written in another language (usually machine code).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004734Z" creationid="Heromyth" creationdate="20170820T004734Z">
        <seg>与解释器不同的是，它不立即执行代码，而是生成一个用其他语言（通常为机器码）表示的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different from structs, classes provide the $(I object oriented programming) (OOP) paradigm in D. The major aspects of OOP are the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T120242Z" creationid="Heromyth" creationdate="20170819T120242Z">
        <seg>不同于结构的是，D 语言中的类提供的是 $(I 面向对象编程) （OOP）模型。OOP 的主要内容有以下几个方面：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even its $(C toString()) function is not overloaded:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232544Z" creationid="Heromyth" creationdate="20170824T232544Z">
        <seg>它甚至连 $(C toString()) 都没重载：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the two objects are constructed by the same character $(C'♔'), they are still two separate objects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015411Z" creationid="Hipter" creationdate="20160707T015411Z">
        <seg>即使这两个对象由同一字符 $(C'♔')  参数构造，, 它们仍是两个单独的对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executing the $(C scope) statements in reverse order enables undoing side effects of earlier expressions in a consistent order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045550Z" creationid="Hipter" creationdate="20160707T045428Z">
        <seg>这样按相反顺序执行 $(C scope) 语句，让程序能按一致的顺序撤消前边表达式的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For classes, the meaning of $(C opAssign) is always $(I associating a class variable with a class object).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T005153Z" creationid="Hipter" creationdate="20160707T005153Z">
        <seg>对于类， $(C opAssign) 意味着 $(I 一个类变量总是关联着一个类对象)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C __traits(getMember, Person, $(STRING "name"))) produces the symbol $(C Person.name).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T134631Z" creationid="Heromyth" creationdate="20170805T134631Z">
        <seg>例如，$(C __traits(getMember, Person, $(STRING "name"))) 生成的符号是 $(C Person.name)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C char[]) is a type of string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144519Z" creationid="Hipter" creationdate="20160711T091203Z">
        <seg>例如，$(C char[]) 是一个字符串类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, $(C dayNumbers) would have two key-value pairs after the operations above.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T145157Z">
        <seg>例如，上面的操作结束后 $(C dayNumbers) 将有两个键值对。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 'A' and 'a' are different letters, when directly comparing Unicode strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143527Z" creationid="大处着手小处着眼" creationdate="20160715T143527Z">
        <seg>例如，当直接比较 Unicode 字符串时，‘A’和‘a’是不同的字母。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, 'B' comes before 'a'.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143708Z" creationid="大处着手小处着眼" creationdate="20160715T143708Z">
        <seg>例如，‘B’排在‘a’之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, all of the members of $(C Person) can become encrypted in the XML output by the trivial change below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170816T042440Z" creationid="Heromyth" creationdate="20170816T042440Z">
        <seg>例如，$(C Person) 的所有成员在 XML 格式输出里都会被加密，类似下面内容：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, an array that holds the air temperatures of the days in July can bring 31 $(C double) values together and form $(I a container of elements of type $(C double)).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044854Z" creationid="大处着手小处着眼" creationdate="20160723T142638Z">
        <seg>例如，一个保存了七月每天的气温的数组能汇集 31 个 double 值，形成一个 $(I $(C double) 类型元素的容器)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, as the $(C formattedRead()) call above expects to read $(I two) items (a $(C string) as name and an $(C int) as age), the following check ensures that it really is the case:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063415Z" creationid="Hipter" creationdate="20160712T074138Z">
        <seg>例如，像上面的 $(C formattedRead()) 函数期望去读$(I 两个)项目(一个 $(C string) 型 name 和一个 $(C int) 型 age)，下面的检查确定它真是这样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, assuming that a $(C Student) class represents students by their names and grades, such information would be stored by the members of $(C Student) $(I objects).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131502Z" creationid="Heromyth" creationdate="20170819T131502Z">
        <seg>例如，有一个 $(C Student) 类，它通过姓名和成绩来表示学生， 此时 $(C Student) $(I 对象)的成员会存储这些信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both of the following variables have the same attributes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042510Z" creationid="Heromyth" creationdate="20170720T042510Z">
        <seg>例如，下面的变量拥有的属性是相同的：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, for an imaginary 8-bit CPU, the number 4 might represent the operation of loading, the number 5 might represent the operation of storing, and the number 6 might represent the operation of incrementing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003729Z" creationid="Heromyth" creationdate="20170820T003729Z">
        <seg>例如，对于虚构的 8 位 CPU 来说，数字 4 可能表示载入操作，数字 5 可能表示存储操作，而数字 6 可能表示递增操作。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, for the code above, an interpreter would understand to first execute $(C a_card_has_been_played()) and then conditionally execute $(C display_the_card()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004312Z" creationid="Heromyth" creationdate="20170820T004312Z">
        <seg>例如，对于上述代码，解释器会首先执行 $(C a_card_has_been_played()) ，而后根据其执行结果选择性地执行 $(C display_the_card())。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if $(C s) is a variable of type $(C char[]), the following line will fail to compile:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T032200Z" creationid="Hipter" creationdate="20160713T030425Z">
        <seg>例如，如果 $(C s) 的变量类型是 $(C char[])，下面这行将编译失败：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, let's assume that the grades 90, 85, 95, etc. are to be stored for the student named "emre".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233623Z" creationid="Hipter" creationdate="20160709T090853Z">
        <seg>例如，我们假设存储学生“emre”的成绩 90，85，95 等等。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, memory used for the elements of a dynamic array is allocated by the garbage collector as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002415Z" creationid="Heromyth" creationdate="20170820T002415Z">
        <seg>例如，用于一个动态数组的元素的内存由垃圾回收器来分配。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the character 'é' (the latin letter 'e' combined with an acute accent) is represented by Unicode encodings using at least two bytes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T150017Z" creationid="大处着手小处着眼" creationdate="20160714T011821Z">
        <seg>例如，字符‘é’ (拉丁字母‘e’包含了一个重音符) 由 Unicode 编码表示，至少用了两个字节。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the characters of a $(C wchar[]) can be modified but the characters of a $(C wstring) cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T132216Z" creationid="Hipter" creationdate="20160712T081951Z">
        <seg>例如，可以修改一个 $(C wchar[]) 中的字符，但不可以修改一个 $(C wstring) 中的字符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the elements of the array holding the number of days in each month can be shown like the following (assuming a year when February has 28 days):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024134Z" creationid="大处着手小处着眼" creationdate="20160725T023841Z">
        <seg>例如，下面数组的元素保存了每个月的天数（假定一年中二月有 28 天）：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code assigns the $(C Encrypted) attribute to the declaration of $(C name):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T042203Z" creationid="Heromyth" creationdate="20170720T042203Z">
        <seg>例如，下面代码会将 $(C Encrypted) 属性赋予 $(C name) 声明：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code removes the element at index 1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145128Z" creationid="Heromyth" creationdate="20170817T145128Z">
        <seg>例如，下面这段代码将删除索引1上的那个元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code removes the elements of the array that are equal to 42.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T145726Z" creationid="Heromyth" creationdate="20170817T145726Z">
        <seg>例如，下面这段代码将删除数组里等于 42 的所有元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the month can be determined by the value of the $(C monthIndex) variable below:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T021651Z" creationid="大处着手小处着眼" creationdate="20160725T021651Z">
        <seg>例如，下面通过变量 $(C monthIndex) 的值来确定该月：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the special value of -1 can be used as the code for colors that are not in $(C colorCodes).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T035915Z" creationid="Hipter" creationdate="20160709T035915Z">
        <seg>例如，特殊值 -1 用作不在 $(C colorCodes) 中的  colors 代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the valid indexes of a three-element array are 0, 1, and 2.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T022748Z" creationid="大处着手小处着眼" creationdate="20160725T022748Z">
        <seg>例如，一个具有三个元素的数组的有效索引是 0、1 和 2。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the line is "this line has five words" the program should print "e has five".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144021Z" creationid="大处着手小处着眼" creationdate="20160715T144021Z">
        <seg>例如，若这行是“this line has five words”程序就应该打印出“e has five”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the member is $(STRING "name"), the right-hand side expression becomes $(C object.name.to!string).)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042157Z" creationid="Heromyth" creationdate="20170815T042157Z">
        <seg>例如，当成员为 $(STRING "name") 时，对应的表达式会变成 $(C object.name.to!string)。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when the strings are "ebru" and "domates" the program should print "Ebru&amp;nbsp;Domates".</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143945Z" creationid="大处着手小处着眼" creationdate="20160715T143945Z">
        <seg>例如，字符串是“ebru”和“domates”，程序应该打印出“Ebru&amp;nbsp;Domates”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when there are just two elements to store for keys 0 and 999, an associative array stores just two elements, not 1000 as a plain array has to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233433Z" creationid="Hipter" creationdate="20160708T094744Z">
        <seg>例如，对于键 0 和 999，当只有两个元素要存储时，关联数组就只存储两个元素，而不像简单数组那样必须 1000 个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20100615T034848Z" creationid="ZXP" creationdate="20070103T141309Z">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if the user inputs the text "résumé" you and your program cannot assume that the string length will be 6 even for $(C dchar) strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152446Z" creationid="大处着手小处着眼" creationdate="20160715T005840Z">
        <seg>例如，如果用户输入文本“résumé”，即使使用 $(C dchar) 字符串，你和你的程序仍然不能确保字符串的长度会是6。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason and in general, a compiled program runs faster compared to executing that program with an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004843Z" creationid="Heromyth" creationdate="20170820T004843Z">
        <seg>出于这个原因，通常情况下被编译的程序较被解释器所执行的程序运行更快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, class variables must always be compared by the $(C is) and $(C !is) operators.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130731Z" creationid="Heromyth" creationdate="20170819T130731Z">
        <seg>因此，类变量必须总是通过运算符 $(C is) 和 $(C !is) 进行比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, running a program with an interpreter is usually slower than running the compiled version of the same program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004518Z" creationid="Heromyth" creationdate="20170820T004518Z">
        <seg>这也就是为什么使用解释器执行程序往往要比直接执行编译版本的同一程序要慢。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, the result of the remove operation must be assigned back to the same array variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144130Z" creationid="Heromyth" creationdate="20170817T144130Z">
        <seg>基于此，删除操作的结果必须回赋给同一个数组变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, when we assign a new key-value pair and the key already exists, the table does not grow; instead, the value of the existing key changes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132325Z" creationid="Hipter" creationdate="20160709T030446Z">
        <seg>因而，给一个存在的键赋值，表不增长，而现有键所对应的值会发生变化：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For that reason, you may get results that don't match your expectations below.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153710Z" creationid="大处着手小处着眼" creationdate="20160715T034256Z">
        <seg>因此，下面的输出结果不是你所期望的那样。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these reasons, $(C readf()) does not work as intended when reading strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T095603Z" creationid="Hipter" creationdate="20160711T095603Z">
        <seg>因而，$(C readf()) 不能如愿读取字符串：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the point of view of the programmer, executing with a compiler involves three steps: writing the source code, compiling it, and running the produced program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004821Z" creationid="Heromyth" creationdate="20170820T004821Z">
        <seg>这时，从程序员的角度来看，执行指令就分三个步骤：写代码、编译和执行生成的文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From the point of view of the programmer, executing with an interpreter involves just two steps: writing the source code and giving it to the interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004456Z" creationid="Heromyth" creationdate="20170820T004456Z">
        <seg>从程序员的角度来看，依赖解释器执行指令只涉及两个步骤：编写源代码和将源代码交由解释器处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Further, because there is no way to tell $(C readf()) how many characters to read, it continues to read until the end of the entire input.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144815Z" creationid="Hipter" creationdate="20160711T095339Z">
        <seg>另外，因为没有办法告诉 $(C readf()) 要读取多少字符，它持续读，直到整个输入结束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, since you would be unable to use a loop to iterate the 20 values, you would also have to repeat several lines 20 times, one time for each single-valued variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082255Z" creationid="大处着手小处着眼" creationdate="20160725T081423Z">
        <seg>此外，因为您无法使用循环遍历 20 个值，您也不得不把那几行代码重复 20 次，每个单值变量来一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>GERI_METIN=Prev
ILERI_METIN=Next
PROBLEM_METIN=Exercise
PROBLEM_COK_METIN=Exercises
PROBLEM_TEK_COZUMSUZ_METIN=the solution will be posted later...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105551Z" creationid="Heromyth" creationdate="20170718T105551Z">
        <seg>GERI_METIN=上一章
ILERI_METIN=下一章
PROBLEM_METIN=练习
PROBLEM_COK_METIN=练习
PROBLEM_TEK_COZUMSUZ_METIN=答案将随后公布……</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>HORIZNAV_CONTENT_DERSE_OZEL=$(LINK2 /ders/d.en/rss.xml, RSS&amp;nbsp;&lt;img src="$(ROOT_DIR)/image/rss-icon.png" border="0" width="16" height="16" alt="Programming in D RSS Feed"/&gt;)
$(BR)
$(LINK2 /ders/d.en/index.html,
Download or buy $(IMG book.png))</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T060009Z" creationid="Heromyth" creationdate="20170721T060009Z">
        <seg>HORIZNAV_CONTENT_DERSE_OZEL=$(LINK2 /ders/d.cn/rss.xml, RSS&amp;nbsp;&lt;img src="$(ROOT_DIR)/image/rss-icon.png" border="0" width="16" height="16" alt="RSS 订阅"/&gt;)
$(BR)
$(LINK2 /ders/d.cn/index.html,
下载或购买 $(IMG book.png))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash tables are among the fastest collections for storing and accessing elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T091320Z" creationid="Hipter" creationdate="20160708T091320Z">
        <seg>Hash 表是存储和访问元素的最快的集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Have the program sort the elements using $(C sort()) and then reverse the sorted elements using $(C reverse()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T022317Z" creationid="大处着手小处着眼" creationdate="20160726T022317Z">
        <seg>让程序使用 $(C sort()) 函数排序元素，然后使用 $(C reverse()) 函数反转排序的元素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the bool values may mean</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T033302Z" creationid="大处着手小处着眼" creationdate="20160720T033302Z">
        <seg>在这里，bool 值可能意味着</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because their meanings may not be clear, attributes consisting of literal values like $(C 42) are discouraged:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T043559Z" creationid="Heromyth" creationdate="20170803T043559Z">
        <seg>不过，因为它们的含义可能不是很清楚，因此不赞成大家使用文字量值（如 $(C 42) ）构成的属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the exceptions can be caught and sent explicitly by the worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044707Z" creationid="Heromyth" creationdate="20170825T044707Z">
        <seg>但你也可以在工作线程中手动捕获异常并将其发送给所有者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the grades cannot be inserted as in the following code because each grade would overwrite the previous one:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233816Z" creationid="Hipter" creationdate="20160709T092351Z">
        <seg>然而，不能像下面的代码这样插入成绩，因为后来的成绩将覆盖前一个：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, warnings almost always indicate an actual error or bad style, so it is a common practice to consider most or all warnings as errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005229Z" creationid="Heromyth" creationdate="20170820T005229Z">
        <seg>但是，警告几乎总是指示一个实际错误或糟糕的代码风格，所以把警告当作错误对待是一个常见的做法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the majority of its threads are I/O bound, then a program can afford to start more threads than the number of cores without any degradation of performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232138Z" creationid="Heromyth" creationdate="20170824T232138Z">
        <seg>如果大部分线程都是 I/O 密集型的，那程序就不需要担心由于线程数多余核心数而造成的性能下降的问题。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user eventually terminates the input that way, we see that the new-line characters have been read as parts of the string as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T135535Z" creationid="Hipter" creationdate="20160712T014616Z">
        <seg>如果用户最后这样结束输入，我们看到换行符已作为字符串的一部分被读取：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Illegal instructions are the ones that are outside the specifications of the language.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005132Z" creationid="Heromyth" creationdate="20170820T005132Z">
        <seg>非法指令指的是超出语言规范的地方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine needing a thousand values; it is almost impossible to define a thousand variables from $(C value_1) to $(C value_1000).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T021233Z" creationid="大处着手小处着眼" creationdate="20160720T021233Z">
        <seg>想象一下，需要一千个值；定义从 $(C value_1) 到 $(C value_1000) 一千个变量，这几乎是不可能的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In concurrency, it is normal for threads to depend on results of other threads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012141Z" creationid="Heromyth" creationdate="20170824T012141Z">
        <seg>而对于并发，线程间的相互依赖是很常见的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, it would be a bug if they did depend on results of other tasks that are running at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012132Z" creationid="Heromyth" creationdate="20170824T012132Z">
        <seg>事实上如果同时运行的任务依赖其他任务的结果就可能会引发程序的 bug。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, tasks that have been covered in the previous chapter are based on threads that are started automatically by $(C std.parallelism).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012537Z" creationid="Heromyth" creationdate="20170824T012537Z">
        <seg>实际上上一章我们学习的 task 就是基于线程的，只不过这些线程是由 $(C std.parallelism) 自动维护的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to copy class objects, the type must have a special function likely named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020430Z" creationid="Hipter" creationdate="20160707T020335Z">
        <seg>为了复制类对象，类型必须有一个类似于命名为 $(C dup()) 的特殊函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to use the $(C sort()) function, one must import the $(C std.algorithm) module first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021425Z" creationid="大处着手小处着眼" creationdate="20160726T021425Z">
        <seg>为了使用 $(C sort()) 函数，必须先导入 $(C std.algorithm) 模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, $(C opAssign) cannot be overloaded for them.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031807Z" creationid="Hipter" creationdate="20160706T031807Z">
        <seg>换句话说，$(C opAssign) 不能因为它们而被重载。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, arrays map indexes to values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T084530Z" creationid="Hipter" creationdate="20160708T084530Z">
        <seg>换句话说，数组映射索引到值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, class variables may not be providing access to any object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124942Z" creationid="Heromyth" creationdate="20170819T124942Z">
        <seg>换句话说，类变量可以不提供对任何对象的访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, instead of typing $(C value_1) one must type $(C values[0]) with arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T023208Z" creationid="大处着手小处着眼" creationdate="20160724T023208Z">
        <seg>换句话说，对数组输入 $(C values[0]) 而不是键入 $(C value_1) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it can be used as the opposite of the $(C dayNames) array at the beginning of this chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030433Z" creationid="Hipter" creationdate="20160708T141319Z">
        <seg>换句话说，它能用作本章开始处 $(C dayNames) 数组的逆转。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, it stores an array of ten integer values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T024436Z" creationid="大处着手小处着眼" creationdate="20160720T023707Z">
        <seg>换句话说，它是一个可存储十个整数值的数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases the template parameters of $(C receiveOnly()) must match the types of the tuple members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233435Z" creationid="Heromyth" creationdate="20170824T233435Z">
        <seg>此时，$(C receiveOnly()) 的模版参数的类型要与每一个 tuple 成员的类型对应：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the $(C .idup) property can be used to produce an immutable $(C string) variable from a mutable $(C char[]) variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T151939Z" creationid="Hipter" creationdate="20160713T030418Z">
        <seg>这种情况下，$(C .idup) property 能被用来从一个可变的 $(C char[]) 变量中生成一个不可变的 $(C string) 变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In such cases, the initial values of the elements can be specified on the right-hand side of the assignment operator, within square brackets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083958Z" creationid="大处着手小处着眼" creationdate="20160725T083958Z">
        <seg>在这种情况下，元素的初始值可以在分配操作的右手侧方括号内指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case all of the elements of the array are initialized to that value:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012049Z" creationid="大处着手小处着眼" creationdate="20160726T012049Z">
        <seg>在这种情况下，所有的数组元素都初始化为该值：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case it $(I returns) the line that it has just read.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063005Z" creationid="Hipter" creationdate="20160712T021418Z">
        <seg>在这种情况下它$(I 返回)刚刚读入的行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of integers, the elements get sorted from the smallest value to the greatest value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T021258Z" creationid="大处着手小处着眼" creationdate="20160726T021258Z">
        <seg>对于整数，元素按从小到大排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the simplest definition, strings are nothing but arrays of characters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091131Z" creationid="Hipter" creationdate="20160711T091131Z">
        <seg>在最简单的定义中，字符串只不过是字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the constructor must be defined as $(C pure) as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T133939Z" creationid="Heromyth" creationdate="20170819T133939Z">
        <seg>此时，构造函数必须同时定义为 $(C pure) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance is for acquiring $(I implementations) of other types.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T122731Z" creationid="Heromyth" creationdate="20170819T122731Z">
        <seg>继承是用于获取其它类型的 $(I 实现)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the comparison must be done by the $(C is) or the $(C !is) operator, accordingly:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130448Z" creationid="Heromyth" creationdate="20170819T130448Z">
        <seg>相反，必须相应地使用运算符 $(C is) 或 $(C !is)：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the elements are accessed by specifying the $(I element number) within square brackets:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T045216Z" creationid="大处着手小处着眼" creationdate="20160724T022032Z">
        <seg>相反，通过指定方括号内的元素位置数就可以访问元素：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the program terminates with an error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024649Z" creationid="大处着手小处着眼" creationdate="20160726T024649Z">
        <seg>若有错误，程序会终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It accesses the element that</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T014519Z" creationid="大处着手小处着眼" creationdate="20160725T014519Z">
        <seg>它访问对应于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can continue working on other things if a message does not arrive within that time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044525Z" creationid="Heromyth" creationdate="20170825T044525Z">
        <seg>如果消息超时它还会继续执行其他操作：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It defines an array that consists</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025506Z" creationid="大处着手小处着眼" creationdate="20160724T025431Z">
        <seg>它定义了一个可以存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It dispatches messages to message handling delegates.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235908Z" creationid="Heromyth" creationdate="20170824T235908Z">
        <seg>它通过消息处理委托来处理消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It identifies the robots by the robot ids that are sent as parts of the messages.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234512Z" creationid="Heromyth" creationdate="20170824T234449Z">
        <seg>它通过消息中的机器人 ID 来识别机器人。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is an even</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T030417Z" creationid="大处着手小处着眼" creationdate="20160726T030417Z">
        <seg>如果值被 2 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is commonly called without the function parentheses:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232316Z" creationid="Heromyth" creationdate="20170824T232316Z">
        <seg>通常调用它的时候不需要带圆括号：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is easy to see an example of such a problem simply by trying to allocate an object in a class destructor:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002034Z" creationid="Heromyth" creationdate="20170820T002034Z">
        <seg>尝试在类的析构函数中分配一个对象，通过这种方式可以轻易地重现这种的问题：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is the owner thread that $(I serializes) the printing process simply by receiving messages from its message box one by one.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235730Z" creationid="Heromyth" creationdate="20170824T235730Z">
        <seg>所有者线程仅仅是将收件箱中的消息一个一个取出来并$(I 按顺序)输出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is used differently because the $(STRING " %s") format string and the $(C &amp;) operator are not needed:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015633Z" creationid="Hipter" creationdate="20160712T015506Z">
        <seg>不同的是没有 $(STRING " %s") 格式字符串并且不需要 $(C &amp;) 运算符：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is very difficult to write correct concurrent programs if they are based on the traditional model of concurrency that involves lock-based data sharing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012308Z" creationid="Heromyth" creationdate="20170824T012308Z">
        <seg>若使用传统的基于锁的数据共享模型，则很难写出正确的程序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may be one</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235325Z" creationid="Heromyth" creationdate="20170824T235325Z">
        <seg>它既可能是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It might be greater if e.g. at least one of the 'é' characters is not encoded as a single code point but as the combination of an 'e' and a combining accute accent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152728Z" creationid="大处着手小处着眼" creationdate="20160715T013340Z">
        <seg>如果至少其中一个‘é’字符没有做为单个编码点编码，而是一个‘e’与一个组合重音符的组合，那么它就可能会更长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It produces a symbol by combining its first argument, a dot, and its second argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T134502Z" creationid="Heromyth" creationdate="20170805T134502Z">
        <seg>它会生成一个符号，其组成部分包含了它的第一个参数、一个小数点和它的第二个参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns $(C true) if the object is the same and $(C false) otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T014719Z" creationid="Hipter" creationdate="20160707T014719Z">
        <seg>如果是同一对象，返回 $(C true) ，否则为 $(C false) 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating over this slice and removing the element for each key by calling $(C .remove) would result in an empty associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T142255Z" creationid="Hipter" creationdate="20160711T005658Z">
        <seg>采用迭代此分片，并对每个键调用 $(C .remove) 函数来移除元素的方法，最后会得到一个空的关联数组：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating the loop while its value is less than $(C values.length) ensures that the loops are executed once per element.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T075021Z" creationid="大处着手小处着眼" creationdate="20160725T075021Z">
        <seg>当它的值小于 $(C values.length) 时，迭代循环可以保证每个元素只执行了一次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its $(C ~=) counterpart combines the two arrays and assigns the result back to the left-hand side array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T150131Z" creationid="大处着手小处着眼" creationdate="20160726T015640Z">
        <seg>$(C ~=) 将两边的数组连接起来，并把结果赋给左边那个数组：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its first argument is a symbol (e.g. a type or a variable name) and its second argument is a string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170805T133822Z" creationid="Heromyth" creationdate="20170805T133822Z">
        <seg>它的第一个参数是符号（如类型或者变量名），第二个参数是字符串。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its first parameter is the line that contains the data, and the rest of the parameters are used exacly like $(C readf()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T143027Z" creationid="Hipter" creationdate="20160712T033324Z">
        <seg>它的第一个参数是包含数据的输入行，而其余的参数就与 $(C readf()) 的一模一样：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its return value is $(C true) if a message has been received within that time, $(C false) otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043357Z" creationid="Heromyth" creationdate="20170825T043357Z">
        <seg>如果在指定时间内接收到了消息，函数返回值为 $(C true) ；如果超时则返回 $(C false)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005402Z" creationid="Heromyth" creationdate="20170820T005402Z">
        <seg>KEYWORDS=D 编程 语言 教程 书籍</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book arrays fixed-length dynamic</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T025230Z" creationid="大处着手小处着眼" creationdate="20160726T024956Z">
        <seg>KEYWORDS=D 编程语言 教程 定长 动态</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092726Z" creationid="Hipter" creationdate="20160709T092726Z">
        <seg>KEYWORDS=D 编程语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book novice beginner</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T045729Z" creationid="Heromyth" creationdate="20170801T100406Z">
        <seg>KEYWORDS=d programming language tutorial book novice beginner D 编程语言 教程 书籍 新手 初学者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book scope</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T050130Z" creationid="Hipter" creationdate="20160707T045824Z">
        <seg>KEYWORDS=D 语言编程教程 scope</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book string</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144252Z" creationid="大处着手小处着眼" creationdate="20160715T144252Z">
        <seg>KEYWORDS=D 语言教程 string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming language tutorial book user defined attributes UDA</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053942Z" creationid="Heromyth" creationdate="20170804T053942Z">
        <seg>KEYWORDS=d programming language tutorial book user defined attributes UDA D 编程语言 教程 书籍 自定义属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=d programming lesson book tutorial class</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013649Z" creationid="Hipter" creationdate="20160707T020932Z">
        <seg>KEYWORDS=D 语言 编程 教程 书籍 教程 类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial arrays solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T033049Z" creationid="大处着手小处着眼" creationdate="20160726T033032Z">
        <seg>KEYWORDS=D 语言编程教程 数组 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial associative arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T022406Z" creationid="Hipter" creationdate="20160711T022406Z">
        <seg>KEYWORDS=D语言教程 关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>KEYWORDS=programming in d tutorial strings solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T151258Z" creationid="大处着手小处着眼" creationdate="20160714T100248Z">
        <seg>KEYWORDS=D 语言教程 字符串 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's see this in a program that reads the number of the month from the user, and prints the number of days in that month:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051000Z" creationid="大处着手小处着眼" creationdate="20160725T084038Z">
        <seg>让我们来看一看这个程序，读取来自用户的月数，并输出当月的天数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's see this on a class that has various types of members:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022751Z" creationid="Hipter" creationdate="20160706T022751Z">
        <seg>让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like $(C finally), the three different $(C scope) statements are about executing expressions when leaving scopes:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T025251Z" creationid="Hipter" creationdate="20160707T025035Z">
        <seg>像 $(C finally)，下面三个不同的 $(C scope) 语句就是关于离开作用域时应执行的表达式：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAIN_TITLE=D.ershane Solutions
CLASS=solution
COZUM_BOLUMU = $(H4 $0)
LANG=en
LANGUAGE=english
SUB_AUTHOR=</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014830Z" creationid="Heromyth" creationdate="20170718T104957Z">
        <seg>MAIN_TITLE=D 语言答案
CLASS=答案
COZUM_BOLUMU = $(H4 $0)
LANG=zh-cn
LANGUAGE=chinese
SUB_AUTHOR=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAIN_TITLE=Programming in D
SUB_MAIN_TITLE_DERSE_OZEL=– Tutorial and Reference
SUB_AUTHOR=Ali Çehreli
LANG=en
LANGUAGE=english</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170721T055442Z" creationid="Heromyth" creationdate="20170718T105151Z">
        <seg>MAIN_TITLE=D 编程语言
SUB_MAIN_TITLE_DERSE_OZEL=——教程与参考
SUB_AUTHOR=Ali Çehreli
LANG=zh-cn
LANGUAGE=chinese</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message passing normally involves more complicated communication in many kinds of programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234629Z" creationid="Heromyth" creationdate="20170824T234629Z">
        <seg>当然在许多程序中消息传递不止这么简单。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages may be composed of any type and any number of variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054103Z" creationid="Heromyth" creationdate="20170824T054103Z">
        <seg>任何类型任何长短的数据都可以被称为消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Messages that do not match the handlers that are specified earlier in the argument list always match a $(C Variant) handler:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043113Z" creationid="Heromyth" creationdate="20170825T043113Z">
        <seg>如果消息无法与参数列表前面指定的各个处理函数相匹配，那么它们将会与一个 $(C Variant) 类型的处理函数匹配：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More features will be introduced later in $(LINK2 /ders/d.en/slices.html, the Slices and Other Array Features chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T014118Z" creationid="大处着手小处着眼" creationdate="20160720T022422Z">
        <seg>更多功能将在后面 $(LINK2 /ders/d.cn/slices.html, 分片和其他数组功能一章) 介绍。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, the programs that are produced by a compiler can usually run only on a specific platform; to run on a different kind of processor or on a different operating system, the program would have to be recompiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004923Z" creationid="Heromyth" creationdate="20170820T004923Z">
        <seg>另外，编译器往往是针对某一特定平台进行编译，程序需要重新编译以在不同的处理器或操作系统上运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the features that we have seen for structs in the following chapters apply to classes as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T123741Z" creationid="Heromyth" creationdate="20170819T123741Z">
        <seg>在下面的章节中我们已经看到结构的大部分特性也适用于类：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MyClass variable;   // does not reference an object</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T130525Z" creationid="Heromyth" creationdate="20170819T130525Z">
        <seg>MyClass variable;   // 没有引用对象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that I have chosen the name of the array variable as plural to avoid confusing it with a single-valued variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T030859Z" creationid="大处着手小处着眼" creationdate="20160720T030859Z">
        <seg>请注意，我选择了数组变量的名字为复数，以避免它与单值变量混淆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the constructor copies the $(C s) member explicitly by the $(C .dup) property of arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T023408Z" creationid="Hipter" creationdate="20160706T023408Z">
        <seg>注意，构造函数通过数组的  $(C .dup) 属性显式复制 $(C s) 成员。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, a program that did not use an array would have to have 20 variable definitions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T081416Z" creationid="大处着手小处着眼" creationdate="20160725T081416Z">
        <seg>另一方面，这个程序若不使用数组那将必须定义 20 个变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, having to compile the program every time it is changed is a complication and a potential source of human errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004905Z" creationid="Heromyth" creationdate="20170820T004905Z">
        <seg>另一方面，每次改变代码都必须重新编译，既复杂又易引起人为错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, some threads spend considerable amount of their time waiting for some event to occur like input from a user, data from a network connection, the completion of a $(C Thread.sleep) call, etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232105Z" creationid="Heromyth" creationdate="20170824T232105Z">
        <seg>与之相对的是消耗大量时间等待事件、用户输入、来自互联网的数据或调用了 $(C Thread.sleep) 等情况的线程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One solution is to have the worker catch the exception to be sent as a message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233821Z" creationid="Heromyth" creationdate="20170824T233821Z">
        <seg>一种解决方案是在工作线程中捕获潜在的由接收信息引发的异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other than in rare pathological cases, the time it takes to store or access an element is independent of the number of elements that are in the associative array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T100056Z" creationid="Hipter" creationdate="20160708T091750Z">
        <seg>除极个别情况外，一般存取单个元素所花费的时间不依赖于关联数组中元素的个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PROBLEM_COK_COZUMSUZ_METIN=the solutions will be posted later...</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170718T105604Z" creationid="Heromyth" creationdate="20170718T105604Z">
        <seg>PROBLEM_COK_COZUMSUZ_METIN=答案将随后公布……</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Partly because they are anonymous, it is not possible to access class objects directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131523Z" creationid="Heromyth" creationdate="20170819T131523Z">
        <seg>另一方面，类变量是用于访问类对象的一种语言特性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Plain arrays can use only integers as indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085309Z" creationid="Hipter" creationdate="20160708T084606Z">
        <seg>简单数组只能使用整型做索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Problems like a mismatched parenthesis, a missing semicolon, a misspelled keyword, etc. all cause compilation errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005135Z" creationid="Heromyth" creationdate="20170820T005135Z">
        <seg>诸如圆括号未匹配、分号丢失、关键字拼错等的问题都会引起编译错误。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Produce the full name that contains the proper capitalization of the first and last names.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143933Z" creationid="大处着手小处着眼" creationdate="20160715T143933Z">
        <seg>生成一个姓名首字母大写的全名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming languages are easier for humans to understand, closer to natural languages:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004159Z" creationid="Heromyth" creationdate="20170820T004120Z">
        <seg>编程语言更易于人类理解，更接近自然语言：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming languages do not have to deal with hardware constraints; their main purposes are ease of use and expressiveness.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004126Z" creationid="Heromyth" creationdate="20170820T004047Z">
        <seg>编程语言不处理底层硬件约束，它们的主要目的是使用和表现上的简易舒适。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it has to move some of the elements of the array one or more positions to the left.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170817T144512Z" creationid="Heromyth" creationdate="20170817T143944Z">
        <seg>由此，它不得不将原数组的某些元素向左移动一个或多个位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S      o;  // assume S is a struct type</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022841Z" creationid="Hipter" creationdate="20160706T022841Z">
        <seg>S      o;  // 假设 S 是一个结构类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024838Z" creationid="大处着手小处着眼" creationdate="20160726T024838Z">
        <seg>SUBTITLE=数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Arrays Solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032902Z" creationid="大处着手小处着眼" creationdate="20160726T032902Z">
        <seg>SUBTITLE=数组习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092636Z" creationid="Hipter" creationdate="20160709T092636Z">
        <seg>SUBTITLE=关联数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Associative Arrays Solutions</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T041125Z" creationid="Hipter" creationdate="20160711T022321Z">
        <seg>SUBTITLE=关联数组 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Classes</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020705Z" creationid="Hipter" creationdate="20160707T020705Z">
        <seg>SUBTITLE=类</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Compiler</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005319Z" creationid="Heromyth" creationdate="20170820T005319Z">
        <seg>SUBTITLE=编译器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Programming in D</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170726T011119Z" creationid="Heromyth" creationdate="20170726T011119Z">
        <seg>SUBTITLE=D 语言编程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Strings</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144233Z" creationid="大处着手小处着眼" creationdate="20160715T144233Z">
        <seg>SUBTITLE=字符串</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=Strings Solution</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T095608Z" creationid="大处着手小处着眼" creationdate="20160714T095608Z">
        <seg>SUBTITLE=字符串 习题解答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SUBTITLE=User Defined Attributes (UDA)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T053834Z" creationid="Heromyth" creationdate="20170804T053834Z">
        <seg>SUBTITLE=自定义属性（UDA）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Short for "read line", $(C readln()) reads until the end of the line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T015218Z" creationid="Hipter" creationdate="20160712T015218Z">
        <seg>它是“read line”的缩写，$(C readln()) 读取到行尾。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since multiple grades can be stored in a dynamic array, an associative array that maps from $(C string) to $(C int[]) would work here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170818T142319Z" creationid="Hipter" creationdate="20160711T014051Z">
        <seg>由于多个成绩可以用一个动态数组存储，从 $(C string) 到 $(C int[]) 映射的关联数组将能用在此处。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since that key is not in the container anymore, the second line would cause an exception to be thrown and the program to be terminated if that exception is not caught.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T033921Z" creationid="Hipter" creationdate="20160709T033921Z">
        <seg>由于键已不存在于容器中， 因而第二行将引发一个异常，如果异常没有被捕获，程序将终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since there is no other variable for $(C variable1)'s original object, that object will be destroyed by the garbage collector.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T031538Z" creationid="Hipter" creationdate="20160706T031538Z">
        <seg>由于 $(C variable1) 的原始对象没有别的变量，该对象将由垃圾回收器销毁。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals are defined with double quotes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T005323Z" creationid="Hipter" creationdate="20160712T075946Z">
        <seg>字符串字面量用双引号定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are a combination of the two features that we have covered in the last three chapters: characters and arrays.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T091043Z" creationid="Hipter" creationdate="20160711T091043Z">
        <seg>字符串是在过去三章中介绍的两种功能的组合：字符和数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such threads are said to be $(I I/O bound) at those times.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232121Z" creationid="Heromyth" creationdate="20170824T232121Z">
        <seg>这种线程被称作 $(I I/O 密集型)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Telling the CPU what to do is called $(I coding), and the instructions that are used when doing so are called $(I machine code).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003607Z" creationid="Heromyth" creationdate="20170820T003607Z">
        <seg>告知 CPU 要做什么事情这在过程叫做 $(I 编码)，而何时该做何事的指令则叫做 $(I 机器码)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That value can be compared against the expected number of data items so that the input can be validated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T144527Z" creationid="Hipter" creationdate="20160712T074124Z">
        <seg>该值可与数据项的预期数相比较，以便确定输入的有效性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T121050Z" creationid="Hipter" creationdate="20160711T120306Z">
        <seg>这个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C dmd) compiler switch to enable warnings as errors is $(C -w).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T005309Z" creationid="Heromyth" creationdate="20170820T005309Z">
        <seg>编译器 $(C dmd) 将警告视作错误的编译选项是 $(C -w)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C icmp()) function of the $(C std.string) module can be used when strings need to be compared regardless of lowercase and uppercase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T143727Z" creationid="大处着手小处着眼" creationdate="20160715T143727Z">
        <seg>无论小写大写，$(C std.string) 模块中的 $(C icmp()) 函数可用于字符串比较。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C king) variable does not have a $(C shape) member, the anonymous object does.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004408Z" creationid="Hipter" creationdate="20160707T004408Z">
        <seg>$(C king) 变量并没有 $(C shape) 成员，匿名对象有。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The $(C new) keyword constructs an anonymous $(I class object) and returns a $(I class variable).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T015858Z" creationid="Hipter" creationdate="20160707T015858Z">
        <seg>The $(C new) 关键字构造一个匿名 $(I class 对象) 并返回一个 $(I class 变量)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual concept that a class type represents in a program is provided by a class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T131148Z" creationid="Heromyth" creationdate="20170819T131148Z">
        <seg>实际的概念是，在程序中，一个类类型由一个类对象表示。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual object is not copied.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T012852Z" creationid="Hipter" creationdate="20160706T012821Z">
        <seg>实际的对象没有被复制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The attributes are determined by $(C __traits(getAttributes)) at compile time and the code is compiled according to those attributes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170804T043355Z" creationid="Heromyth" creationdate="20170804T043355Z">
        <seg>编译时可以通过 $(C __traits(getAttributes)) 来判定属性，而相应代码则会根据那些属性来编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters of the variables that are defined by these aliases cannot be modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T145527Z" creationid="Hipter" creationdate="20160712T081806Z">
        <seg>由这些别名定义的变量中的字符不可修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler does not allow accessing characters of an immutable array through a mutable slice.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T025135Z" creationid="Hipter" creationdate="20160713T025135Z">
        <seg>编译器不允许通过可变的切片访问不可变的字符数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concepts of $(I less) and $(I greater) are replaced with $(I before) and $(I after) in this hypothetical alphabet:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063636Z" creationid="大处着手小处着眼" creationdate="20160715T035221Z">
        <seg>在这个假设的字母表中，$(I 更少)和$(I 更多)的概念就被$(I 之前)和$(I 之后)代替：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value is specified as the second parameter of $(C .get()):
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T042602Z" creationid="Hipter" creationdate="20160709T042602Z">
        <seg>默认值被指定为 $(C .get()) 的第2个参数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definitions of those variables were the following:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T015831Z" creationid="大处着手小处着眼" creationdate="20160719T100148Z">
        <seg>下面各项是这些变量的定义：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The delegate that matches the type of the particular message handles it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235938Z" creationid="Heromyth" creationdate="20170824T235938Z">
        <seg>如果委托参数的类型与消息类型相同，它就会把消息交由对应的委托处理。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference is that it is the type of the key that is specified within the square brackets, not the length of the array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T093513Z" creationid="Hipter" creationdate="20160708T095042Z">
        <seg>不同的是方框号中指定的是键的类型，而不是数组的长度：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two are with the $(C while) loops: Both of the loop conditions use the $(C &lt;=) operator instead of the $(C &lt;) operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T084426Z" creationid="大处着手小处着眼" creationdate="20160726T031012Z">
        <seg>前两个与 $(C while) 循环有关： 循环条件都使用 $(C &lt;=) 运算符而不使用 $(C &lt;) 运算符。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following $(C static assert) checks both pass because $(C Person.name) has $(C Colored(Color.blue)) attribute:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104835Z" creationid="Heromyth" creationdate="20170810T104835Z">
        <seg>下面的两个 $(C static assert) 都会顺利通过，因为 $(C Person.name) 拥有 $(C Colored(Color.blue)) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following $(C static assert) passes because $(C Person.name) has $(C Encrypted) attribute:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170810T104459Z" creationid="Heromyth" creationdate="20170810T104459Z">
        <seg>下面的 $(C static assert) 会顺利通过，因为 $(C Person.name) 拥有 $(C Encrypted) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following function considers the $(C Encrypted) and $(C Colored) attributes of each member when producing the output:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170814T103912Z" creationid="Heromyth" creationdate="20170814T103912Z">
        <seg>下面这个函数在生成输出内容时会使用到每个成员的 $(C Encrypted) 和 $(C Colored) 属性：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following message consists of three parts:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233343Z" creationid="Heromyth" creationdate="20170824T233343Z">
        <seg>下面这个消息就是由三个部分组成：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods would empty the array in a single step.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T120214Z" creationid="Hipter" creationdate="20160711T012406Z">
        <seg>而下面的方法将用一步清空数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program also defines a special type named $(C Exit) used for communicating to the thread that it is time for it to exit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000525Z" creationid="Heromyth" creationdate="20170825T000525Z">
        <seg>程序还定义了一个 $(C Exit) 类型来通知线程退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following program sends the reason of the failure as a $(C CalculationFailure) message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045116Z" creationid="Heromyth" creationdate="20170825T045116Z">
        <seg>下面这个程序就把出错的原因封装在 $(C CalculationFailure) 消息中传递回去。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following worker handles messages by lambda functions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000458Z" creationid="Heromyth" creationdate="20170825T000458Z">
        <seg>下面这个工作线程使用 lambda 函数处理消息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grades can be appended to the dynamic arrays that are stored in the associative array:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T014729Z" creationid="Hipter" creationdate="20160711T014729Z">
        <seg>成绩能附加到存储在关联数组中的动态数组上：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial value of the elements depends on the type of the elements: 0 for $(C int), $(C double.nan) for $(C double), etc.
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082740Z" creationid="大处着手小处着眼" creationdate="20160725T082636Z">
        <seg>元素的初始值取决于元素类型：$(C int) 的为 0，$(C double) 的为 $(C double.nan) 等等。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intermediate owner thread below simply exits after sending two messages to its worker.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052047Z" creationid="Heromyth" creationdate="20170825T052047Z">
        <seg>下方程序中处在中间层的线程所有者在发送两条消息后就立即退出。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The lengths of those arrays cannot be changed during the execution of the program.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033144Z" creationid="大处着手小处着眼" creationdate="20160725T033144Z">
        <seg>在程序的执行过程中数组的长度不可修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference between a thread that is started with $(C spawn()) and a thread that is started with $(LINK2 /ders/d.en/parallelism.html, $(C task())) is the fact that $(C spawn()) makes it possible for threads to send messages to each other.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054618Z" creationid="Heromyth" creationdate="20170824T054618Z">
        <seg>使用 $(C spawn()) 启动的线程和使用 $(LINK2 /ders/d.en/parallelism.html, $(C task())) 启动的线程之间最大的差异在于，$(C spawn()) 允许线程间消息传递。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The movement of each robot is handled by a separate thread that takes three pieces of information when started:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234136Z" creationid="Heromyth" creationdate="20170824T234136Z">
        <seg>每个机器人的移动都是由一个独立的线程控制的。线程在启动时需要传入三个参数：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number of elements of an array is called the $(I length) of the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160723T143218Z" creationid="大处着手小处着眼" creationdate="20160723T142830Z">
        <seg>数组元素的个数称为数组的 $(I length)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is that the number of values associated with the variable is specified in square brackets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T043657Z" creationid="大处着手小处着眼" creationdate="20160720T022710Z">
        <seg>唯一的区别是，与变量相关联的值的个数在方括号中指定。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other differences outlined below are mostly due to this fact.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T124126Z" creationid="Heromyth" creationdate="20170819T124126Z">
        <seg>下面的其它不同大部分与此有关。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the program shows that the two threads, one that runs $(C main()) and the other that has been started by $(C spawn()), execute independently at the same time:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054941Z" creationid="Heromyth" creationdate="20170824T054941Z">
        <seg>这个程序的输出表明有两个线程：一个用于运行 $(C main())，另一个则由 $(C spawn()) 启动。它们同时相互独立地执行：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The overall performance of the system can be reduced if there are more threads that are busily working than the number of cores in the system.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T232021Z" creationid="Heromyth" creationdate="20170824T232021Z">
        <seg>如果忙碌的工作线程数量比系统中处理器核心数多，系统的整体性能就有可能下降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The owner can use the exception object or simply rethrow it:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T051851Z" creationid="Heromyth" creationdate="20170825T051851Z">
        <seg>所有者既可以处理异常对象也可以重新抛出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The owner simply prints every movement:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T234549Z" creationid="Heromyth" creationdate="20170824T234549Z">
        <seg>所有者会简单地将其运动情况输出：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program above would require a single change: replacing 5 with 20.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T081214Z" creationid="大处着手小处着眼" creationdate="20160725T081214Z">
        <seg>修改一下上面的程序：用 20 替换 5。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program is free to start other threads to be able to work on multiple tasks at the same time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012518Z" creationid="Heromyth" creationdate="20170824T012518Z">
        <seg>程序也可以自由地创建线程以实现在同一时间执行多个任务的功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program is written to read five numbers from the input and to place the squares of those numbers into an array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024424Z" creationid="大处着手小处着眼" creationdate="20160726T024424Z">
        <seg>程序要求从输入流中读取五个数字，并把这些数字放入一个数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program then attempts to print the squares to the output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T024527Z" creationid="大处着手小处着眼" creationdate="20160726T024527Z">
        <seg>然后程序会输出这些平方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same operators can be used with strings as well, but with a different meaning: strings are ordered $(I lexicographically).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T063719Z" creationid="大处着手小处着眼" creationdate="20160715T034841Z">
        <seg>同样的操作也能用于字符串，但含义不同：字符串按$(I 字典顺序)排序。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second line is the definition of a variable which stores ten consecutive values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T023429Z" creationid="大处着手小处着眼" creationdate="20160720T023429Z">
        <seg>第二行定义了一个存储连续十个值的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sender may have been busy temporarily or may have terminated with an exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T043234Z" creationid="Heromyth" creationdate="20170825T043234Z">
        <seg>消息的发送者可能正在忙碌或因异常终止。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The solution is to reset $(C i) to 0 before the second $(C while) loop, for example with the statement $(C i = 0;)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T032827Z" creationid="大处着手小处着眼" creationdate="20160726T032827Z">
        <seg>解决办法就是在第二个 $(C while) 循环前重设 $(C i) 为 0，比如使用语句 $(C i = 0;)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thread may be paused at any point between these steps to be continued after an unpredictable time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T054031Z" creationid="Heromyth" creationdate="20170824T054031Z">
        <seg>线程可能会暂停在这三步中的任何一步上，停顿一段时间后才会继续。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The threads continue sending messages back and forth until the owner sends a negative $(C int).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233003Z" creationid="Heromyth" creationdate="20170824T233003Z">
        <seg>工作线程会不停地返回消息直到线程所有者发送一个负的 $(C int)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two variables start providing access to the same object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170819T132015Z" creationid="Hipter" creationdate="20160706T021711Z">
        <seg>这两个变量可访问同一个对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two worker threads in the following program print four numbers each.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055246Z" creationid="Heromyth" creationdate="20170824T055246Z">
        <seg>下面程序中的两个工作线程分别打印四个数字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the member is encrypted if it has that attribute.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170815T042355Z" creationid="Heromyth" creationdate="20170815T042355Z">
        <seg>如果该成员拥有此属性，则它的值会被加密。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of the type that associative arrays $(I map from) are called $(I keys), rather than indexes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T023157Z" creationid="Hipter" creationdate="20160708T090042Z">
        <seg>关联数组用于$(I 映射)的类型的值叫$(I 键)，而不是索引。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that we have numbered as 1, 2, 3, 4, and 5 before are numbered as 0, 1, 2, 3, and 4 in the array.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T024332Z" creationid="大处着手小处着眼" creationdate="20160724T024332Z">
        <seg>以前被我们编号为 1、2、3、4 和 5 的值在数组中编号为 0、1、2、3 和 4。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The worker thread above can be tested by the following program:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000304Z" creationid="Heromyth" creationdate="20170825T000304Z">
        <seg>上面的工作线程可以用下面程序来测试：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their curly brackets are highlighted:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000641Z" creationid="Heromyth" creationdate="20170825T000641Z">
        <seg>它们的花括号已被高亮：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These languages have traditionally been used with an interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004705Z" creationid="Heromyth" creationdate="20170820T004705Z">
        <seg>因此，这些语言传统上就需使用解释器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These limits can be set for each user, for the whole system, or for something else.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T231902Z" creationid="Heromyth" creationdate="20170824T231902Z">
        <seg>这种限制可能是对用户的，也可能是对整个操作系统的，当然也可能是对其他某些级别。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These machine code instructions are determined under hardware constraints during the design stage of the architecture.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T003643Z" creationid="Heromyth" creationdate="20170820T003643Z">
        <seg>而这些机器码指令取决于底层架构设计阶段时的硬件约束。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are very fast data structures that work like mini databases and are used in many programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T233259Z" creationid="Hipter" creationdate="20160708T015014Z">
        <seg>它们是高速的数据结构，如迷你数据库一样地运作，在很多程序里都用到了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They grow automatically as key-value pairs are added.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T080331Z" creationid="Hipter" creationdate="20160708T143053Z">
        <seg>它们随着键值对的添加而自动增长。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They map the values of one type to the values of another type.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T085824Z" creationid="Hipter" creationdate="20160708T085824Z">
        <seg>它们映射一种类型的值到另一种类型的值上。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They take the starting number as the thread function parameter:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055311Z" creationid="Heromyth" creationdate="20170824T055311Z">
        <seg>线程函数的参数为初始数字：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows the owner to catch such exceptions:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T044642Z" creationid="Heromyth" creationdate="20170825T044642Z">
        <seg>它使得所有者线程可以捕获工作线程的异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This array is used to hold the number</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025543Z" creationid="大处着手小处着眼" creationdate="20160724T025543Z">
        <seg>这个数组用于存储</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior cannot be changed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T020610Z" creationid="Hipter" creationdate="20160707T020610Z">
        <seg>该行为不能被修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be demonstrated by printing the entire table:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T145930Z" creationid="Hipter" creationdate="20160708T145930Z">
        <seg>这可以通过打印整个表来验证：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This causes an $(C OwnerTerminated) exception to be thrown at the worker thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052101Z" creationid="Heromyth" creationdate="20170825T052101Z">
        <seg>这会导致工作线程抛出 $(C OwnerTerminated) 异常：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction has an important consequence when  $(LINK2 /ders/d.en/function_parameters.html, passing associative arrays to functions).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T144154Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>当 $(LINK2 /ders/d.cn/function_parameters.html, 传关联数组给函数) 时，这种区分具有重要意义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This fact is reflected in the $(C .length) property of strings:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160714T012504Z" creationid="大处着手小处着眼" creationdate="20160714T012504Z">
        <seg>这个事实反映在字符串的 $(C .length) property 上：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function must create and return a new class object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022554Z" creationid="Hipter" creationdate="20160706T022554Z">
        <seg>该函数必须创建并返回一个新的类对象。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an important difference that affects the way attributes are used at compile time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T055247Z" creationid="Heromyth" creationdate="20170803T055247Z">
        <seg>它们有着明显的差异，它会对编译时属性的使用方式产生影响。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because garbage collectors are not required to guarantee that the object and its members are finalized in any specific order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001705Z" creationid="Heromyth" creationdate="20170820T001705Z">
        <seg>这是因为垃圾回收器没有被要求保证该对象及其成员按任何特定顺序终结。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because garbage collectors are not required to guarantee that they can allocate new objects during a garbage collection cycle.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T001831Z" creationid="Heromyth" creationdate="20170820T001831Z">
        <seg>这是因为垃圾回收器没有被要求保证在垃圾回收周期内能分配新的对象。)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because later code may depend on previous variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T045157Z" creationid="Hipter" creationdate="20160707T045157Z">
        <seg>这是因为后边的代码依赖于前边的变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not possible nor necessary when a single array stores all the values under a single name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T022048Z" creationid="大处着手小处着眼" creationdate="20160724T021904Z">
        <seg>让一个数组在一个名字下存储所有的值，那是不可能也没必要的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is so that the program has a way of determining whether the input consisted of a complete line or whether the end of input has been reached:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160712T020302Z" creationid="Hipter" creationdate="20160712T020302Z">
        <seg>这就让程序有办法确定输入是否包含一条完整语句或者输入是否已结束： 
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the owner thread:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233119Z" creationid="Heromyth" creationdate="20170824T233119Z">
        <seg>这个就是所有者线程，如下所示：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be seen as a limitation for some applications.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T085053Z" creationid="Hipter" creationdate="20160709T085053Z">
        <seg>对某些程序来说可能是个限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ordering takes each character's Unicode code to be its place in a hypothetical grand Unicode alphabet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T035023Z" creationid="大处着手小处着眼" creationdate="20160715T035023Z">
        <seg>这种排序需要在一个假设的大字母表中让每个字符的 Unicode 编码找到它的位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This produced program is responsible for the execution of the instructions that were written by the programmer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T004745Z" creationid="Heromyth" creationdate="20170820T004745Z">
        <seg>而后，这个被生成的程序负责执行程序员写就的指令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variation can confuse new programmers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T104312Z" creationid="大处着手小处着眼" creationdate="20160724T024418Z">
        <seg>这种变化可能会让编程新手感到困惑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid dealing with this and many other Unicode issues, consider using a Unicode-aware text manipulation library in your programs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T152807Z" creationid="大处着手小处着眼" creationdate="20160715T014621Z">
        <seg>为避免处理这种以及许多其它的 Unicode 问题，在你的程序里就要考虑使用一个支持 Unicode 的文本处理库。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To be compatible with arrays, this function may be named $(C dup()).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T022458Z" creationid="Hipter" creationdate="20160706T022458Z">
        <seg>为与数组兼容，该函数可以命名为 $(C dup()).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To change their lengths, the source code must be modified and the program must be recompiled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T033354Z" creationid="大处着手小处着眼" creationdate="20160725T033229Z">
        <seg>要修改长度，就必须修改源代码，而且程序必须重新编译。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Treat the value &lt;span style="white-space: nowrap"&gt;-1&lt;/span&gt; specially to determine the end of the numbers; do not process that value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051620Z" creationid="大处着手小处着眼" creationdate="20160726T022945Z">
        <seg>并专门用值 &lt;span style="white-space: nowrap"&gt;-1&lt;/span&gt; 来确定数字的结束；不处理该值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, $(C addend) is accessible only in the $(C try) block, where it is defined.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T022824Z" creationid="Hipter" creationdate="20160707T022824Z">
        <seg>不幸的是，$(C addend) 只能在定义它的 $(C try) 块里访问。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structs, class objects cannot be constructed by the $(C {&amp;nbsp;}) syntax.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160706T032515Z" creationid="Hipter" creationdate="20160706T032515Z">
        <seg>不像结构，类对象不能由 $(C {&amp;nbsp;}) 语法构造。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User defined attributes is purely a compile-time feature.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170720T041606Z" creationid="Heromyth" creationdate="20170720T041606Z">
        <seg>自定义属性完全是一项编译时功能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using an array in a way that would require allocating a new memory block for the elements is undefined behavior as well:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002426Z" creationid="Heromyth" creationdate="20170820T002426Z">
        <seg>用这种方式使用一个数组，那将需要为未定义行为的元素分配一个新的内存块：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using such a specific type is more expressive than sending the arbitrary value of -1 like it was done in the previous example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000550Z" creationid="Heromyth" creationdate="20170825T000550Z">
        <seg>相对于使用像 -1 这样的任意值，用一个特定的类型来传递特定的消息会让程序更易读。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables which only store a single value are called scalar variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T044240Z" creationid="大处着手小处着眼" creationdate="20160720T030929Z">
        <seg>只存储一个值的变量称为标量变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can contrast the two definitions as follows:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T022850Z" creationid="大处着手小处着眼" creationdate="20160720T022850Z">
        <seg>我们可以对比两种定义如下：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can see this in the output above by the fact that $(C worker()) continues executing even after $(C main()) exits after printing "main is done."
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T055208Z" creationid="Heromyth" creationdate="20170824T055208Z">
        <seg>从上面的输出中我们可以看到，在函数 $(C main()) 输出 “main is done.” 并退出之后，$(C worker()) 仍然在继续执行。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have already seen this above when assigning to an element of an array:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T083358Z" creationid="大处着手小处着眼" creationdate="20160725T083358Z">
        <seg>这在上面给数组的元素赋值时我们已经看到：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T011230Z" creationid="Hipter" creationdate="20160711T011230Z">
        <seg>在下一章我们将</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover message passing in this chapter and data sharing in the next chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T012330Z" creationid="Heromyth" creationdate="20170824T012330Z">
        <seg>我们将会在本章中学习到消息传递，在下一章中学习数据共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover the $(C pure) keyword in $(LINK2 /ders/d.en/functions_more.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T013623Z" creationid="Heromyth" creationdate="20170819T134146Z">
        <seg>我们会在$(LINK2 /ders/d.cn/functions_more.html, 后面章节)对关键字 $(C pure) 进行讲解。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will cover these concepts in later chapters.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T030254Z" creationid="Hipter" creationdate="20160708T144231Z">
        <seg>在稍后的章节中我们将涵盖这些概念。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see Phobos ranges in a later chapter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T124954Z" creationid="大处着手小处着眼" creationdate="20160714T094241Z">
        <seg>在稍后的一章中我们将看到 Phobos 的 range。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see an example of this difference below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170803T055422Z" creationid="Heromyth" creationdate="20170803T055422Z">
        <seg>下面来看一个与该差异有关的例子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see exceptions in $(LINK2 /ders/d.en/exceptions.html, a later chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T034341Z" creationid="Hipter" creationdate="20160708T081001Z">
        <seg>在 $(LINK2 /ders/d.cn/exceptions.html, 稍后的一章) 中我们将看到异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see in $(LINK2 /ders/d.en/inheritance.html, the next chapter) how the definition of $(C toString) can be changed by the $(C override) keyword.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T013604Z" creationid="Hipter" creationdate="20160707T013604Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html, 下一章节) 我们将看到怎样通过$(C override) 关键字来修改 $(C toString) 的定义。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233855Z" creationid="Heromyth" creationdate="20170824T233855Z">
        <seg>随后就会看到这个。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this concept later in $(LINK2 /ders/d.en/inheritance.html, the Inheritance chapter).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T011019Z" creationid="Hipter" creationdate="20160707T005801Z">
        <seg>在 $(LINK2 /ders/d.cn/inheritance.html,继承章节) 我们将看到相关内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see this in a later chapter.)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013507Z" creationid="大处着手小处着眼" creationdate="20160726T013507Z">
        <seg>我们将在后面的章节中看到这一点。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will see user-defined types in later chapters.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141854Z" creationid="Hipter" creationdate="20160708T141751Z">
        <seg>在稍后的章节中我们将看到用户定义类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will use the $(C dayNumbers) associative array in the examples below.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160708T141603Z" creationid="Hipter" creationdate="20160708T141603Z">
        <seg>在下面的例子中我们将使用 $(C dayNumbers) 关联数组。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a message arrives, it is compared to the message type of each delegate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T235924Z" creationid="Heromyth" creationdate="20170824T235924Z">
        <seg>当它接收到消息时，它会比较消息类型与委托的参数类型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a worker that has been started by $(C spawnLinked()) terminates, a $(C LinkTerminated) exception is thrown at the owner:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052327Z" creationid="Heromyth" creationdate="20170825T052327Z">
        <seg>当由 $(C spawnLinked()) 创建的线程终止时，拥有者线程将会抛出 $(C LinkTerminated) 异常。
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When accessing elements, the $(C []) characters are written after the name of the array and specify the number of the element that is being accessed:</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025224Z" creationid="大处着手小处着眼" creationdate="20160724T025224Z">
        <seg>访问元素时，$(C []) 写在数组名称之后，并指定要访问的元素位置数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining arrays, the $(C []) characters are written after the type of the elements and specify the number of elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160724T025046Z" creationid="大处着手小处着眼" creationdate="20160724T025046Z">
        <seg>当我们定义数组时，$(C []) 写在元素类型之后，并指定元素个数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When reading strings from the input, the control character that corresponds to the Enter key that is pressed at the end of the input becomes a part of the string as well.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T144811Z" creationid="Hipter" creationdate="20160711T092900Z">
        <seg>当从输入中读取字符串，输入结束时按的 Enter 键对应的控制字符将变成字符串的一部分。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that exact syntax is desired, properties should be preferred, which will be explained in $(LINK2 /ders/d.en/property.html, a later chapter).)
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T004716Z" creationid="Hipter" creationdate="20160707T004716Z">
        <seg>若确实需要这样的语法，应该首选属性，这将在 $(LINK2 /ders/d.cn/property.html, 后面的章节) 中解释。)
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the length can change during the execution of the program, that array is a $(I dynamic array).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T085342Z" creationid="大处着手小处着眼" creationdate="20160725T032258Z">
        <seg>当长度可以在程序的执行过程中进行修改时，该数组就是一个$(I 动态数组)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also think of it as defining ten variables of the same type, or as defining an array, for short.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160720T024941Z" creationid="大处着手小处着眼" creationdate="20160720T024926Z">
        <seg>你也可以把它定义为同类型的十个变量，或作为数组定义的简称。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply this guideline blindly unless there are compilation errors:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T051126Z" creationid="Hipter" creationdate="20160707T012523Z">
        <seg>若没有编译错误，您可以闭着眼睛按教程来：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can determine whether a number is odd or even using the $(C %) (remainder) operator.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T051702Z" creationid="大处着手小处着眼" creationdate="20160726T023927Z">
        <seg>使用 $(C %)（求余数）运算符来确定数字是奇数还是偶数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see the functions of this module at $(LINK2 http://dlang.org/phobos/std_string.html, its online documentation).</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160718T153950Z" creationid="大处着手小处着眼" creationdate="20160715T143802Z">
        <seg>在 $(LINK2 http://dlang.org/phobos/std_string.html, 它的在线文档) 中你可以看到这个模块的各个函数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may find especially the Phobos ranges confusing at this point.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T105630Z" creationid="大处着手小处着眼" creationdate="20160714T094151Z">
        <seg>此刻你可能会发现 Phobos 的 range 尤其让人迷惑。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have to define variables of that exact type:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160722T105723Z" creationid="大处着手小处着眼" creationdate="20160715T144129Z">
        <seg>您可能就需要定义该类型的变量：
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You will notice that the program will not print the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T031442Z" creationid="大处着手小处着眼" creationdate="20160726T031442Z">
        <seg>你将注意到程序不会输出结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= 360;               // array is now equal to [7, 360]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013941Z" creationid="大处着手小处着眼" creationdate="20160726T013941Z">
        <seg>array ~= 360;               // 数组现在等于 [7, 360]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= 7;                 // array is now equal to [7]</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013932Z" creationid="大处着手小处着眼" creationdate="20160726T013932Z">
        <seg>array ~= 7;                 // 数组现在等于 [7]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array ~= [ 30, 40 ];        // array is now equal to [7, 360, 30, 40]
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013952Z" creationid="大处着手小处着眼" creationdate="20160726T013952Z">
        <seg>array ~= [ 30, 40 ];        // 数组现在等于 [7, 360, 30, 40]
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>array.length = 5;       // now has 5 elements
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072325Z" creationid="大处着手小处着眼" creationdate="20160725T072325Z">
        <seg>array.length = 5;       // 现在有 5 个元素
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto arr = [ 1 ];    // ← WRONG: Allocates indirectly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002459Z" creationid="Heromyth" creationdate="20170820T002459Z">
        <seg>auto arr = [ 1 ];    // ← 错误：在类的析构函数里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto c = new C();    // ← WRONG: Allocates explicitly</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170820T002104Z" creationid="Heromyth" creationdate="20170820T002104Z">
        <seg>auto c = new C();    // ← 错误：在类的析构函数里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto floating = message[2];    // of type double
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233539Z" creationid="Heromyth" creationdate="20170824T233539Z">
        <seg>auto floating = message[2];    // double 类型
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto integer  = message[1];    // of type int</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233528Z" creationid="Heromyth" creationdate="20170824T233528Z">
        <seg>auto integer  = message[1];    // int 类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto m = receiveOnly!int(); // ← An exception is</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052125Z" creationid="Heromyth" creationdate="20170825T052125Z">
        <seg>auto m = receiveOnly!int(); // ← 如果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto message = receiveOnly!double();    $(CODE_NOTE Expecting $(HILITE double))
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233709Z" creationid="Heromyth" creationdate="20170824T233709Z">
        <seg>auto message = receiveOnly!double();    $(CODE_NOTE 期望 $(HILITE double))
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>auto sender   = message[0];    // of type Tid</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233520Z" creationid="Heromyth" creationdate="20170824T233520Z">
        <seg>auto sender   = message[0];    // Tid 类型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>break;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070307T072716Z" creationid="ZXP" creationdate="20070307T072716Z">
        <seg>break;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>calculator.send("hello");  // ← incorrect input</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T045011Z" creationid="Heromyth" creationdate="20170825T045011Z">
        <seg>calculator.send("hello");  // ← 错误的输入</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>dayNumbers.clear;    // The associative array becomes empty
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T132349Z" creationid="Hipter" creationdate="20160709T034649Z">
        <seg>dayNumbers.clear;    // 清空关联数组
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>double[5] values;     // elements are all double.nan
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T082939Z" creationid="大处着手小处着眼" creationdate="20160725T082929Z">
        <seg>double[5] values;     // 元素都是 double.nan
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>elements →  | 31 | 28 | 31 | 30 | 31 | 30 | 31 | 31 | 30 | 31 | 30 | 31 |
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024159Z" creationid="大处着手小处着眼" creationdate="20160725T024159Z">
        <seg>元素 →  | 31 | 28 | 31 | 30 | 31 | 30 | 31 | 31 | 30 | 31 | 30 | 31 |
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>grades["emre"] = 85;   // ← Overwrites the previous grade!</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T092525Z" creationid="Hipter" creationdate="20160709T092525Z">
        <seg>grades["emre"] = 85;   // ← 覆盖前一个成绩！</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>indexes →     0    1    2    3    4    5    6    7    8    9   10   11</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T024151Z" creationid="大处着手小处着眼" creationdate="20160725T024151Z">
        <seg>索引 →     0    1    2    3    4    5    6    7    8    9   10   11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[10] allOnes = 1;    // All of the elements are set to 1
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T012107Z" creationid="大处着手小处着眼" creationdate="20160726T012107Z">
        <seg>int[10] allOnes = 1;    // 所有的元素都设置为 1
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[] array;                // empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T013851Z" creationid="大处着手小处着眼" creationdate="20160726T013851Z">
        <seg>int[] array;                // 空数组</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>int[] array;            // initially empty</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160725T072313Z" creationid="大处着手小处着眼" creationdate="20160725T072313Z">
        <seg>int[] array;            // 初始时为空</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>number = int.init;    // 0 for int
---
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160711T133427Z" creationid="Hipter" creationdate="20160709T084837Z">
        <seg>number = int.init;    // int 值：0 
---
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ownerTid.send("hello");    $(CODE_NOTE Sending $(HILITE string))
}</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170824T233731Z" creationid="Heromyth" creationdate="20170824T233731Z">
        <seg>ownerTid.send("hello");    $(CODE_NOTE 发送 $(HILITE string))
}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return;</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="ZXP" changedate="20070307T073114Z" creationid="ZXP" creationdate="20070307T073114Z">
        <seg>return;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← now compiles
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160713T160846Z" creationid="Hipter" creationdate="20160713T160846Z">
        <seg>string result = (s ~ '.')$(HILITE .idup);   // ← 现在可以编译
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>string s = "résumé"c;   // same as "résumé"</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160715T031247Z" creationid="大处着手小处着眼" creationdate="20160715T031247Z">
        <seg>string s = "résumé"c;   // 与“résumé”一样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>variable</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Tradoser" changedate="20070103T042255Z" creationid="Tradoser" creationdate="20070103T042255Z">
        <seg>变数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>worker.send(-1);        // ← to terminate the worker
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T000336Z" creationid="Heromyth" creationdate="20170825T000336Z">
        <seg>worker.send(-1);        // ← 终止工作线程
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>worker.send(2);
}  // ← Terminates after sending two messages</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170825T052113Z" creationid="Heromyth" creationdate="20170825T052113Z">
        <seg>worker.send(2);
}  // ← 发送两条消息后立刻终止</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNames[1]);   // prints "Tuesday"
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T090929Z" creationid="Hipter" creationdate="20160708T084244Z">
        <seg>writeln(dayNames[1]);   // 打印 “Tuesday”
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // prints 1
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032006Z" creationid="Hipter" creationdate="20160709T032006Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // 打印 1
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← run-time ERROR
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160709T032204Z" creationid="Hipter" creationdate="20160709T032204Z">
        <seg>writeln(dayNumbers["Tuesday"]);    // ← 运行时错误
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(result.length);     // prints 20</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015707Z" creationid="大处着手小处着眼" creationdate="20160726T015658Z">
        <seg>writeln(result.length);     // 输出 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>writeln(result.length);     // prints 30
}
---</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="大处着手小处着眼" changedate="20160726T015711Z" creationid="大处着手小处着眼" creationdate="20160726T015711Z">
        <seg>writeln(result.length);     // 输出 30
}
---</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>{} static, static this, static ~this))
$(LI $(LINK2 /ders/d.en/parameter_flexibility.html, Variable Number of Parameters) $(INDEX_KEYWORDS T[]... __MODULE__ __FILE__ __LINE__ __FUNCTION__ (and more)))
$(LI $(LINK2 /ders/d.en/function_overloading.html, Function Overloading))
$(LI $(LINK2 /ders/d.en/member_functions.html, Member Functions) $(INDEX_KEYWORDS toString))
$(LI $(LINK2 /ders/d.en/const_member_functions.html, const ref Parameters and const Member Functions) $(INDEX_KEYWORDS const ref, in ref, inout))
$(LI $(LINK2 /ders/d.en/special_functions.html, Constructor and Other Special Functions) $(INDEX_KEYWORDS this ~this this(this) opAssign @disable))
$(LI $(LINK2 /ders/d.en/operator_overloading.html, Operator Overloading) $(INDEX_KEYWORDS opUnary opBinary opEquals opCmp opIndex (and more)))
$(LI $(LINK2 /ders/d.en/class.html, Classes) $(INDEX_KEYWORDS class new))
$(LI $(LINK2 /ders/d.en/inheritance.html, Inheritance) $(INDEX_KEYWORDS : super override abstract))
$(LI $(LINK2 /ders/d.en/object.html, Object) $(INDEX_KEYWORDS toString opEquals opCmp toHash typeid TypeInfo))
$(LI $(LINK2 /ders/d.en/interface.html, Interfaces) $(INDEX_KEYWORDS interface static final))
$(LI $(LINK2 /ders/d.en/destroy.html, destroy and scoped) $(INDEX_KEYWORDS destroy scoped))
$(LI $(LINK2 /ders/d.en/modules.html, Modules and Libraries) $(INDEX_KEYWORDS import, module, static this, static ~this))
$(LI $(LINK2 /ders/d.en/encapsulation.html, Encapsulation and Protection Attributes) $(INDEX_KEYWORDS private protected public package))
$(LI $(LINK2 /ders/d.en/ufcs.html, Universal Function Call Syntax (UFCS)))
$(LI $(LINK2 /ders/d.en/property.html, Properties) $(INDEX_KEYWORDS @property))
$(LI $(LINK2 /ders/d.en/invariant.html, Contract Programming for Structs and Classes) $(INDEX_KEYWORDS invariant))
$(LI $(LINK2 /ders/d.en/templates.html, Templates))
$(LI $(LINK2 /ders/d.en/pragma.html, Pragmas))
$(LI $(LINK2 /ders/d.en/alias.html, alias and with) $(INDEX_KEYWORDS alias with))
$(LI $(LINK2 /ders/d.en/alias_this.html, alias this) $(INDEX_KEYWORDS alias this))
$(LI $(LINK2 /ders/d.en/pointers.html, Pointers) $(INDEX_KEYWORDS * &amp;))
$(LI $(LINK2 /ders/d.en/bit_operations.html, Bit Operations) $(INDEX_KEYWORDS ~ &amp; | ^ &gt;&gt; &gt;&gt;&gt; &lt;&lt;))
$(LI $(LINK2 /ders/d.en/cond_comp.html, Conditional Compilation) $(INDEX_KEYWORDS debug, version, static if, static assert, __traits))
$(LI $(LINK2 /ders/d.en/is_expr.html, is Expression) $(INDEX_KEYWORDS is()))
$(LI $(LINK2 /ders/d.en/lambda.html, Function Pointers, Delegates, and Lambdas) $(INDEX_KEYWORDS function delegate =&gt; toString))
$(LI $(LINK2 /ders/d.en/foreach_opapply.html, foreach with Structs and Classes) $(INDEX_KEYWORDS opApply empty popFront front (and more)))
$(LI $(LINK2 /ders/d.en/nested.html, Nested Functions, Structs, and Classes) $(INDEX_KEYWORDS static))
$(LI $(LINK2 /ders/d.en/union.html, Unions) $(INDEX_KEYWORDS union))
$(LI $(LINK2 /ders/d.en/goto.html, Labels and goto) $(INDEX_KEYWORDS goto))
$(LI $(LINK2 /ders/d.en/tuples.html, Tuples) $(INDEX_KEYWORDS tuple Tuple AliasSeq .tupleof foreach))
$(LI $(LINK2 /ders/d.en/templates_more.html, More Templates) $(INDEX_KEYWORDS template opDollar opIndex opSlice))
$(LI $(LINK2 /ders/d.en/functions_more.html, More Functions) $(INDEX_KEYWORDS inout pure nothrow @nogc @safe @trusted @system CTFE __ctfe))
$(LI $(LINK2 /ders/d.en/mixin.html, Mixins) $(INDEX_KEYWORDS mixin))
$(LI $(LINK2 /ders/d.en/ranges.html, Ranges) $(INDEX_KEYWORDS InputRange ForwardRange BidirectionalRange RandomAccessRange OutputRange))
$(LI $(LINK2 /ders/d.en/ranges_more.html, More Ranges) $(INDEX_KEYWORDS isInputRange ElementType hasLength inputRangeObject (and more)))
$(LI $(LINK2 /ders/d.en/parallelism.html, Parallelism) $(INDEX_KEYWORDS parallel task asyncBuf map amap reduce))
$(LI $(LINK2 /ders/d.en/concurrency.html, Message Passing Concurrency) $(INDEX_KEYWORDS spawn thisTid ownerTid send receive (and more)))
$(LI $(LINK2 /ders/d.en/concurrency_shared.html, Data Sharing Concurrency) $(INDEX_KEYWORDS synchronized, shared, shared static this, shared static ~this))
$(LI $(LINK2 /ders/d.en/fibers.html, Fibers) $(INDEX_KEYWORDS call yield))
$(LI $(LINK2 /ders/d.en/memory.html, Memory Management) $(INDEX_KEYWORDS calloc realloc emplace destroy .alignof))
$(LI $(LINK2 /ders/d.en/uda.html, User Defined Attributes (UDA)) $(INDEX_KEYWORDS @))
$(LI $(LINK2 /ders/d.en/operator_precedence.html, Operator Precedence))
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Heromyth" changedate="20170802T045619Z" creationid="Heromyth" creationdate="20170802T045619Z">
        <seg>{} static, static this, static ~this))
$(LI $(LINK2 /ders/d.cn/parameter_flexibility.html, 不定个数参数) $(INDEX_KEYWORDS T[]... __MODULE__ __FILE__ __LINE__ __FUNCTION__（等）))
$(LI $(LINK2 /ders/d.cn/function_overloading.html, 函数重载))
$(LI $(LINK2 /ders/d.cn/member_functions.html, 成员函数) $(INDEX_KEYWORDS toString))
$(LI $(LINK2 /ders/d.cn/const_member_functions.html, const ref 参数和 const 函数函数) $(INDEX_KEYWORDS const ref, in ref, inout))
$(LI $(LINK2 /ders/d.cn/special_functions.html, 构造函数和其他特殊函数) $(INDEX_KEYWORDS this ~this this(this) opAssign @disable))
$(LI $(LINK2 /ders/d.cn/operator_overloading.html, 运算符重载) $(INDEX_KEYWORDS opUnary opBinary opEquals opCmp opIndex（等）))
$(LI $(LINK2 /ders/d.cn/class.html, 类) $(INDEX_KEYWORDS class new))
$(LI $(LINK2 /ders/d.cn/inheritance.html, 继承) $(INDEX_KEYWORDS : super override abstract))
$(LI $(LINK2 /ders/d.cn/object.html, Object) $(INDEX_KEYWORDS toString opEquals opCmp toHash typeid TypeInfo))
$(LI $(LINK2 /ders/d.cn/interface.html, 接口) $(INDEX_KEYWORDS interface static final))
$(LI $(LINK2 /ders/d.cn/destroy.html, destroy 和 scoped) $(INDEX_KEYWORDS destroy scoped))
$(LI $(LINK2 /ders/d.cn/modules.html, 模块和库) $(INDEX_KEYWORDS import, module, static this, static ~this))
$(LI $(LINK2 /ders/d.cn/encapsulation.html, 封装和保护属性) $(INDEX_KEYWORDS private protected public package))
$(LI $(LINK2 /ders/d.cn/ufcs.html, 统一调用语法（UFCS）))
$(LI $(LINK2 /ders/d.cn/property.html, 特性) $(INDEX_KEYWORDS @property))
$(LI $(LINK2 /ders/d.cn/invariant.html, 结构和类的契约编程) $(INDEX_KEYWORDS invariant))
$(LI $(LINK2 /ders/d.cn/templates.html, 模板))
$(LI $(LINK2 /ders/d.cn/pragma.html, 编译指令))
$(LI $(LINK2 /ders/d.cn/alias.html, alias 和 with) $(INDEX_KEYWORDS alias with))
$(LI $(LINK2 /ders/d.cn/alias_this.html, alias this) $(INDEX_KEYWORDS alias this))
$(LI $(LINK2 /ders/d.cn/pointers.html, 指针) $(INDEX_KEYWORDS * &amp;))
$(LI $(LINK2 /ders/d.cn/bit_operations.html, 位运算) $(INDEX_KEYWORDS ~ &amp; | ^ &gt;&gt; &gt;&gt;&gt; &lt;&lt;))
$(LI $(LINK2 /ders/d.cn/cond_comp.html, 条件编译) $(INDEX_KEYWORDS debug, version, static if, static assert, __traits))
$(LI $(LINK2 /ders/d.cn/is_expr.html, is 表达式) $(INDEX_KEYWORDS is()))
$(LI $(LINK2 /ders/d.cn/lambda.html, 函数指针、委托和λ) $(INDEX_KEYWORDS function delegate =&gt; toString))
$(LI $(LINK2 /ders/d.cn/foreach_opapply.html, 将foreach用于结构和类) $(INDEX_KEYWORDS opApply empty popFront front（等）))
$(LI $(LINK2 /ders/d.cn/nested.html, 嵌套函数、结构和类) $(INDEX_KEYWORDS static))
$(LI $(LINK2 /ders/d.cn/union.html, 联合) $(INDEX_KEYWORDS union))
$(LI $(LINK2 /ders/d.cn/goto.html, 标签和 goto) $(INDEX_KEYWORDS goto))
$(LI $(LINK2 /ders/d.cn/tuples.html, 元组) $(INDEX_KEYWORDS tuple Tuple AliasSeq .tupleof foreach))
$(LI $(LINK2 /ders/d.cn/templates_more.html, 模板的更多内容) $(INDEX_KEYWORDS template opDollar opIndex opSlice))
$(LI $(LINK2 /ders/d.cn/functions_more.html, 函数的更多内容) $(INDEX_KEYWORDS inout pure nothrow @nogc @safe @trusted @system CTFE __ctfe))
$(LI $(LINK2 /ders/d.cn/mixin.html, 混入) $(INDEX_KEYWORDS mixin))
$(LI $(LINK2 /ders/d.cn/ranges.html, 范围) $(INDEX_KEYWORDS InputRange ForwardRange BidirectionalRange RandomAccessRange OutputRange))
$(LI $(LINK2 /ders/d.cn/ranges_more.html, 范围的更多内容) $(INDEX_KEYWORDS isInputRange ElementType hasLength inputRangeObject（等）))
$(LI $(LINK2 /ders/d.cn/parallelism.html, 并行性) $(INDEX_KEYWORDS parallel task asyncBuf map amap reduce))
$(LI $(LINK2 /ders/d.cn/concurrency.html, 消息传递并发) $(INDEX_KEYWORDS spawn thisTid ownerTid send receive (and more)))
$(LI $(LINK2 /ders/d.cn/concurrency_shared.html, 数据共享并发) $(INDEX_KEYWORDS synchronized, shared, shared static this, shared static ~this))
$(LI $(LINK2 /ders/d.cn/fibers.html, 纤程) $(INDEX_KEYWORDS call yield))
$(LI $(LINK2 /ders/d.cn/memory.html, 内存管理) $(INDEX_KEYWORDS calloc realloc emplace destroy .alignof))
$(LI $(LINK2 /ders/d.cn/uda.html, 自定义属性（UDA）) $(INDEX_KEYWORDS @))
$(LI $(LINK2 /ders/d.cn/operator_precedence.html, 运算符优先级))
)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：:
)</seg>
      </tuv>
      <tuv lang="ZH-CN" changeid="Hipter" changedate="20160707T104106Z" creationid="Hipter" creationdate="20160707T104106Z">
        <seg>该函数必须创建并返回一个新的类对象。让我们在有各种类型成员的类上看看它：
)</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
